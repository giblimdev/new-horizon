
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Neighborhood
 * 
 */
export type Neighborhood = $Result.DefaultSelection<Prisma.$NeighborhoodPayload>
/**
 * Model Landmark
 * 
 */
export type Landmark = $Result.DefaultSelection<Prisma.$LandmarkPayload>
/**
 * Model AccommodationType
 * 
 */
export type AccommodationType = $Result.DefaultSelection<Prisma.$AccommodationTypePayload>
/**
 * Model Destination
 * 
 */
export type Destination = $Result.DefaultSelection<Prisma.$DestinationPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model HotelGroup
 * 
 */
export type HotelGroup = $Result.DefaultSelection<Prisma.$HotelGroupPayload>
/**
 * Model HotelHighlight
 * 
 */
export type HotelHighlight = $Result.DefaultSelection<Prisma.$HotelHighlightPayload>
/**
 * Model HotelAmenity
 * 
 */
export type HotelAmenity = $Result.DefaultSelection<Prisma.$HotelAmenityPayload>
/**
 * Model RoomAmenity
 * 
 */
export type RoomAmenity = $Result.DefaultSelection<Prisma.$RoomAmenityPayload>
/**
 * Model AccessibilityOption
 * 
 */
export type AccessibilityOption = $Result.DefaultSelection<Prisma.$AccessibilityOptionPayload>
/**
 * Model HotelParking
 * 
 */
export type HotelParking = $Result.DefaultSelection<Prisma.$HotelParkingPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model HotelImage
 * 
 */
export type HotelImage = $Result.DefaultSelection<Prisma.$HotelImagePayload>
/**
 * Model HotelCard
 * 
 */
export type HotelCard = $Result.DefaultSelection<Prisma.$HotelCardPayload>
/**
 * Model HotelDetails
 * 
 */
export type HotelDetails = $Result.DefaultSelection<Prisma.$HotelDetailsPayload>
/**
 * Model HotelCardToHotelHighlight
 * 
 */
export type HotelCardToHotelHighlight = $Result.DefaultSelection<Prisma.$HotelCardToHotelHighlightPayload>
/**
 * Model HotelCardToLabel
 * 
 */
export type HotelCardToLabel = $Result.DefaultSelection<Prisma.$HotelCardToLabelPayload>
/**
 * Model HotelCardToAccessibilityOption
 * 
 */
export type HotelCardToAccessibilityOption = $Result.DefaultSelection<Prisma.$HotelCardToAccessibilityOptionPayload>
/**
 * Model HotelCardToHotelAmenity
 * 
 */
export type HotelCardToHotelAmenity = $Result.DefaultSelection<Prisma.$HotelCardToHotelAmenityPayload>
/**
 * Model HotelDetailsToRoomAmenity
 * 
 */
export type HotelDetailsToRoomAmenity = $Result.DefaultSelection<Prisma.$HotelDetailsToRoomAmenityPayload>
/**
 * Model DestinationToCity
 * 
 */
export type DestinationToCity = $Result.DefaultSelection<Prisma.$DestinationToCityPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.neighborhood`: Exposes CRUD operations for the **Neighborhood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Neighborhoods
    * const neighborhoods = await prisma.neighborhood.findMany()
    * ```
    */
  get neighborhood(): Prisma.NeighborhoodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landmark`: Exposes CRUD operations for the **Landmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Landmarks
    * const landmarks = await prisma.landmark.findMany()
    * ```
    */
  get landmark(): Prisma.LandmarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accommodationType`: Exposes CRUD operations for the **AccommodationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccommodationTypes
    * const accommodationTypes = await prisma.accommodationType.findMany()
    * ```
    */
  get accommodationType(): Prisma.AccommodationTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destination`: Exposes CRUD operations for the **Destination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinations
    * const destinations = await prisma.destination.findMany()
    * ```
    */
  get destination(): Prisma.DestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelGroup`: Exposes CRUD operations for the **HotelGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelGroups
    * const hotelGroups = await prisma.hotelGroup.findMany()
    * ```
    */
  get hotelGroup(): Prisma.HotelGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelHighlight`: Exposes CRUD operations for the **HotelHighlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelHighlights
    * const hotelHighlights = await prisma.hotelHighlight.findMany()
    * ```
    */
  get hotelHighlight(): Prisma.HotelHighlightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelAmenity`: Exposes CRUD operations for the **HotelAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelAmenities
    * const hotelAmenities = await prisma.hotelAmenity.findMany()
    * ```
    */
  get hotelAmenity(): Prisma.HotelAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomAmenity`: Exposes CRUD operations for the **RoomAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAmenities
    * const roomAmenities = await prisma.roomAmenity.findMany()
    * ```
    */
  get roomAmenity(): Prisma.RoomAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessibilityOption`: Exposes CRUD operations for the **AccessibilityOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessibilityOptions
    * const accessibilityOptions = await prisma.accessibilityOption.findMany()
    * ```
    */
  get accessibilityOption(): Prisma.AccessibilityOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelParking`: Exposes CRUD operations for the **HotelParking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelParkings
    * const hotelParkings = await prisma.hotelParking.findMany()
    * ```
    */
  get hotelParking(): Prisma.HotelParkingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelImage`: Exposes CRUD operations for the **HotelImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelImages
    * const hotelImages = await prisma.hotelImage.findMany()
    * ```
    */
  get hotelImage(): Prisma.HotelImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelCard`: Exposes CRUD operations for the **HotelCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCards
    * const hotelCards = await prisma.hotelCard.findMany()
    * ```
    */
  get hotelCard(): Prisma.HotelCardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelDetails`: Exposes CRUD operations for the **HotelDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelDetails
    * const hotelDetails = await prisma.hotelDetails.findMany()
    * ```
    */
  get hotelDetails(): Prisma.HotelDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelCardToHotelHighlight`: Exposes CRUD operations for the **HotelCardToHotelHighlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCardToHotelHighlights
    * const hotelCardToHotelHighlights = await prisma.hotelCardToHotelHighlight.findMany()
    * ```
    */
  get hotelCardToHotelHighlight(): Prisma.HotelCardToHotelHighlightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelCardToLabel`: Exposes CRUD operations for the **HotelCardToLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCardToLabels
    * const hotelCardToLabels = await prisma.hotelCardToLabel.findMany()
    * ```
    */
  get hotelCardToLabel(): Prisma.HotelCardToLabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelCardToAccessibilityOption`: Exposes CRUD operations for the **HotelCardToAccessibilityOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCardToAccessibilityOptions
    * const hotelCardToAccessibilityOptions = await prisma.hotelCardToAccessibilityOption.findMany()
    * ```
    */
  get hotelCardToAccessibilityOption(): Prisma.HotelCardToAccessibilityOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelCardToHotelAmenity`: Exposes CRUD operations for the **HotelCardToHotelAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCardToHotelAmenities
    * const hotelCardToHotelAmenities = await prisma.hotelCardToHotelAmenity.findMany()
    * ```
    */
  get hotelCardToHotelAmenity(): Prisma.HotelCardToHotelAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelDetailsToRoomAmenity`: Exposes CRUD operations for the **HotelDetailsToRoomAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelDetailsToRoomAmenities
    * const hotelDetailsToRoomAmenities = await prisma.hotelDetailsToRoomAmenity.findMany()
    * ```
    */
  get hotelDetailsToRoomAmenity(): Prisma.HotelDetailsToRoomAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destinationToCity`: Exposes CRUD operations for the **DestinationToCity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DestinationToCities
    * const destinationToCities = await prisma.destinationToCity.findMany()
    * ```
    */
  get destinationToCity(): Prisma.DestinationToCityDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Country: 'Country',
    City: 'City',
    Neighborhood: 'Neighborhood',
    Landmark: 'Landmark',
    AccommodationType: 'AccommodationType',
    Destination: 'Destination',
    Label: 'Label',
    HotelGroup: 'HotelGroup',
    HotelHighlight: 'HotelHighlight',
    HotelAmenity: 'HotelAmenity',
    RoomAmenity: 'RoomAmenity',
    AccessibilityOption: 'AccessibilityOption',
    HotelParking: 'HotelParking',
    Address: 'Address',
    HotelImage: 'HotelImage',
    HotelCard: 'HotelCard',
    HotelDetails: 'HotelDetails',
    HotelCardToHotelHighlight: 'HotelCardToHotelHighlight',
    HotelCardToLabel: 'HotelCardToLabel',
    HotelCardToAccessibilityOption: 'HotelCardToAccessibilityOption',
    HotelCardToHotelAmenity: 'HotelCardToHotelAmenity',
    HotelDetailsToRoomAmenity: 'HotelDetailsToRoomAmenity',
    DestinationToCity: 'DestinationToCity'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "country" | "city" | "neighborhood" | "landmark" | "accommodationType" | "destination" | "label" | "hotelGroup" | "hotelHighlight" | "hotelAmenity" | "roomAmenity" | "accessibilityOption" | "hotelParking" | "address" | "hotelImage" | "hotelCard" | "hotelDetails" | "hotelCardToHotelHighlight" | "hotelCardToLabel" | "hotelCardToAccessibilityOption" | "hotelCardToHotelAmenity" | "hotelDetailsToRoomAmenity" | "destinationToCity"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Neighborhood: {
        payload: Prisma.$NeighborhoodPayload<ExtArgs>
        fields: Prisma.NeighborhoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NeighborhoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NeighborhoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          findFirst: {
            args: Prisma.NeighborhoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NeighborhoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          findMany: {
            args: Prisma.NeighborhoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>[]
          }
          create: {
            args: Prisma.NeighborhoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          createMany: {
            args: Prisma.NeighborhoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NeighborhoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>[]
          }
          delete: {
            args: Prisma.NeighborhoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          update: {
            args: Prisma.NeighborhoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          deleteMany: {
            args: Prisma.NeighborhoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NeighborhoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NeighborhoodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>[]
          }
          upsert: {
            args: Prisma.NeighborhoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeighborhoodPayload>
          }
          aggregate: {
            args: Prisma.NeighborhoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNeighborhood>
          }
          groupBy: {
            args: Prisma.NeighborhoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<NeighborhoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.NeighborhoodCountArgs<ExtArgs>
            result: $Utils.Optional<NeighborhoodCountAggregateOutputType> | number
          }
        }
      }
      Landmark: {
        payload: Prisma.$LandmarkPayload<ExtArgs>
        fields: Prisma.LandmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          findFirst: {
            args: Prisma.LandmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          findMany: {
            args: Prisma.LandmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>[]
          }
          create: {
            args: Prisma.LandmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          createMany: {
            args: Prisma.LandmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>[]
          }
          delete: {
            args: Prisma.LandmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          update: {
            args: Prisma.LandmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          deleteMany: {
            args: Prisma.LandmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandmarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>[]
          }
          upsert: {
            args: Prisma.LandmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandmarkPayload>
          }
          aggregate: {
            args: Prisma.LandmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandmark>
          }
          groupBy: {
            args: Prisma.LandmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandmarkCountArgs<ExtArgs>
            result: $Utils.Optional<LandmarkCountAggregateOutputType> | number
          }
        }
      }
      AccommodationType: {
        payload: Prisma.$AccommodationTypePayload<ExtArgs>
        fields: Prisma.AccommodationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          findFirst: {
            args: Prisma.AccommodationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          findMany: {
            args: Prisma.AccommodationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>[]
          }
          create: {
            args: Prisma.AccommodationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          createMany: {
            args: Prisma.AccommodationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>[]
          }
          delete: {
            args: Prisma.AccommodationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          update: {
            args: Prisma.AccommodationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          deleteMany: {
            args: Prisma.AccommodationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccommodationTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>[]
          }
          upsert: {
            args: Prisma.AccommodationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          aggregate: {
            args: Prisma.AccommodationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodationType>
          }
          groupBy: {
            args: Prisma.AccommodationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationTypeCountAggregateOutputType> | number
          }
        }
      }
      Destination: {
        payload: Prisma.$DestinationPayload<ExtArgs>
        fields: Prisma.DestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findFirst: {
            args: Prisma.DestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findMany: {
            args: Prisma.DestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          create: {
            args: Prisma.DestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          createMany: {
            args: Prisma.DestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          delete: {
            args: Prisma.DestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          update: {
            args: Prisma.DestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          deleteMany: {
            args: Prisma.DestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          upsert: {
            args: Prisma.DestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          aggregate: {
            args: Prisma.DestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestination>
          }
          groupBy: {
            args: Prisma.DestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      HotelGroup: {
        payload: Prisma.$HotelGroupPayload<ExtArgs>
        fields: Prisma.HotelGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          findFirst: {
            args: Prisma.HotelGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          findMany: {
            args: Prisma.HotelGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>[]
          }
          create: {
            args: Prisma.HotelGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          createMany: {
            args: Prisma.HotelGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>[]
          }
          delete: {
            args: Prisma.HotelGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          update: {
            args: Prisma.HotelGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          deleteMany: {
            args: Prisma.HotelGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>[]
          }
          upsert: {
            args: Prisma.HotelGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelGroupPayload>
          }
          aggregate: {
            args: Prisma.HotelGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelGroup>
          }
          groupBy: {
            args: Prisma.HotelGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelGroupCountArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupCountAggregateOutputType> | number
          }
        }
      }
      HotelHighlight: {
        payload: Prisma.$HotelHighlightPayload<ExtArgs>
        fields: Prisma.HotelHighlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelHighlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelHighlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          findFirst: {
            args: Prisma.HotelHighlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelHighlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          findMany: {
            args: Prisma.HotelHighlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>[]
          }
          create: {
            args: Prisma.HotelHighlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          createMany: {
            args: Prisma.HotelHighlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelHighlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>[]
          }
          delete: {
            args: Prisma.HotelHighlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          update: {
            args: Prisma.HotelHighlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          deleteMany: {
            args: Prisma.HotelHighlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelHighlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelHighlightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>[]
          }
          upsert: {
            args: Prisma.HotelHighlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelHighlightPayload>
          }
          aggregate: {
            args: Prisma.HotelHighlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelHighlight>
          }
          groupBy: {
            args: Prisma.HotelHighlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelHighlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelHighlightCountArgs<ExtArgs>
            result: $Utils.Optional<HotelHighlightCountAggregateOutputType> | number
          }
        }
      }
      HotelAmenity: {
        payload: Prisma.$HotelAmenityPayload<ExtArgs>
        fields: Prisma.HotelAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findFirst: {
            args: Prisma.HotelAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findMany: {
            args: Prisma.HotelAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          create: {
            args: Prisma.HotelAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          createMany: {
            args: Prisma.HotelAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          delete: {
            args: Prisma.HotelAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          update: {
            args: Prisma.HotelAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          deleteMany: {
            args: Prisma.HotelAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          upsert: {
            args: Prisma.HotelAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          aggregate: {
            args: Prisma.HotelAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelAmenity>
          }
          groupBy: {
            args: Prisma.HotelAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityCountAggregateOutputType> | number
          }
        }
      }
      RoomAmenity: {
        payload: Prisma.$RoomAmenityPayload<ExtArgs>
        fields: Prisma.RoomAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findFirst: {
            args: Prisma.RoomAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findMany: {
            args: Prisma.RoomAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          create: {
            args: Prisma.RoomAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          createMany: {
            args: Prisma.RoomAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          delete: {
            args: Prisma.RoomAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          update: {
            args: Prisma.RoomAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          deleteMany: {
            args: Prisma.RoomAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          upsert: {
            args: Prisma.RoomAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          aggregate: {
            args: Prisma.RoomAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAmenity>
          }
          groupBy: {
            args: Prisma.RoomAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityCountAggregateOutputType> | number
          }
        }
      }
      AccessibilityOption: {
        payload: Prisma.$AccessibilityOptionPayload<ExtArgs>
        fields: Prisma.AccessibilityOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessibilityOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessibilityOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          findFirst: {
            args: Prisma.AccessibilityOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessibilityOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          findMany: {
            args: Prisma.AccessibilityOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>[]
          }
          create: {
            args: Prisma.AccessibilityOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          createMany: {
            args: Prisma.AccessibilityOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessibilityOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>[]
          }
          delete: {
            args: Prisma.AccessibilityOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          update: {
            args: Prisma.AccessibilityOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          deleteMany: {
            args: Prisma.AccessibilityOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessibilityOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessibilityOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>[]
          }
          upsert: {
            args: Prisma.AccessibilityOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessibilityOptionPayload>
          }
          aggregate: {
            args: Prisma.AccessibilityOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessibilityOption>
          }
          groupBy: {
            args: Prisma.AccessibilityOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessibilityOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessibilityOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AccessibilityOptionCountAggregateOutputType> | number
          }
        }
      }
      HotelParking: {
        payload: Prisma.$HotelParkingPayload<ExtArgs>
        fields: Prisma.HotelParkingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelParkingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelParkingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          findFirst: {
            args: Prisma.HotelParkingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelParkingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          findMany: {
            args: Prisma.HotelParkingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>[]
          }
          create: {
            args: Prisma.HotelParkingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          createMany: {
            args: Prisma.HotelParkingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelParkingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>[]
          }
          delete: {
            args: Prisma.HotelParkingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          update: {
            args: Prisma.HotelParkingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          deleteMany: {
            args: Prisma.HotelParkingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelParkingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelParkingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>[]
          }
          upsert: {
            args: Prisma.HotelParkingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelParkingPayload>
          }
          aggregate: {
            args: Prisma.HotelParkingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelParking>
          }
          groupBy: {
            args: Prisma.HotelParkingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelParkingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelParkingCountArgs<ExtArgs>
            result: $Utils.Optional<HotelParkingCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      HotelImage: {
        payload: Prisma.$HotelImagePayload<ExtArgs>
        fields: Prisma.HotelImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          findFirst: {
            args: Prisma.HotelImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          findMany: {
            args: Prisma.HotelImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>[]
          }
          create: {
            args: Prisma.HotelImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          createMany: {
            args: Prisma.HotelImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>[]
          }
          delete: {
            args: Prisma.HotelImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          update: {
            args: Prisma.HotelImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          deleteMany: {
            args: Prisma.HotelImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>[]
          }
          upsert: {
            args: Prisma.HotelImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelImagePayload>
          }
          aggregate: {
            args: Prisma.HotelImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelImage>
          }
          groupBy: {
            args: Prisma.HotelImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelImageCountArgs<ExtArgs>
            result: $Utils.Optional<HotelImageCountAggregateOutputType> | number
          }
        }
      }
      HotelCard: {
        payload: Prisma.$HotelCardPayload<ExtArgs>
        fields: Prisma.HotelCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          findFirst: {
            args: Prisma.HotelCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          findMany: {
            args: Prisma.HotelCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>[]
          }
          create: {
            args: Prisma.HotelCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          createMany: {
            args: Prisma.HotelCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>[]
          }
          delete: {
            args: Prisma.HotelCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          update: {
            args: Prisma.HotelCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          deleteMany: {
            args: Prisma.HotelCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelCardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>[]
          }
          upsert: {
            args: Prisma.HotelCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardPayload>
          }
          aggregate: {
            args: Prisma.HotelCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCard>
          }
          groupBy: {
            args: Prisma.HotelCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCardCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCardCountAggregateOutputType> | number
          }
        }
      }
      HotelDetails: {
        payload: Prisma.$HotelDetailsPayload<ExtArgs>
        fields: Prisma.HotelDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          findFirst: {
            args: Prisma.HotelDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          findMany: {
            args: Prisma.HotelDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>[]
          }
          create: {
            args: Prisma.HotelDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          createMany: {
            args: Prisma.HotelDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>[]
          }
          delete: {
            args: Prisma.HotelDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          update: {
            args: Prisma.HotelDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          deleteMany: {
            args: Prisma.HotelDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>[]
          }
          upsert: {
            args: Prisma.HotelDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsPayload>
          }
          aggregate: {
            args: Prisma.HotelDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelDetails>
          }
          groupBy: {
            args: Prisma.HotelDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<HotelDetailsCountAggregateOutputType> | number
          }
        }
      }
      HotelCardToHotelHighlight: {
        payload: Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>
        fields: Prisma.HotelCardToHotelHighlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCardToHotelHighlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCardToHotelHighlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          findFirst: {
            args: Prisma.HotelCardToHotelHighlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCardToHotelHighlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          findMany: {
            args: Prisma.HotelCardToHotelHighlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>[]
          }
          create: {
            args: Prisma.HotelCardToHotelHighlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          createMany: {
            args: Prisma.HotelCardToHotelHighlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCardToHotelHighlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>[]
          }
          delete: {
            args: Prisma.HotelCardToHotelHighlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          update: {
            args: Prisma.HotelCardToHotelHighlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          deleteMany: {
            args: Prisma.HotelCardToHotelHighlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCardToHotelHighlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelCardToHotelHighlightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>[]
          }
          upsert: {
            args: Prisma.HotelCardToHotelHighlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelHighlightPayload>
          }
          aggregate: {
            args: Prisma.HotelCardToHotelHighlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCardToHotelHighlight>
          }
          groupBy: {
            args: Prisma.HotelCardToHotelHighlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToHotelHighlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCardToHotelHighlightCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToHotelHighlightCountAggregateOutputType> | number
          }
        }
      }
      HotelCardToLabel: {
        payload: Prisma.$HotelCardToLabelPayload<ExtArgs>
        fields: Prisma.HotelCardToLabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCardToLabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCardToLabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          findFirst: {
            args: Prisma.HotelCardToLabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCardToLabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          findMany: {
            args: Prisma.HotelCardToLabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>[]
          }
          create: {
            args: Prisma.HotelCardToLabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          createMany: {
            args: Prisma.HotelCardToLabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCardToLabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>[]
          }
          delete: {
            args: Prisma.HotelCardToLabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          update: {
            args: Prisma.HotelCardToLabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          deleteMany: {
            args: Prisma.HotelCardToLabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCardToLabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelCardToLabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>[]
          }
          upsert: {
            args: Prisma.HotelCardToLabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToLabelPayload>
          }
          aggregate: {
            args: Prisma.HotelCardToLabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCardToLabel>
          }
          groupBy: {
            args: Prisma.HotelCardToLabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToLabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCardToLabelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToLabelCountAggregateOutputType> | number
          }
        }
      }
      HotelCardToAccessibilityOption: {
        payload: Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>
        fields: Prisma.HotelCardToAccessibilityOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCardToAccessibilityOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCardToAccessibilityOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          findFirst: {
            args: Prisma.HotelCardToAccessibilityOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCardToAccessibilityOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          findMany: {
            args: Prisma.HotelCardToAccessibilityOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>[]
          }
          create: {
            args: Prisma.HotelCardToAccessibilityOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          createMany: {
            args: Prisma.HotelCardToAccessibilityOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCardToAccessibilityOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>[]
          }
          delete: {
            args: Prisma.HotelCardToAccessibilityOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          update: {
            args: Prisma.HotelCardToAccessibilityOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          deleteMany: {
            args: Prisma.HotelCardToAccessibilityOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCardToAccessibilityOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelCardToAccessibilityOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>[]
          }
          upsert: {
            args: Prisma.HotelCardToAccessibilityOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToAccessibilityOptionPayload>
          }
          aggregate: {
            args: Prisma.HotelCardToAccessibilityOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCardToAccessibilityOption>
          }
          groupBy: {
            args: Prisma.HotelCardToAccessibilityOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToAccessibilityOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCardToAccessibilityOptionCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToAccessibilityOptionCountAggregateOutputType> | number
          }
        }
      }
      HotelCardToHotelAmenity: {
        payload: Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>
        fields: Prisma.HotelCardToHotelAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCardToHotelAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCardToHotelAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          findFirst: {
            args: Prisma.HotelCardToHotelAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCardToHotelAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          findMany: {
            args: Prisma.HotelCardToHotelAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>[]
          }
          create: {
            args: Prisma.HotelCardToHotelAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          createMany: {
            args: Prisma.HotelCardToHotelAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCardToHotelAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>[]
          }
          delete: {
            args: Prisma.HotelCardToHotelAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          update: {
            args: Prisma.HotelCardToHotelAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          deleteMany: {
            args: Prisma.HotelCardToHotelAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCardToHotelAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelCardToHotelAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>[]
          }
          upsert: {
            args: Prisma.HotelCardToHotelAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCardToHotelAmenityPayload>
          }
          aggregate: {
            args: Prisma.HotelCardToHotelAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCardToHotelAmenity>
          }
          groupBy: {
            args: Prisma.HotelCardToHotelAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToHotelAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCardToHotelAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCardToHotelAmenityCountAggregateOutputType> | number
          }
        }
      }
      HotelDetailsToRoomAmenity: {
        payload: Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>
        fields: Prisma.HotelDetailsToRoomAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelDetailsToRoomAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelDetailsToRoomAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          findFirst: {
            args: Prisma.HotelDetailsToRoomAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelDetailsToRoomAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          findMany: {
            args: Prisma.HotelDetailsToRoomAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>[]
          }
          create: {
            args: Prisma.HotelDetailsToRoomAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          createMany: {
            args: Prisma.HotelDetailsToRoomAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelDetailsToRoomAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>[]
          }
          delete: {
            args: Prisma.HotelDetailsToRoomAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          update: {
            args: Prisma.HotelDetailsToRoomAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          deleteMany: {
            args: Prisma.HotelDetailsToRoomAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelDetailsToRoomAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelDetailsToRoomAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>[]
          }
          upsert: {
            args: Prisma.HotelDetailsToRoomAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelDetailsToRoomAmenityPayload>
          }
          aggregate: {
            args: Prisma.HotelDetailsToRoomAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelDetailsToRoomAmenity>
          }
          groupBy: {
            args: Prisma.HotelDetailsToRoomAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelDetailsToRoomAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelDetailsToRoomAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<HotelDetailsToRoomAmenityCountAggregateOutputType> | number
          }
        }
      }
      DestinationToCity: {
        payload: Prisma.$DestinationToCityPayload<ExtArgs>
        fields: Prisma.DestinationToCityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationToCityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationToCityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          findFirst: {
            args: Prisma.DestinationToCityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationToCityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          findMany: {
            args: Prisma.DestinationToCityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>[]
          }
          create: {
            args: Prisma.DestinationToCityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          createMany: {
            args: Prisma.DestinationToCityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationToCityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>[]
          }
          delete: {
            args: Prisma.DestinationToCityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          update: {
            args: Prisma.DestinationToCityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          deleteMany: {
            args: Prisma.DestinationToCityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationToCityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationToCityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>[]
          }
          upsert: {
            args: Prisma.DestinationToCityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationToCityPayload>
          }
          aggregate: {
            args: Prisma.DestinationToCityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestinationToCity>
          }
          groupBy: {
            args: Prisma.DestinationToCityGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationToCityGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationToCityCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationToCityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    country?: CountryOmit
    city?: CityOmit
    neighborhood?: NeighborhoodOmit
    landmark?: LandmarkOmit
    accommodationType?: AccommodationTypeOmit
    destination?: DestinationOmit
    label?: LabelOmit
    hotelGroup?: HotelGroupOmit
    hotelHighlight?: HotelHighlightOmit
    hotelAmenity?: HotelAmenityOmit
    roomAmenity?: RoomAmenityOmit
    accessibilityOption?: AccessibilityOptionOmit
    hotelParking?: HotelParkingOmit
    address?: AddressOmit
    hotelImage?: HotelImageOmit
    hotelCard?: HotelCardOmit
    hotelDetails?: HotelDetailsOmit
    hotelCardToHotelHighlight?: HotelCardToHotelHighlightOmit
    hotelCardToLabel?: HotelCardToLabelOmit
    hotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionOmit
    hotelCardToHotelAmenity?: HotelCardToHotelAmenityOmit
    hotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityOmit
    destinationToCity?: DestinationToCityOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    Address: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    Address?: boolean | UserCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    neighborhoods: number
    landmarks: number
    addresses: number
    destinations: number
    DestinationToCity: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    neighborhoods?: boolean | CityCountOutputTypeCountNeighborhoodsArgs
    landmarks?: boolean | CityCountOutputTypeCountLandmarksArgs
    addresses?: boolean | CityCountOutputTypeCountAddressesArgs
    destinations?: boolean | CityCountOutputTypeCountDestinationsArgs
    DestinationToCity?: boolean | CityCountOutputTypeCountDestinationToCityArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountNeighborhoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeighborhoodWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountLandmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandmarkWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDestinationToCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationToCityWhereInput
  }


  /**
   * Count Type NeighborhoodCountOutputType
   */

  export type NeighborhoodCountOutputType = {
    addresses: number
  }

  export type NeighborhoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | NeighborhoodCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * NeighborhoodCountOutputType without action
   */
  export type NeighborhoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeighborhoodCountOutputType
     */
    select?: NeighborhoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NeighborhoodCountOutputType without action
   */
  export type NeighborhoodCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type AccommodationTypeCountOutputType
   */

  export type AccommodationTypeCountOutputType = {
    HotelCard: number
  }

  export type AccommodationTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | AccommodationTypeCountOutputTypeCountHotelCardArgs
  }

  // Custom InputTypes
  /**
   * AccommodationTypeCountOutputType without action
   */
  export type AccommodationTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationTypeCountOutputType
     */
    select?: AccommodationTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccommodationTypeCountOutputType without action
   */
  export type AccommodationTypeCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }


  /**
   * Count Type DestinationCountOutputType
   */

  export type DestinationCountOutputType = {
    HotelCard: number
    City: number
    DestinationToCity: number
  }

  export type DestinationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | DestinationCountOutputTypeCountHotelCardArgs
    City?: boolean | DestinationCountOutputTypeCountCityArgs
    DestinationToCity?: boolean | DestinationCountOutputTypeCountDestinationToCityArgs
  }

  // Custom InputTypes
  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationCountOutputType
     */
    select?: DestinationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountDestinationToCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationToCityWhereInput
  }


  /**
   * Count Type LabelCountOutputType
   */

  export type LabelCountOutputType = {
    HotelCardToLabel: number
  }

  export type LabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCardToLabel?: boolean | LabelCountOutputTypeCountHotelCardToLabelArgs
  }

  // Custom InputTypes
  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     */
    select?: LabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountHotelCardToLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToLabelWhereInput
  }


  /**
   * Count Type HotelGroupCountOutputType
   */

  export type HotelGroupCountOutputType = {
    HotelCard: number
  }

  export type HotelGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelGroupCountOutputTypeCountHotelCardArgs
  }

  // Custom InputTypes
  /**
   * HotelGroupCountOutputType without action
   */
  export type HotelGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroupCountOutputType
     */
    select?: HotelGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelGroupCountOutputType without action
   */
  export type HotelGroupCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }


  /**
   * Count Type HotelHighlightCountOutputType
   */

  export type HotelHighlightCountOutputType = {
    HotelCardToHotelHighlight: number
  }

  export type HotelHighlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCardToHotelHighlight?: boolean | HotelHighlightCountOutputTypeCountHotelCardToHotelHighlightArgs
  }

  // Custom InputTypes
  /**
   * HotelHighlightCountOutputType without action
   */
  export type HotelHighlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlightCountOutputType
     */
    select?: HotelHighlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelHighlightCountOutputType without action
   */
  export type HotelHighlightCountOutputTypeCountHotelCardToHotelHighlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelHighlightWhereInput
  }


  /**
   * Count Type HotelAmenityCountOutputType
   */

  export type HotelAmenityCountOutputType = {
    HotelCard: number
    HotelCardToHotelAmenity: number
  }

  export type HotelAmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelAmenityCountOutputTypeCountHotelCardArgs
    HotelCardToHotelAmenity?: boolean | HotelAmenityCountOutputTypeCountHotelCardToHotelAmenityArgs
  }

  // Custom InputTypes
  /**
   * HotelAmenityCountOutputType without action
   */
  export type HotelAmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenityCountOutputType
     */
    select?: HotelAmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelAmenityCountOutputType without action
   */
  export type HotelAmenityCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }

  /**
   * HotelAmenityCountOutputType without action
   */
  export type HotelAmenityCountOutputTypeCountHotelCardToHotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelAmenityWhereInput
  }


  /**
   * Count Type RoomAmenityCountOutputType
   */

  export type RoomAmenityCountOutputType = {
    HotelDetails: number
    HotelDetailsToRoomAmenity: number
  }

  export type RoomAmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelDetails?: boolean | RoomAmenityCountOutputTypeCountHotelDetailsArgs
    HotelDetailsToRoomAmenity?: boolean | RoomAmenityCountOutputTypeCountHotelDetailsToRoomAmenityArgs
  }

  // Custom InputTypes
  /**
   * RoomAmenityCountOutputType without action
   */
  export type RoomAmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenityCountOutputType
     */
    select?: RoomAmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomAmenityCountOutputType without action
   */
  export type RoomAmenityCountOutputTypeCountHotelDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsWhereInput
  }

  /**
   * RoomAmenityCountOutputType without action
   */
  export type RoomAmenityCountOutputTypeCountHotelDetailsToRoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsToRoomAmenityWhereInput
  }


  /**
   * Count Type AccessibilityOptionCountOutputType
   */

  export type AccessibilityOptionCountOutputType = {
    HotelCardToAccessibilityOption: number
  }

  export type AccessibilityOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCardToAccessibilityOption?: boolean | AccessibilityOptionCountOutputTypeCountHotelCardToAccessibilityOptionArgs
  }

  // Custom InputTypes
  /**
   * AccessibilityOptionCountOutputType without action
   */
  export type AccessibilityOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOptionCountOutputType
     */
    select?: AccessibilityOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccessibilityOptionCountOutputType without action
   */
  export type AccessibilityOptionCountOutputTypeCountHotelCardToAccessibilityOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToAccessibilityOptionWhereInput
  }


  /**
   * Count Type HotelParkingCountOutputType
   */

  export type HotelParkingCountOutputType = {
    HotelCard: number
  }

  export type HotelParkingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelParkingCountOutputTypeCountHotelCardArgs
  }

  // Custom InputTypes
  /**
   * HotelParkingCountOutputType without action
   */
  export type HotelParkingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParkingCountOutputType
     */
    select?: HotelParkingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelParkingCountOutputType without action
   */
  export type HotelParkingCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    hotelDetails: number
    user: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelDetails?: boolean | AddressCountOutputTypeCountHotelDetailsArgs
    user?: boolean | AddressCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountHotelDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsWhereInput
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type HotelImageCountOutputType
   */

  export type HotelImageCountOutputType = {
    HotelCard: number
  }

  export type HotelImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelImageCountOutputTypeCountHotelCardArgs
  }

  // Custom InputTypes
  /**
   * HotelImageCountOutputType without action
   */
  export type HotelImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImageCountOutputType
     */
    select?: HotelImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelImageCountOutputType without action
   */
  export type HotelImageCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }


  /**
   * Count Type HotelCardCountOutputType
   */

  export type HotelCardCountOutputType = {
    parking: number
    images: number
    HotelAmenity: number
    HotelCardToHotelHighlight: number
    HotelCardToLabel: number
    HotelCardToAccessibilityOption: number
    HotelCardToHotelAmenity: number
  }

  export type HotelCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parking?: boolean | HotelCardCountOutputTypeCountParkingArgs
    images?: boolean | HotelCardCountOutputTypeCountImagesArgs
    HotelAmenity?: boolean | HotelCardCountOutputTypeCountHotelAmenityArgs
    HotelCardToHotelHighlight?: boolean | HotelCardCountOutputTypeCountHotelCardToHotelHighlightArgs
    HotelCardToLabel?: boolean | HotelCardCountOutputTypeCountHotelCardToLabelArgs
    HotelCardToAccessibilityOption?: boolean | HotelCardCountOutputTypeCountHotelCardToAccessibilityOptionArgs
    HotelCardToHotelAmenity?: boolean | HotelCardCountOutputTypeCountHotelCardToHotelAmenityArgs
  }

  // Custom InputTypes
  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardCountOutputType
     */
    select?: HotelCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountParkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelParkingWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelImageWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountHotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountHotelCardToHotelHighlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelHighlightWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountHotelCardToLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToLabelWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountHotelCardToAccessibilityOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToAccessibilityOptionWhereInput
  }

  /**
   * HotelCardCountOutputType without action
   */
  export type HotelCardCountOutputTypeCountHotelCardToHotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelAmenityWhereInput
  }


  /**
   * Count Type HotelDetailsCountOutputType
   */

  export type HotelDetailsCountOutputType = {
    RoomAmenity: number
    Label: number
    HotelCard: number
    HotelDetailsToRoomAmenity: number
  }

  export type HotelDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomAmenity?: boolean | HotelDetailsCountOutputTypeCountRoomAmenityArgs
    Label?: boolean | HotelDetailsCountOutputTypeCountLabelArgs
    HotelCard?: boolean | HotelDetailsCountOutputTypeCountHotelCardArgs
    HotelDetailsToRoomAmenity?: boolean | HotelDetailsCountOutputTypeCountHotelDetailsToRoomAmenityArgs
  }

  // Custom InputTypes
  /**
   * HotelDetailsCountOutputType without action
   */
  export type HotelDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsCountOutputType
     */
    select?: HotelDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelDetailsCountOutputType without action
   */
  export type HotelDetailsCountOutputTypeCountRoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
  }

  /**
   * HotelDetailsCountOutputType without action
   */
  export type HotelDetailsCountOutputTypeCountLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }

  /**
   * HotelDetailsCountOutputType without action
   */
  export type HotelDetailsCountOutputTypeCountHotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
  }

  /**
   * HotelDetailsCountOutputType without action
   */
  export type HotelDetailsCountOutputTypeCountHotelDetailsToRoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsToRoomAmenityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    Address?: boolean | User$AddressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    Address?: boolean | User$AddressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      Address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Address<T extends User$AddressArgs<ExtArgs> = {}>(args?: Subset<T, User$AddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.Address
   */
  export type User$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    order: number | null
  }

  export type CountrySumAggregateOutputType = {
    order: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    language: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    language: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    order: number
    code: number
    language: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    order?: true
  }

  export type CountrySumAggregateInputType = {
    order?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    language?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    language?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    language?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    order: number | null
    code: string
    language: string | null
    currency: string | null
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    language?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    language?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    language?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    language?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "code" | "language" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      code: string
      language: string | null
      currency: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly order: FieldRef<"Country", 'Int'>
    readonly code: FieldRef<"Country", 'String'>
    readonly language: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    order: number | null
  }

  export type CitySumAggregateOutputType = {
    order: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    countryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    countryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    order: number
    countryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    order?: true
  }

  export type CitySumAggregateInputType = {
    order?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    order: number | null
    countryId: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    countryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    neighborhoods?: boolean | City$neighborhoodsArgs<ExtArgs>
    landmarks?: boolean | City$landmarksArgs<ExtArgs>
    addresses?: boolean | City$addressesArgs<ExtArgs>
    destinations?: boolean | City$destinationsArgs<ExtArgs>
    DestinationToCity?: boolean | City$DestinationToCityArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    countryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    countryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    countryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "countryId" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    neighborhoods?: boolean | City$neighborhoodsArgs<ExtArgs>
    landmarks?: boolean | City$landmarksArgs<ExtArgs>
    addresses?: boolean | City$addressesArgs<ExtArgs>
    destinations?: boolean | City$destinationsArgs<ExtArgs>
    DestinationToCity?: boolean | City$DestinationToCityArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      neighborhoods: Prisma.$NeighborhoodPayload<ExtArgs>[]
      landmarks: Prisma.$LandmarkPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      destinations: Prisma.$DestinationPayload<ExtArgs>[]
      DestinationToCity: Prisma.$DestinationToCityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      countryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    neighborhoods<T extends City$neighborhoodsArgs<ExtArgs> = {}>(args?: Subset<T, City$neighborhoodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landmarks<T extends City$landmarksArgs<ExtArgs> = {}>(args?: Subset<T, City$landmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends City$addressesArgs<ExtArgs> = {}>(args?: Subset<T, City$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    destinations<T extends City$destinationsArgs<ExtArgs> = {}>(args?: Subset<T, City$destinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DestinationToCity<T extends City$DestinationToCityArgs<ExtArgs> = {}>(args?: Subset<T, City$DestinationToCityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly order: FieldRef<"City", 'Int'>
    readonly countryId: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.neighborhoods
   */
  export type City$neighborhoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    where?: NeighborhoodWhereInput
    orderBy?: NeighborhoodOrderByWithRelationInput | NeighborhoodOrderByWithRelationInput[]
    cursor?: NeighborhoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeighborhoodScalarFieldEnum | NeighborhoodScalarFieldEnum[]
  }

  /**
   * City.landmarks
   */
  export type City$landmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    where?: LandmarkWhereInput
    orderBy?: LandmarkOrderByWithRelationInput | LandmarkOrderByWithRelationInput[]
    cursor?: LandmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandmarkScalarFieldEnum | LandmarkScalarFieldEnum[]
  }

  /**
   * City.addresses
   */
  export type City$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * City.destinations
   */
  export type City$destinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    cursor?: DestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * City.DestinationToCity
   */
  export type City$DestinationToCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    where?: DestinationToCityWhereInput
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    cursor?: DestinationToCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationToCityScalarFieldEnum | DestinationToCityScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Neighborhood
   */

  export type AggregateNeighborhood = {
    _count: NeighborhoodCountAggregateOutputType | null
    _avg: NeighborhoodAvgAggregateOutputType | null
    _sum: NeighborhoodSumAggregateOutputType | null
    _min: NeighborhoodMinAggregateOutputType | null
    _max: NeighborhoodMaxAggregateOutputType | null
  }

  export type NeighborhoodAvgAggregateOutputType = {
    order: number | null
  }

  export type NeighborhoodSumAggregateOutputType = {
    order: number | null
  }

  export type NeighborhoodMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NeighborhoodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NeighborhoodCountAggregateOutputType = {
    id: number
    name: number
    order: number
    cityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NeighborhoodAvgAggregateInputType = {
    order?: true
  }

  export type NeighborhoodSumAggregateInputType = {
    order?: true
  }

  export type NeighborhoodMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NeighborhoodMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NeighborhoodCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NeighborhoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Neighborhood to aggregate.
     */
    where?: NeighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Neighborhoods to fetch.
     */
    orderBy?: NeighborhoodOrderByWithRelationInput | NeighborhoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NeighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Neighborhoods
    **/
    _count?: true | NeighborhoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeighborhoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeighborhoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeighborhoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeighborhoodMaxAggregateInputType
  }

  export type GetNeighborhoodAggregateType<T extends NeighborhoodAggregateArgs> = {
        [P in keyof T & keyof AggregateNeighborhood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeighborhood[P]>
      : GetScalarType<T[P], AggregateNeighborhood[P]>
  }




  export type NeighborhoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeighborhoodWhereInput
    orderBy?: NeighborhoodOrderByWithAggregationInput | NeighborhoodOrderByWithAggregationInput[]
    by: NeighborhoodScalarFieldEnum[] | NeighborhoodScalarFieldEnum
    having?: NeighborhoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeighborhoodCountAggregateInputType | true
    _avg?: NeighborhoodAvgAggregateInputType
    _sum?: NeighborhoodSumAggregateInputType
    _min?: NeighborhoodMinAggregateInputType
    _max?: NeighborhoodMaxAggregateInputType
  }

  export type NeighborhoodGroupByOutputType = {
    id: string
    name: string
    order: number | null
    cityId: string
    createdAt: Date
    updatedAt: Date
    _count: NeighborhoodCountAggregateOutputType | null
    _avg: NeighborhoodAvgAggregateOutputType | null
    _sum: NeighborhoodSumAggregateOutputType | null
    _min: NeighborhoodMinAggregateOutputType | null
    _max: NeighborhoodMaxAggregateOutputType | null
  }

  type GetNeighborhoodGroupByPayload<T extends NeighborhoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NeighborhoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeighborhoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeighborhoodGroupByOutputType[P]>
            : GetScalarType<T[P], NeighborhoodGroupByOutputType[P]>
        }
      >
    >


  export type NeighborhoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    addresses?: boolean | Neighborhood$addressesArgs<ExtArgs>
    _count?: boolean | NeighborhoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["neighborhood"]>

  export type NeighborhoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["neighborhood"]>

  export type NeighborhoodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["neighborhood"]>

  export type NeighborhoodSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NeighborhoodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "cityId" | "createdAt" | "updatedAt", ExtArgs["result"]["neighborhood"]>
  export type NeighborhoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    addresses?: boolean | Neighborhood$addressesArgs<ExtArgs>
    _count?: boolean | NeighborhoodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NeighborhoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type NeighborhoodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $NeighborhoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Neighborhood"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      cityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["neighborhood"]>
    composites: {}
  }

  type NeighborhoodGetPayload<S extends boolean | null | undefined | NeighborhoodDefaultArgs> = $Result.GetResult<Prisma.$NeighborhoodPayload, S>

  type NeighborhoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NeighborhoodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NeighborhoodCountAggregateInputType | true
    }

  export interface NeighborhoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Neighborhood'], meta: { name: 'Neighborhood' } }
    /**
     * Find zero or one Neighborhood that matches the filter.
     * @param {NeighborhoodFindUniqueArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NeighborhoodFindUniqueArgs>(args: SelectSubset<T, NeighborhoodFindUniqueArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Neighborhood that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NeighborhoodFindUniqueOrThrowArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NeighborhoodFindUniqueOrThrowArgs>(args: SelectSubset<T, NeighborhoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Neighborhood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodFindFirstArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NeighborhoodFindFirstArgs>(args?: SelectSubset<T, NeighborhoodFindFirstArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Neighborhood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodFindFirstOrThrowArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NeighborhoodFindFirstOrThrowArgs>(args?: SelectSubset<T, NeighborhoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Neighborhoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Neighborhoods
     * const neighborhoods = await prisma.neighborhood.findMany()
     * 
     * // Get first 10 Neighborhoods
     * const neighborhoods = await prisma.neighborhood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const neighborhoodWithIdOnly = await prisma.neighborhood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NeighborhoodFindManyArgs>(args?: SelectSubset<T, NeighborhoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Neighborhood.
     * @param {NeighborhoodCreateArgs} args - Arguments to create a Neighborhood.
     * @example
     * // Create one Neighborhood
     * const Neighborhood = await prisma.neighborhood.create({
     *   data: {
     *     // ... data to create a Neighborhood
     *   }
     * })
     * 
     */
    create<T extends NeighborhoodCreateArgs>(args: SelectSubset<T, NeighborhoodCreateArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Neighborhoods.
     * @param {NeighborhoodCreateManyArgs} args - Arguments to create many Neighborhoods.
     * @example
     * // Create many Neighborhoods
     * const neighborhood = await prisma.neighborhood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NeighborhoodCreateManyArgs>(args?: SelectSubset<T, NeighborhoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Neighborhoods and returns the data saved in the database.
     * @param {NeighborhoodCreateManyAndReturnArgs} args - Arguments to create many Neighborhoods.
     * @example
     * // Create many Neighborhoods
     * const neighborhood = await prisma.neighborhood.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Neighborhoods and only return the `id`
     * const neighborhoodWithIdOnly = await prisma.neighborhood.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NeighborhoodCreateManyAndReturnArgs>(args?: SelectSubset<T, NeighborhoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Neighborhood.
     * @param {NeighborhoodDeleteArgs} args - Arguments to delete one Neighborhood.
     * @example
     * // Delete one Neighborhood
     * const Neighborhood = await prisma.neighborhood.delete({
     *   where: {
     *     // ... filter to delete one Neighborhood
     *   }
     * })
     * 
     */
    delete<T extends NeighborhoodDeleteArgs>(args: SelectSubset<T, NeighborhoodDeleteArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Neighborhood.
     * @param {NeighborhoodUpdateArgs} args - Arguments to update one Neighborhood.
     * @example
     * // Update one Neighborhood
     * const neighborhood = await prisma.neighborhood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NeighborhoodUpdateArgs>(args: SelectSubset<T, NeighborhoodUpdateArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Neighborhoods.
     * @param {NeighborhoodDeleteManyArgs} args - Arguments to filter Neighborhoods to delete.
     * @example
     * // Delete a few Neighborhoods
     * const { count } = await prisma.neighborhood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NeighborhoodDeleteManyArgs>(args?: SelectSubset<T, NeighborhoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Neighborhoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Neighborhoods
     * const neighborhood = await prisma.neighborhood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NeighborhoodUpdateManyArgs>(args: SelectSubset<T, NeighborhoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Neighborhoods and returns the data updated in the database.
     * @param {NeighborhoodUpdateManyAndReturnArgs} args - Arguments to update many Neighborhoods.
     * @example
     * // Update many Neighborhoods
     * const neighborhood = await prisma.neighborhood.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Neighborhoods and only return the `id`
     * const neighborhoodWithIdOnly = await prisma.neighborhood.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NeighborhoodUpdateManyAndReturnArgs>(args: SelectSubset<T, NeighborhoodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Neighborhood.
     * @param {NeighborhoodUpsertArgs} args - Arguments to update or create a Neighborhood.
     * @example
     * // Update or create a Neighborhood
     * const neighborhood = await prisma.neighborhood.upsert({
     *   create: {
     *     // ... data to create a Neighborhood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Neighborhood we want to update
     *   }
     * })
     */
    upsert<T extends NeighborhoodUpsertArgs>(args: SelectSubset<T, NeighborhoodUpsertArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Neighborhoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodCountArgs} args - Arguments to filter Neighborhoods to count.
     * @example
     * // Count the number of Neighborhoods
     * const count = await prisma.neighborhood.count({
     *   where: {
     *     // ... the filter for the Neighborhoods we want to count
     *   }
     * })
    **/
    count<T extends NeighborhoodCountArgs>(
      args?: Subset<T, NeighborhoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeighborhoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Neighborhood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeighborhoodAggregateArgs>(args: Subset<T, NeighborhoodAggregateArgs>): Prisma.PrismaPromise<GetNeighborhoodAggregateType<T>>

    /**
     * Group by Neighborhood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeighborhoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeighborhoodGroupByArgs['orderBy'] }
        : { orderBy?: NeighborhoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeighborhoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeighborhoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Neighborhood model
   */
  readonly fields: NeighborhoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Neighborhood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NeighborhoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addresses<T extends Neighborhood$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Neighborhood$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Neighborhood model
   */
  interface NeighborhoodFieldRefs {
    readonly id: FieldRef<"Neighborhood", 'String'>
    readonly name: FieldRef<"Neighborhood", 'String'>
    readonly order: FieldRef<"Neighborhood", 'Int'>
    readonly cityId: FieldRef<"Neighborhood", 'String'>
    readonly createdAt: FieldRef<"Neighborhood", 'DateTime'>
    readonly updatedAt: FieldRef<"Neighborhood", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Neighborhood findUnique
   */
  export type NeighborhoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter, which Neighborhood to fetch.
     */
    where: NeighborhoodWhereUniqueInput
  }

  /**
   * Neighborhood findUniqueOrThrow
   */
  export type NeighborhoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter, which Neighborhood to fetch.
     */
    where: NeighborhoodWhereUniqueInput
  }

  /**
   * Neighborhood findFirst
   */
  export type NeighborhoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter, which Neighborhood to fetch.
     */
    where?: NeighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Neighborhoods to fetch.
     */
    orderBy?: NeighborhoodOrderByWithRelationInput | NeighborhoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Neighborhoods.
     */
    cursor?: NeighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Neighborhoods.
     */
    distinct?: NeighborhoodScalarFieldEnum | NeighborhoodScalarFieldEnum[]
  }

  /**
   * Neighborhood findFirstOrThrow
   */
  export type NeighborhoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter, which Neighborhood to fetch.
     */
    where?: NeighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Neighborhoods to fetch.
     */
    orderBy?: NeighborhoodOrderByWithRelationInput | NeighborhoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Neighborhoods.
     */
    cursor?: NeighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Neighborhoods.
     */
    distinct?: NeighborhoodScalarFieldEnum | NeighborhoodScalarFieldEnum[]
  }

  /**
   * Neighborhood findMany
   */
  export type NeighborhoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter, which Neighborhoods to fetch.
     */
    where?: NeighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Neighborhoods to fetch.
     */
    orderBy?: NeighborhoodOrderByWithRelationInput | NeighborhoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Neighborhoods.
     */
    cursor?: NeighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Neighborhoods.
     */
    skip?: number
    distinct?: NeighborhoodScalarFieldEnum | NeighborhoodScalarFieldEnum[]
  }

  /**
   * Neighborhood create
   */
  export type NeighborhoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Neighborhood.
     */
    data: XOR<NeighborhoodCreateInput, NeighborhoodUncheckedCreateInput>
  }

  /**
   * Neighborhood createMany
   */
  export type NeighborhoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Neighborhoods.
     */
    data: NeighborhoodCreateManyInput | NeighborhoodCreateManyInput[]
  }

  /**
   * Neighborhood createManyAndReturn
   */
  export type NeighborhoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * The data used to create many Neighborhoods.
     */
    data: NeighborhoodCreateManyInput | NeighborhoodCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Neighborhood update
   */
  export type NeighborhoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Neighborhood.
     */
    data: XOR<NeighborhoodUpdateInput, NeighborhoodUncheckedUpdateInput>
    /**
     * Choose, which Neighborhood to update.
     */
    where: NeighborhoodWhereUniqueInput
  }

  /**
   * Neighborhood updateMany
   */
  export type NeighborhoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Neighborhoods.
     */
    data: XOR<NeighborhoodUpdateManyMutationInput, NeighborhoodUncheckedUpdateManyInput>
    /**
     * Filter which Neighborhoods to update
     */
    where?: NeighborhoodWhereInput
    /**
     * Limit how many Neighborhoods to update.
     */
    limit?: number
  }

  /**
   * Neighborhood updateManyAndReturn
   */
  export type NeighborhoodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * The data used to update Neighborhoods.
     */
    data: XOR<NeighborhoodUpdateManyMutationInput, NeighborhoodUncheckedUpdateManyInput>
    /**
     * Filter which Neighborhoods to update
     */
    where?: NeighborhoodWhereInput
    /**
     * Limit how many Neighborhoods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Neighborhood upsert
   */
  export type NeighborhoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Neighborhood to update in case it exists.
     */
    where: NeighborhoodWhereUniqueInput
    /**
     * In case the Neighborhood found by the `where` argument doesn't exist, create a new Neighborhood with this data.
     */
    create: XOR<NeighborhoodCreateInput, NeighborhoodUncheckedCreateInput>
    /**
     * In case the Neighborhood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NeighborhoodUpdateInput, NeighborhoodUncheckedUpdateInput>
  }

  /**
   * Neighborhood delete
   */
  export type NeighborhoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    /**
     * Filter which Neighborhood to delete.
     */
    where: NeighborhoodWhereUniqueInput
  }

  /**
   * Neighborhood deleteMany
   */
  export type NeighborhoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Neighborhoods to delete
     */
    where?: NeighborhoodWhereInput
    /**
     * Limit how many Neighborhoods to delete.
     */
    limit?: number
  }

  /**
   * Neighborhood.addresses
   */
  export type Neighborhood$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Neighborhood without action
   */
  export type NeighborhoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
  }


  /**
   * Model Landmark
   */

  export type AggregateLandmark = {
    _count: LandmarkCountAggregateOutputType | null
    _avg: LandmarkAvgAggregateOutputType | null
    _sum: LandmarkSumAggregateOutputType | null
    _min: LandmarkMinAggregateOutputType | null
    _max: LandmarkMaxAggregateOutputType | null
  }

  export type LandmarkAvgAggregateOutputType = {
    order: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LandmarkSumAggregateOutputType = {
    order: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LandmarkMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    type: string | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandmarkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    type: string | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandmarkCountAggregateOutputType = {
    id: number
    name: number
    order: number
    description: number
    type: number
    cityId: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandmarkAvgAggregateInputType = {
    order?: true
    latitude?: true
    longitude?: true
  }

  export type LandmarkSumAggregateInputType = {
    order?: true
    latitude?: true
    longitude?: true
  }

  export type LandmarkMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    cityId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandmarkMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    cityId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandmarkCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    cityId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landmark to aggregate.
     */
    where?: LandmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landmarks to fetch.
     */
    orderBy?: LandmarkOrderByWithRelationInput | LandmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Landmarks
    **/
    _count?: true | LandmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandmarkMaxAggregateInputType
  }

  export type GetLandmarkAggregateType<T extends LandmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateLandmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandmark[P]>
      : GetScalarType<T[P], AggregateLandmark[P]>
  }




  export type LandmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandmarkWhereInput
    orderBy?: LandmarkOrderByWithAggregationInput | LandmarkOrderByWithAggregationInput[]
    by: LandmarkScalarFieldEnum[] | LandmarkScalarFieldEnum
    having?: LandmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandmarkCountAggregateInputType | true
    _avg?: LandmarkAvgAggregateInputType
    _sum?: LandmarkSumAggregateInputType
    _min?: LandmarkMinAggregateInputType
    _max?: LandmarkMaxAggregateInputType
  }

  export type LandmarkGroupByOutputType = {
    id: string
    name: string
    order: number | null
    description: string | null
    type: string
    cityId: string
    latitude: number | null
    longitude: number | null
    createdAt: Date
    updatedAt: Date
    _count: LandmarkCountAggregateOutputType | null
    _avg: LandmarkAvgAggregateOutputType | null
    _sum: LandmarkSumAggregateOutputType | null
    _min: LandmarkMinAggregateOutputType | null
    _max: LandmarkMaxAggregateOutputType | null
  }

  type GetLandmarkGroupByPayload<T extends LandmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandmarkGroupByOutputType[P]>
            : GetScalarType<T[P], LandmarkGroupByOutputType[P]>
        }
      >
    >


  export type LandmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landmark"]>

  export type LandmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landmark"]>

  export type LandmarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landmark"]>

  export type LandmarkSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LandmarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "description" | "type" | "cityId" | "latitude" | "longitude" | "createdAt" | "updatedAt", ExtArgs["result"]["landmark"]>
  export type LandmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type LandmarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type LandmarkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $LandmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Landmark"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      description: string | null
      type: string
      cityId: string
      latitude: number | null
      longitude: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["landmark"]>
    composites: {}
  }

  type LandmarkGetPayload<S extends boolean | null | undefined | LandmarkDefaultArgs> = $Result.GetResult<Prisma.$LandmarkPayload, S>

  type LandmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandmarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandmarkCountAggregateInputType | true
    }

  export interface LandmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Landmark'], meta: { name: 'Landmark' } }
    /**
     * Find zero or one Landmark that matches the filter.
     * @param {LandmarkFindUniqueArgs} args - Arguments to find a Landmark
     * @example
     * // Get one Landmark
     * const landmark = await prisma.landmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandmarkFindUniqueArgs>(args: SelectSubset<T, LandmarkFindUniqueArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Landmark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandmarkFindUniqueOrThrowArgs} args - Arguments to find a Landmark
     * @example
     * // Get one Landmark
     * const landmark = await prisma.landmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, LandmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkFindFirstArgs} args - Arguments to find a Landmark
     * @example
     * // Get one Landmark
     * const landmark = await prisma.landmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandmarkFindFirstArgs>(args?: SelectSubset<T, LandmarkFindFirstArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkFindFirstOrThrowArgs} args - Arguments to find a Landmark
     * @example
     * // Get one Landmark
     * const landmark = await prisma.landmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, LandmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Landmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Landmarks
     * const landmarks = await prisma.landmark.findMany()
     * 
     * // Get first 10 Landmarks
     * const landmarks = await prisma.landmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landmarkWithIdOnly = await prisma.landmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandmarkFindManyArgs>(args?: SelectSubset<T, LandmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Landmark.
     * @param {LandmarkCreateArgs} args - Arguments to create a Landmark.
     * @example
     * // Create one Landmark
     * const Landmark = await prisma.landmark.create({
     *   data: {
     *     // ... data to create a Landmark
     *   }
     * })
     * 
     */
    create<T extends LandmarkCreateArgs>(args: SelectSubset<T, LandmarkCreateArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Landmarks.
     * @param {LandmarkCreateManyArgs} args - Arguments to create many Landmarks.
     * @example
     * // Create many Landmarks
     * const landmark = await prisma.landmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandmarkCreateManyArgs>(args?: SelectSubset<T, LandmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Landmarks and returns the data saved in the database.
     * @param {LandmarkCreateManyAndReturnArgs} args - Arguments to create many Landmarks.
     * @example
     * // Create many Landmarks
     * const landmark = await prisma.landmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Landmarks and only return the `id`
     * const landmarkWithIdOnly = await prisma.landmark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, LandmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Landmark.
     * @param {LandmarkDeleteArgs} args - Arguments to delete one Landmark.
     * @example
     * // Delete one Landmark
     * const Landmark = await prisma.landmark.delete({
     *   where: {
     *     // ... filter to delete one Landmark
     *   }
     * })
     * 
     */
    delete<T extends LandmarkDeleteArgs>(args: SelectSubset<T, LandmarkDeleteArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Landmark.
     * @param {LandmarkUpdateArgs} args - Arguments to update one Landmark.
     * @example
     * // Update one Landmark
     * const landmark = await prisma.landmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandmarkUpdateArgs>(args: SelectSubset<T, LandmarkUpdateArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Landmarks.
     * @param {LandmarkDeleteManyArgs} args - Arguments to filter Landmarks to delete.
     * @example
     * // Delete a few Landmarks
     * const { count } = await prisma.landmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandmarkDeleteManyArgs>(args?: SelectSubset<T, LandmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Landmarks
     * const landmark = await prisma.landmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandmarkUpdateManyArgs>(args: SelectSubset<T, LandmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landmarks and returns the data updated in the database.
     * @param {LandmarkUpdateManyAndReturnArgs} args - Arguments to update many Landmarks.
     * @example
     * // Update many Landmarks
     * const landmark = await prisma.landmark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Landmarks and only return the `id`
     * const landmarkWithIdOnly = await prisma.landmark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandmarkUpdateManyAndReturnArgs>(args: SelectSubset<T, LandmarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Landmark.
     * @param {LandmarkUpsertArgs} args - Arguments to update or create a Landmark.
     * @example
     * // Update or create a Landmark
     * const landmark = await prisma.landmark.upsert({
     *   create: {
     *     // ... data to create a Landmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Landmark we want to update
     *   }
     * })
     */
    upsert<T extends LandmarkUpsertArgs>(args: SelectSubset<T, LandmarkUpsertArgs<ExtArgs>>): Prisma__LandmarkClient<$Result.GetResult<Prisma.$LandmarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Landmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkCountArgs} args - Arguments to filter Landmarks to count.
     * @example
     * // Count the number of Landmarks
     * const count = await prisma.landmark.count({
     *   where: {
     *     // ... the filter for the Landmarks we want to count
     *   }
     * })
    **/
    count<T extends LandmarkCountArgs>(
      args?: Subset<T, LandmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Landmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandmarkAggregateArgs>(args: Subset<T, LandmarkAggregateArgs>): Prisma.PrismaPromise<GetLandmarkAggregateType<T>>

    /**
     * Group by Landmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandmarkGroupByArgs['orderBy'] }
        : { orderBy?: LandmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Landmark model
   */
  readonly fields: LandmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Landmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Landmark model
   */
  interface LandmarkFieldRefs {
    readonly id: FieldRef<"Landmark", 'String'>
    readonly name: FieldRef<"Landmark", 'String'>
    readonly order: FieldRef<"Landmark", 'Int'>
    readonly description: FieldRef<"Landmark", 'String'>
    readonly type: FieldRef<"Landmark", 'String'>
    readonly cityId: FieldRef<"Landmark", 'String'>
    readonly latitude: FieldRef<"Landmark", 'Float'>
    readonly longitude: FieldRef<"Landmark", 'Float'>
    readonly createdAt: FieldRef<"Landmark", 'DateTime'>
    readonly updatedAt: FieldRef<"Landmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Landmark findUnique
   */
  export type LandmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter, which Landmark to fetch.
     */
    where: LandmarkWhereUniqueInput
  }

  /**
   * Landmark findUniqueOrThrow
   */
  export type LandmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter, which Landmark to fetch.
     */
    where: LandmarkWhereUniqueInput
  }

  /**
   * Landmark findFirst
   */
  export type LandmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter, which Landmark to fetch.
     */
    where?: LandmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landmarks to fetch.
     */
    orderBy?: LandmarkOrderByWithRelationInput | LandmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landmarks.
     */
    cursor?: LandmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landmarks.
     */
    distinct?: LandmarkScalarFieldEnum | LandmarkScalarFieldEnum[]
  }

  /**
   * Landmark findFirstOrThrow
   */
  export type LandmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter, which Landmark to fetch.
     */
    where?: LandmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landmarks to fetch.
     */
    orderBy?: LandmarkOrderByWithRelationInput | LandmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landmarks.
     */
    cursor?: LandmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landmarks.
     */
    distinct?: LandmarkScalarFieldEnum | LandmarkScalarFieldEnum[]
  }

  /**
   * Landmark findMany
   */
  export type LandmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter, which Landmarks to fetch.
     */
    where?: LandmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landmarks to fetch.
     */
    orderBy?: LandmarkOrderByWithRelationInput | LandmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Landmarks.
     */
    cursor?: LandmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landmarks.
     */
    skip?: number
    distinct?: LandmarkScalarFieldEnum | LandmarkScalarFieldEnum[]
  }

  /**
   * Landmark create
   */
  export type LandmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Landmark.
     */
    data: XOR<LandmarkCreateInput, LandmarkUncheckedCreateInput>
  }

  /**
   * Landmark createMany
   */
  export type LandmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Landmarks.
     */
    data: LandmarkCreateManyInput | LandmarkCreateManyInput[]
  }

  /**
   * Landmark createManyAndReturn
   */
  export type LandmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * The data used to create many Landmarks.
     */
    data: LandmarkCreateManyInput | LandmarkCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Landmark update
   */
  export type LandmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Landmark.
     */
    data: XOR<LandmarkUpdateInput, LandmarkUncheckedUpdateInput>
    /**
     * Choose, which Landmark to update.
     */
    where: LandmarkWhereUniqueInput
  }

  /**
   * Landmark updateMany
   */
  export type LandmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Landmarks.
     */
    data: XOR<LandmarkUpdateManyMutationInput, LandmarkUncheckedUpdateManyInput>
    /**
     * Filter which Landmarks to update
     */
    where?: LandmarkWhereInput
    /**
     * Limit how many Landmarks to update.
     */
    limit?: number
  }

  /**
   * Landmark updateManyAndReturn
   */
  export type LandmarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * The data used to update Landmarks.
     */
    data: XOR<LandmarkUpdateManyMutationInput, LandmarkUncheckedUpdateManyInput>
    /**
     * Filter which Landmarks to update
     */
    where?: LandmarkWhereInput
    /**
     * Limit how many Landmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Landmark upsert
   */
  export type LandmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Landmark to update in case it exists.
     */
    where: LandmarkWhereUniqueInput
    /**
     * In case the Landmark found by the `where` argument doesn't exist, create a new Landmark with this data.
     */
    create: XOR<LandmarkCreateInput, LandmarkUncheckedCreateInput>
    /**
     * In case the Landmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandmarkUpdateInput, LandmarkUncheckedUpdateInput>
  }

  /**
   * Landmark delete
   */
  export type LandmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
    /**
     * Filter which Landmark to delete.
     */
    where: LandmarkWhereUniqueInput
  }

  /**
   * Landmark deleteMany
   */
  export type LandmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landmarks to delete
     */
    where?: LandmarkWhereInput
    /**
     * Limit how many Landmarks to delete.
     */
    limit?: number
  }

  /**
   * Landmark without action
   */
  export type LandmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landmark
     */
    select?: LandmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landmark
     */
    omit?: LandmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandmarkInclude<ExtArgs> | null
  }


  /**
   * Model AccommodationType
   */

  export type AggregateAccommodationType = {
    _count: AccommodationTypeCountAggregateOutputType | null
    _avg: AccommodationTypeAvgAggregateOutputType | null
    _sum: AccommodationTypeSumAggregateOutputType | null
    _min: AccommodationTypeMinAggregateOutputType | null
    _max: AccommodationTypeMaxAggregateOutputType | null
  }

  export type AccommodationTypeAvgAggregateOutputType = {
    order: number | null
  }

  export type AccommodationTypeSumAggregateOutputType = {
    order: number | null
  }

  export type AccommodationTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationTypeCountAggregateOutputType = {
    id: number
    name: number
    order: number
    code: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccommodationTypeAvgAggregateInputType = {
    order?: true
  }

  export type AccommodationTypeSumAggregateInputType = {
    order?: true
  }

  export type AccommodationTypeMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationTypeMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationTypeCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccommodationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationType to aggregate.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccommodationTypes
    **/
    _count?: true | AccommodationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccommodationTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccommodationTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationTypeMaxAggregateInputType
  }

  export type GetAccommodationTypeAggregateType<T extends AccommodationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodationType[P]>
      : GetScalarType<T[P], AggregateAccommodationType[P]>
  }




  export type AccommodationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationTypeWhereInput
    orderBy?: AccommodationTypeOrderByWithAggregationInput | AccommodationTypeOrderByWithAggregationInput[]
    by: AccommodationTypeScalarFieldEnum[] | AccommodationTypeScalarFieldEnum
    having?: AccommodationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationTypeCountAggregateInputType | true
    _avg?: AccommodationTypeAvgAggregateInputType
    _sum?: AccommodationTypeSumAggregateInputType
    _min?: AccommodationTypeMinAggregateInputType
    _max?: AccommodationTypeMaxAggregateInputType
  }

  export type AccommodationTypeGroupByOutputType = {
    id: string
    name: string
    order: number | null
    code: string
    description: string | null
    category: string
    createdAt: Date
    updatedAt: Date
    _count: AccommodationTypeCountAggregateOutputType | null
    _avg: AccommodationTypeAvgAggregateOutputType | null
    _sum: AccommodationTypeSumAggregateOutputType | null
    _min: AccommodationTypeMinAggregateOutputType | null
    _max: AccommodationTypeMaxAggregateOutputType | null
  }

  type GetAccommodationTypeGroupByPayload<T extends AccommodationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationTypeGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | AccommodationType$HotelCardArgs<ExtArgs>
    _count?: boolean | AccommodationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationType"]>

  export type AccommodationTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accommodationType"]>

  export type AccommodationTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accommodationType"]>

  export type AccommodationTypeSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccommodationTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "code" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["accommodationType"]>
  export type AccommodationTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | AccommodationType$HotelCardArgs<ExtArgs>
    _count?: boolean | AccommodationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccommodationTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccommodationTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccommodationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccommodationType"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      code: string
      description: string | null
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accommodationType"]>
    composites: {}
  }

  type AccommodationTypeGetPayload<S extends boolean | null | undefined | AccommodationTypeDefaultArgs> = $Result.GetResult<Prisma.$AccommodationTypePayload, S>

  type AccommodationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccommodationTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccommodationTypeCountAggregateInputType | true
    }

  export interface AccommodationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccommodationType'], meta: { name: 'AccommodationType' } }
    /**
     * Find zero or one AccommodationType that matches the filter.
     * @param {AccommodationTypeFindUniqueArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationTypeFindUniqueArgs>(args: SelectSubset<T, AccommodationTypeFindUniqueArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccommodationType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccommodationTypeFindUniqueOrThrowArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindFirstArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationTypeFindFirstArgs>(args?: SelectSubset<T, AccommodationTypeFindFirstArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindFirstOrThrowArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccommodationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccommodationTypes
     * const accommodationTypes = await prisma.accommodationType.findMany()
     * 
     * // Get first 10 AccommodationTypes
     * const accommodationTypes = await prisma.accommodationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationTypeWithIdOnly = await prisma.accommodationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationTypeFindManyArgs>(args?: SelectSubset<T, AccommodationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccommodationType.
     * @param {AccommodationTypeCreateArgs} args - Arguments to create a AccommodationType.
     * @example
     * // Create one AccommodationType
     * const AccommodationType = await prisma.accommodationType.create({
     *   data: {
     *     // ... data to create a AccommodationType
     *   }
     * })
     * 
     */
    create<T extends AccommodationTypeCreateArgs>(args: SelectSubset<T, AccommodationTypeCreateArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccommodationTypes.
     * @param {AccommodationTypeCreateManyArgs} args - Arguments to create many AccommodationTypes.
     * @example
     * // Create many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationTypeCreateManyArgs>(args?: SelectSubset<T, AccommodationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccommodationTypes and returns the data saved in the database.
     * @param {AccommodationTypeCreateManyAndReturnArgs} args - Arguments to create many AccommodationTypes.
     * @example
     * // Create many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccommodationTypes and only return the `id`
     * const accommodationTypeWithIdOnly = await prisma.accommodationType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccommodationType.
     * @param {AccommodationTypeDeleteArgs} args - Arguments to delete one AccommodationType.
     * @example
     * // Delete one AccommodationType
     * const AccommodationType = await prisma.accommodationType.delete({
     *   where: {
     *     // ... filter to delete one AccommodationType
     *   }
     * })
     * 
     */
    delete<T extends AccommodationTypeDeleteArgs>(args: SelectSubset<T, AccommodationTypeDeleteArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccommodationType.
     * @param {AccommodationTypeUpdateArgs} args - Arguments to update one AccommodationType.
     * @example
     * // Update one AccommodationType
     * const accommodationType = await prisma.accommodationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationTypeUpdateArgs>(args: SelectSubset<T, AccommodationTypeUpdateArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccommodationTypes.
     * @param {AccommodationTypeDeleteManyArgs} args - Arguments to filter AccommodationTypes to delete.
     * @example
     * // Delete a few AccommodationTypes
     * const { count } = await prisma.accommodationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationTypeDeleteManyArgs>(args?: SelectSubset<T, AccommodationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationTypeUpdateManyArgs>(args: SelectSubset<T, AccommodationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationTypes and returns the data updated in the database.
     * @param {AccommodationTypeUpdateManyAndReturnArgs} args - Arguments to update many AccommodationTypes.
     * @example
     * // Update many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccommodationTypes and only return the `id`
     * const accommodationTypeWithIdOnly = await prisma.accommodationType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccommodationTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, AccommodationTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccommodationType.
     * @param {AccommodationTypeUpsertArgs} args - Arguments to update or create a AccommodationType.
     * @example
     * // Update or create a AccommodationType
     * const accommodationType = await prisma.accommodationType.upsert({
     *   create: {
     *     // ... data to create a AccommodationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccommodationType we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationTypeUpsertArgs>(args: SelectSubset<T, AccommodationTypeUpsertArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccommodationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeCountArgs} args - Arguments to filter AccommodationTypes to count.
     * @example
     * // Count the number of AccommodationTypes
     * const count = await prisma.accommodationType.count({
     *   where: {
     *     // ... the filter for the AccommodationTypes we want to count
     *   }
     * })
    **/
    count<T extends AccommodationTypeCountArgs>(
      args?: Subset<T, AccommodationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccommodationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationTypeAggregateArgs>(args: Subset<T, AccommodationTypeAggregateArgs>): Prisma.PrismaPromise<GetAccommodationTypeAggregateType<T>>

    /**
     * Group by AccommodationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationTypeGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccommodationType model
   */
  readonly fields: AccommodationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccommodationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends AccommodationType$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, AccommodationType$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccommodationType model
   */
  interface AccommodationTypeFieldRefs {
    readonly id: FieldRef<"AccommodationType", 'String'>
    readonly name: FieldRef<"AccommodationType", 'String'>
    readonly order: FieldRef<"AccommodationType", 'Int'>
    readonly code: FieldRef<"AccommodationType", 'String'>
    readonly description: FieldRef<"AccommodationType", 'String'>
    readonly category: FieldRef<"AccommodationType", 'String'>
    readonly createdAt: FieldRef<"AccommodationType", 'DateTime'>
    readonly updatedAt: FieldRef<"AccommodationType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccommodationType findUnique
   */
  export type AccommodationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType findUniqueOrThrow
   */
  export type AccommodationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType findFirst
   */
  export type AccommodationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationTypes.
     */
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType findFirstOrThrow
   */
  export type AccommodationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationTypes.
     */
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType findMany
   */
  export type AccommodationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationTypes to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType create
   */
  export type AccommodationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccommodationType.
     */
    data: XOR<AccommodationTypeCreateInput, AccommodationTypeUncheckedCreateInput>
  }

  /**
   * AccommodationType createMany
   */
  export type AccommodationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccommodationTypes.
     */
    data: AccommodationTypeCreateManyInput | AccommodationTypeCreateManyInput[]
  }

  /**
   * AccommodationType createManyAndReturn
   */
  export type AccommodationTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * The data used to create many AccommodationTypes.
     */
    data: AccommodationTypeCreateManyInput | AccommodationTypeCreateManyInput[]
  }

  /**
   * AccommodationType update
   */
  export type AccommodationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccommodationType.
     */
    data: XOR<AccommodationTypeUpdateInput, AccommodationTypeUncheckedUpdateInput>
    /**
     * Choose, which AccommodationType to update.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType updateMany
   */
  export type AccommodationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccommodationTypes.
     */
    data: XOR<AccommodationTypeUpdateManyMutationInput, AccommodationTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationTypes to update
     */
    where?: AccommodationTypeWhereInput
    /**
     * Limit how many AccommodationTypes to update.
     */
    limit?: number
  }

  /**
   * AccommodationType updateManyAndReturn
   */
  export type AccommodationTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * The data used to update AccommodationTypes.
     */
    data: XOR<AccommodationTypeUpdateManyMutationInput, AccommodationTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationTypes to update
     */
    where?: AccommodationTypeWhereInput
    /**
     * Limit how many AccommodationTypes to update.
     */
    limit?: number
  }

  /**
   * AccommodationType upsert
   */
  export type AccommodationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccommodationType to update in case it exists.
     */
    where: AccommodationTypeWhereUniqueInput
    /**
     * In case the AccommodationType found by the `where` argument doesn't exist, create a new AccommodationType with this data.
     */
    create: XOR<AccommodationTypeCreateInput, AccommodationTypeUncheckedCreateInput>
    /**
     * In case the AccommodationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationTypeUpdateInput, AccommodationTypeUncheckedUpdateInput>
  }

  /**
   * AccommodationType delete
   */
  export type AccommodationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    /**
     * Filter which AccommodationType to delete.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType deleteMany
   */
  export type AccommodationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationTypes to delete
     */
    where?: AccommodationTypeWhereInput
    /**
     * Limit how many AccommodationTypes to delete.
     */
    limit?: number
  }

  /**
   * AccommodationType.HotelCard
   */
  export type AccommodationType$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * AccommodationType without action
   */
  export type AccommodationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
  }


  /**
   * Model Destination
   */

  export type AggregateDestination = {
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  export type DestinationAvgAggregateOutputType = {
    order: number | null
    popularityScore: number | null
    latitude: number | null
    longitude: number | null
    radius: number | null
  }

  export type DestinationSumAggregateOutputType = {
    order: number | null
    popularityScore: number | null
    latitude: number | null
    longitude: number | null
    radius: number | null
  }

  export type DestinationMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    type: string | null
    popularityScore: number | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    radius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    type: string | null
    popularityScore: number | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    radius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationCountAggregateOutputType = {
    id: number
    name: number
    order: number
    description: number
    type: number
    popularityScore: number
    cityId: number
    latitude: number
    longitude: number
    radius: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationAvgAggregateInputType = {
    order?: true
    popularityScore?: true
    latitude?: true
    longitude?: true
    radius?: true
  }

  export type DestinationSumAggregateInputType = {
    order?: true
    popularityScore?: true
    latitude?: true
    longitude?: true
    radius?: true
  }

  export type DestinationMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    popularityScore?: true
    cityId?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    popularityScore?: true
    cityId?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    type?: true
    popularityScore?: true
    cityId?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destination to aggregate.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinations
    **/
    _count?: true | DestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationMaxAggregateInputType
  }

  export type GetDestinationAggregateType<T extends DestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestination[P]>
      : GetScalarType<T[P], AggregateDestination[P]>
  }




  export type DestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithAggregationInput | DestinationOrderByWithAggregationInput[]
    by: DestinationScalarFieldEnum[] | DestinationScalarFieldEnum
    having?: DestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationCountAggregateInputType | true
    _avg?: DestinationAvgAggregateInputType
    _sum?: DestinationSumAggregateInputType
    _min?: DestinationMinAggregateInputType
    _max?: DestinationMaxAggregateInputType
  }

  export type DestinationGroupByOutputType = {
    id: string
    name: string
    order: number | null
    description: string | null
    type: string
    popularityScore: number
    cityId: string
    latitude: number | null
    longitude: number | null
    radius: number | null
    createdAt: Date
    updatedAt: Date
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  type GetDestinationGroupByPayload<T extends DestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationGroupByOutputType[P]>
        }
      >
    >


  export type DestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    popularityScore?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    radius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | Destination$HotelCardArgs<ExtArgs>
    City?: boolean | Destination$CityArgs<ExtArgs>
    DestinationToCity?: boolean | Destination$DestinationToCityArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    popularityScore?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    radius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    popularityScore?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    radius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    type?: boolean
    popularityScore?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    radius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "description" | "type" | "popularityScore" | "cityId" | "latitude" | "longitude" | "radius" | "createdAt" | "updatedAt", ExtArgs["result"]["destination"]>
  export type DestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | Destination$HotelCardArgs<ExtArgs>
    City?: boolean | Destination$CityArgs<ExtArgs>
    DestinationToCity?: boolean | Destination$DestinationToCityArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DestinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Destination"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
      City: Prisma.$CityPayload<ExtArgs>[]
      DestinationToCity: Prisma.$DestinationToCityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      description: string | null
      type: string
      popularityScore: number
      cityId: string
      latitude: number | null
      longitude: number | null
      radius: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destination"]>
    composites: {}
  }

  type DestinationGetPayload<S extends boolean | null | undefined | DestinationDefaultArgs> = $Result.GetResult<Prisma.$DestinationPayload, S>

  type DestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationCountAggregateInputType | true
    }

  export interface DestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Destination'], meta: { name: 'Destination' } }
    /**
     * Find zero or one Destination that matches the filter.
     * @param {DestinationFindUniqueArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationFindUniqueArgs>(args: SelectSubset<T, DestinationFindUniqueArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Destination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationFindUniqueOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationFindFirstArgs>(args?: SelectSubset<T, DestinationFindFirstArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Destinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinations
     * const destinations = await prisma.destination.findMany()
     * 
     * // Get first 10 Destinations
     * const destinations = await prisma.destination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationWithIdOnly = await prisma.destination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationFindManyArgs>(args?: SelectSubset<T, DestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Destination.
     * @param {DestinationCreateArgs} args - Arguments to create a Destination.
     * @example
     * // Create one Destination
     * const Destination = await prisma.destination.create({
     *   data: {
     *     // ... data to create a Destination
     *   }
     * })
     * 
     */
    create<T extends DestinationCreateArgs>(args: SelectSubset<T, DestinationCreateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Destinations.
     * @param {DestinationCreateManyArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationCreateManyArgs>(args?: SelectSubset<T, DestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Destinations and returns the data saved in the database.
     * @param {DestinationCreateManyAndReturnArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Destination.
     * @param {DestinationDeleteArgs} args - Arguments to delete one Destination.
     * @example
     * // Delete one Destination
     * const Destination = await prisma.destination.delete({
     *   where: {
     *     // ... filter to delete one Destination
     *   }
     * })
     * 
     */
    delete<T extends DestinationDeleteArgs>(args: SelectSubset<T, DestinationDeleteArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Destination.
     * @param {DestinationUpdateArgs} args - Arguments to update one Destination.
     * @example
     * // Update one Destination
     * const destination = await prisma.destination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationUpdateArgs>(args: SelectSubset<T, DestinationUpdateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Destinations.
     * @param {DestinationDeleteManyArgs} args - Arguments to filter Destinations to delete.
     * @example
     * // Delete a few Destinations
     * const { count } = await prisma.destination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationDeleteManyArgs>(args?: SelectSubset<T, DestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationUpdateManyArgs>(args: SelectSubset<T, DestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations and returns the data updated in the database.
     * @param {DestinationUpdateManyAndReturnArgs} args - Arguments to update many Destinations.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Destination.
     * @param {DestinationUpsertArgs} args - Arguments to update or create a Destination.
     * @example
     * // Update or create a Destination
     * const destination = await prisma.destination.upsert({
     *   create: {
     *     // ... data to create a Destination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destination we want to update
     *   }
     * })
     */
    upsert<T extends DestinationUpsertArgs>(args: SelectSubset<T, DestinationUpsertArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationCountArgs} args - Arguments to filter Destinations to count.
     * @example
     * // Count the number of Destinations
     * const count = await prisma.destination.count({
     *   where: {
     *     // ... the filter for the Destinations we want to count
     *   }
     * })
    **/
    count<T extends DestinationCountArgs>(
      args?: Subset<T, DestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationAggregateArgs>(args: Subset<T, DestinationAggregateArgs>): Prisma.PrismaPromise<GetDestinationAggregateType<T>>

    /**
     * Group by Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationGroupByArgs['orderBy'] }
        : { orderBy?: DestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Destination model
   */
  readonly fields: DestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends Destination$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, Destination$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    City<T extends Destination$CityArgs<ExtArgs> = {}>(args?: Subset<T, Destination$CityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DestinationToCity<T extends Destination$DestinationToCityArgs<ExtArgs> = {}>(args?: Subset<T, Destination$DestinationToCityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Destination model
   */
  interface DestinationFieldRefs {
    readonly id: FieldRef<"Destination", 'String'>
    readonly name: FieldRef<"Destination", 'String'>
    readonly order: FieldRef<"Destination", 'Int'>
    readonly description: FieldRef<"Destination", 'String'>
    readonly type: FieldRef<"Destination", 'String'>
    readonly popularityScore: FieldRef<"Destination", 'Int'>
    readonly cityId: FieldRef<"Destination", 'String'>
    readonly latitude: FieldRef<"Destination", 'Float'>
    readonly longitude: FieldRef<"Destination", 'Float'>
    readonly radius: FieldRef<"Destination", 'Float'>
    readonly createdAt: FieldRef<"Destination", 'DateTime'>
    readonly updatedAt: FieldRef<"Destination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Destination findUnique
   */
  export type DestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findUniqueOrThrow
   */
  export type DestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findFirst
   */
  export type DestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findFirstOrThrow
   */
  export type DestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findMany
   */
  export type DestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destinations to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination create
   */
  export type DestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Destination.
     */
    data: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
  }

  /**
   * Destination createMany
   */
  export type DestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
  }

  /**
   * Destination createManyAndReturn
   */
  export type DestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
  }

  /**
   * Destination update
   */
  export type DestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Destination.
     */
    data: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
    /**
     * Choose, which Destination to update.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination updateMany
   */
  export type DestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination updateManyAndReturn
   */
  export type DestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination upsert
   */
  export type DestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Destination to update in case it exists.
     */
    where: DestinationWhereUniqueInput
    /**
     * In case the Destination found by the `where` argument doesn't exist, create a new Destination with this data.
     */
    create: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
    /**
     * In case the Destination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
  }

  /**
   * Destination delete
   */
  export type DestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter which Destination to delete.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination deleteMany
   */
  export type DestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destinations to delete
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to delete.
     */
    limit?: number
  }

  /**
   * Destination.HotelCard
   */
  export type Destination$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * Destination.City
   */
  export type Destination$CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Destination.DestinationToCity
   */
  export type Destination$DestinationToCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    where?: DestinationToCityWhereInput
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    cursor?: DestinationToCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationToCityScalarFieldEnum | DestinationToCityScalarFieldEnum[]
  }

  /**
   * Destination without action
   */
  export type DestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelAvgAggregateOutputType = {
    order: number | null
    priority: number | null
  }

  export type LabelSumAggregateOutputType = {
    order: number | null
    priority: number | null
  }

  export type LabelMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    icon: string | null
    color: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelDetailsId: string | null
  }

  export type LabelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    icon: string | null
    color: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelDetailsId: string | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    name: number
    order: number
    code: number
    description: number
    category: number
    icon: number
    color: number
    priority: number
    createdAt: number
    updatedAt: number
    hotelDetailsId: number
    _all: number
  }


  export type LabelAvgAggregateInputType = {
    order?: true
    priority?: true
  }

  export type LabelSumAggregateInputType = {
    order?: true
    priority?: true
  }

  export type LabelMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    hotelDetailsId?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    hotelDetailsId?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    hotelDetailsId?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _avg?: LabelAvgAggregateInputType
    _sum?: LabelSumAggregateInputType
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: string
    name: string
    order: number | null
    code: string
    description: string | null
    category: string
    icon: string | null
    color: string | null
    priority: number
    createdAt: Date
    updatedAt: Date
    hotelDetailsId: string | null
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetailsId?: boolean
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
    HotelCardToLabel?: boolean | Label$HotelCardToLabelArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetailsId?: boolean
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetailsId?: boolean
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetailsId?: boolean
  }

  export type LabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "code" | "description" | "category" | "icon" | "color" | "priority" | "createdAt" | "updatedAt" | "hotelDetailsId", ExtArgs["result"]["label"]>
  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
    HotelCardToLabel?: boolean | Label$HotelCardToLabelArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
  }
  export type LabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelDetails?: boolean | Label$HotelDetailsArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      HotelDetails: Prisma.$HotelDetailsPayload<ExtArgs> | null
      HotelCardToLabel: Prisma.$HotelCardToLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      code: string
      description: string | null
      category: string
      icon: string | null
      color: string | null
      priority: number
      createdAt: Date
      updatedAt: Date
      hotelDetailsId: string | null
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labels and returns the data saved in the database.
     * @param {LabelCreateManyAndReturnArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabelCreateManyAndReturnArgs>(args?: SelectSubset<T, LabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels and returns the data updated in the database.
     * @param {LabelUpdateManyAndReturnArgs} args - Arguments to update many Labels.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabelUpdateManyAndReturnArgs>(args: SelectSubset<T, LabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelDetails<T extends Label$HotelDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Label$HotelDetailsArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    HotelCardToLabel<T extends Label$HotelCardToLabelArgs<ExtArgs> = {}>(args?: Subset<T, Label$HotelCardToLabelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'String'>
    readonly name: FieldRef<"Label", 'String'>
    readonly order: FieldRef<"Label", 'Int'>
    readonly code: FieldRef<"Label", 'String'>
    readonly description: FieldRef<"Label", 'String'>
    readonly category: FieldRef<"Label", 'String'>
    readonly icon: FieldRef<"Label", 'String'>
    readonly color: FieldRef<"Label", 'String'>
    readonly priority: FieldRef<"Label", 'Int'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
    readonly updatedAt: FieldRef<"Label", 'DateTime'>
    readonly hotelDetailsId: FieldRef<"Label", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
  }

  /**
   * Label createManyAndReturn
   */
  export type LabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
  }

  /**
   * Label updateManyAndReturn
   */
  export type LabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to delete.
     */
    limit?: number
  }

  /**
   * Label.HotelDetails
   */
  export type Label$HotelDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    where?: HotelDetailsWhereInput
  }

  /**
   * Label.HotelCardToLabel
   */
  export type Label$HotelCardToLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    where?: HotelCardToLabelWhereInput
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    cursor?: HotelCardToLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToLabelScalarFieldEnum | HotelCardToLabelScalarFieldEnum[]
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model HotelGroup
   */

  export type AggregateHotelGroup = {
    _count: HotelGroupCountAggregateOutputType | null
    _avg: HotelGroupAvgAggregateOutputType | null
    _sum: HotelGroupSumAggregateOutputType | null
    _min: HotelGroupMinAggregateOutputType | null
    _max: HotelGroupMaxAggregateOutputType | null
  }

  export type HotelGroupAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelGroupSumAggregateOutputType = {
    order: number | null
  }

  export type HotelGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelGroupCountAggregateOutputType = {
    id: number
    name: number
    order: number
    description: number
    website: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelGroupAvgAggregateInputType = {
    order?: true
  }

  export type HotelGroupSumAggregateInputType = {
    order?: true
  }

  export type HotelGroupMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelGroupMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelGroupCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    description?: true
    website?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelGroup to aggregate.
     */
    where?: HotelGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelGroups to fetch.
     */
    orderBy?: HotelGroupOrderByWithRelationInput | HotelGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelGroups
    **/
    _count?: true | HotelGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelGroupMaxAggregateInputType
  }

  export type GetHotelGroupAggregateType<T extends HotelGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelGroup[P]>
      : GetScalarType<T[P], AggregateHotelGroup[P]>
  }




  export type HotelGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelGroupWhereInput
    orderBy?: HotelGroupOrderByWithAggregationInput | HotelGroupOrderByWithAggregationInput[]
    by: HotelGroupScalarFieldEnum[] | HotelGroupScalarFieldEnum
    having?: HotelGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelGroupCountAggregateInputType | true
    _avg?: HotelGroupAvgAggregateInputType
    _sum?: HotelGroupSumAggregateInputType
    _min?: HotelGroupMinAggregateInputType
    _max?: HotelGroupMaxAggregateInputType
  }

  export type HotelGroupGroupByOutputType = {
    id: string
    name: string
    order: number | null
    description: string | null
    website: string | null
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelGroupCountAggregateOutputType | null
    _avg: HotelGroupAvgAggregateOutputType | null
    _sum: HotelGroupSumAggregateOutputType | null
    _min: HotelGroupMinAggregateOutputType | null
    _max: HotelGroupMaxAggregateOutputType | null
  }

  type GetHotelGroupGroupByPayload<T extends HotelGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupGroupByOutputType[P]>
        }
      >
    >


  export type HotelGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | HotelGroup$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelGroup"]>

  export type HotelGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelGroup"]>

  export type HotelGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelGroup"]>

  export type HotelGroupSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "description" | "website" | "logoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelGroup"]>
  export type HotelGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelGroup$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelGroup"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      description: string | null
      website: string | null
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelGroup"]>
    composites: {}
  }

  type HotelGroupGetPayload<S extends boolean | null | undefined | HotelGroupDefaultArgs> = $Result.GetResult<Prisma.$HotelGroupPayload, S>

  type HotelGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelGroupCountAggregateInputType | true
    }

  export interface HotelGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelGroup'], meta: { name: 'HotelGroup' } }
    /**
     * Find zero or one HotelGroup that matches the filter.
     * @param {HotelGroupFindUniqueArgs} args - Arguments to find a HotelGroup
     * @example
     * // Get one HotelGroup
     * const hotelGroup = await prisma.hotelGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelGroupFindUniqueArgs>(args: SelectSubset<T, HotelGroupFindUniqueArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelGroupFindUniqueOrThrowArgs} args - Arguments to find a HotelGroup
     * @example
     * // Get one HotelGroup
     * const hotelGroup = await prisma.hotelGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupFindFirstArgs} args - Arguments to find a HotelGroup
     * @example
     * // Get one HotelGroup
     * const hotelGroup = await prisma.hotelGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelGroupFindFirstArgs>(args?: SelectSubset<T, HotelGroupFindFirstArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupFindFirstOrThrowArgs} args - Arguments to find a HotelGroup
     * @example
     * // Get one HotelGroup
     * const hotelGroup = await prisma.hotelGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelGroups
     * const hotelGroups = await prisma.hotelGroup.findMany()
     * 
     * // Get first 10 HotelGroups
     * const hotelGroups = await prisma.hotelGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelGroupWithIdOnly = await prisma.hotelGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelGroupFindManyArgs>(args?: SelectSubset<T, HotelGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelGroup.
     * @param {HotelGroupCreateArgs} args - Arguments to create a HotelGroup.
     * @example
     * // Create one HotelGroup
     * const HotelGroup = await prisma.hotelGroup.create({
     *   data: {
     *     // ... data to create a HotelGroup
     *   }
     * })
     * 
     */
    create<T extends HotelGroupCreateArgs>(args: SelectSubset<T, HotelGroupCreateArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelGroups.
     * @param {HotelGroupCreateManyArgs} args - Arguments to create many HotelGroups.
     * @example
     * // Create many HotelGroups
     * const hotelGroup = await prisma.hotelGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelGroupCreateManyArgs>(args?: SelectSubset<T, HotelGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelGroups and returns the data saved in the database.
     * @param {HotelGroupCreateManyAndReturnArgs} args - Arguments to create many HotelGroups.
     * @example
     * // Create many HotelGroups
     * const hotelGroup = await prisma.hotelGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelGroups and only return the `id`
     * const hotelGroupWithIdOnly = await prisma.hotelGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelGroup.
     * @param {HotelGroupDeleteArgs} args - Arguments to delete one HotelGroup.
     * @example
     * // Delete one HotelGroup
     * const HotelGroup = await prisma.hotelGroup.delete({
     *   where: {
     *     // ... filter to delete one HotelGroup
     *   }
     * })
     * 
     */
    delete<T extends HotelGroupDeleteArgs>(args: SelectSubset<T, HotelGroupDeleteArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelGroup.
     * @param {HotelGroupUpdateArgs} args - Arguments to update one HotelGroup.
     * @example
     * // Update one HotelGroup
     * const hotelGroup = await prisma.hotelGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelGroupUpdateArgs>(args: SelectSubset<T, HotelGroupUpdateArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelGroups.
     * @param {HotelGroupDeleteManyArgs} args - Arguments to filter HotelGroups to delete.
     * @example
     * // Delete a few HotelGroups
     * const { count } = await prisma.hotelGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelGroupDeleteManyArgs>(args?: SelectSubset<T, HotelGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelGroups
     * const hotelGroup = await prisma.hotelGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelGroupUpdateManyArgs>(args: SelectSubset<T, HotelGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelGroups and returns the data updated in the database.
     * @param {HotelGroupUpdateManyAndReturnArgs} args - Arguments to update many HotelGroups.
     * @example
     * // Update many HotelGroups
     * const hotelGroup = await prisma.hotelGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelGroups and only return the `id`
     * const hotelGroupWithIdOnly = await prisma.hotelGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelGroup.
     * @param {HotelGroupUpsertArgs} args - Arguments to update or create a HotelGroup.
     * @example
     * // Update or create a HotelGroup
     * const hotelGroup = await prisma.hotelGroup.upsert({
     *   create: {
     *     // ... data to create a HotelGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelGroup we want to update
     *   }
     * })
     */
    upsert<T extends HotelGroupUpsertArgs>(args: SelectSubset<T, HotelGroupUpsertArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupCountArgs} args - Arguments to filter HotelGroups to count.
     * @example
     * // Count the number of HotelGroups
     * const count = await prisma.hotelGroup.count({
     *   where: {
     *     // ... the filter for the HotelGroups we want to count
     *   }
     * })
    **/
    count<T extends HotelGroupCountArgs>(
      args?: Subset<T, HotelGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelGroupAggregateArgs>(args: Subset<T, HotelGroupAggregateArgs>): Prisma.PrismaPromise<GetHotelGroupAggregateType<T>>

    /**
     * Group by HotelGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelGroup model
   */
  readonly fields: HotelGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends HotelGroup$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, HotelGroup$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelGroup model
   */
  interface HotelGroupFieldRefs {
    readonly id: FieldRef<"HotelGroup", 'String'>
    readonly name: FieldRef<"HotelGroup", 'String'>
    readonly order: FieldRef<"HotelGroup", 'Int'>
    readonly description: FieldRef<"HotelGroup", 'String'>
    readonly website: FieldRef<"HotelGroup", 'String'>
    readonly logoUrl: FieldRef<"HotelGroup", 'String'>
    readonly createdAt: FieldRef<"HotelGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelGroup findUnique
   */
  export type HotelGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter, which HotelGroup to fetch.
     */
    where: HotelGroupWhereUniqueInput
  }

  /**
   * HotelGroup findUniqueOrThrow
   */
  export type HotelGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter, which HotelGroup to fetch.
     */
    where: HotelGroupWhereUniqueInput
  }

  /**
   * HotelGroup findFirst
   */
  export type HotelGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter, which HotelGroup to fetch.
     */
    where?: HotelGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelGroups to fetch.
     */
    orderBy?: HotelGroupOrderByWithRelationInput | HotelGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelGroups.
     */
    cursor?: HotelGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelGroups.
     */
    distinct?: HotelGroupScalarFieldEnum | HotelGroupScalarFieldEnum[]
  }

  /**
   * HotelGroup findFirstOrThrow
   */
  export type HotelGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter, which HotelGroup to fetch.
     */
    where?: HotelGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelGroups to fetch.
     */
    orderBy?: HotelGroupOrderByWithRelationInput | HotelGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelGroups.
     */
    cursor?: HotelGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelGroups.
     */
    distinct?: HotelGroupScalarFieldEnum | HotelGroupScalarFieldEnum[]
  }

  /**
   * HotelGroup findMany
   */
  export type HotelGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter, which HotelGroups to fetch.
     */
    where?: HotelGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelGroups to fetch.
     */
    orderBy?: HotelGroupOrderByWithRelationInput | HotelGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelGroups.
     */
    cursor?: HotelGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelGroups.
     */
    skip?: number
    distinct?: HotelGroupScalarFieldEnum | HotelGroupScalarFieldEnum[]
  }

  /**
   * HotelGroup create
   */
  export type HotelGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelGroup.
     */
    data: XOR<HotelGroupCreateInput, HotelGroupUncheckedCreateInput>
  }

  /**
   * HotelGroup createMany
   */
  export type HotelGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelGroups.
     */
    data: HotelGroupCreateManyInput | HotelGroupCreateManyInput[]
  }

  /**
   * HotelGroup createManyAndReturn
   */
  export type HotelGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * The data used to create many HotelGroups.
     */
    data: HotelGroupCreateManyInput | HotelGroupCreateManyInput[]
  }

  /**
   * HotelGroup update
   */
  export type HotelGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelGroup.
     */
    data: XOR<HotelGroupUpdateInput, HotelGroupUncheckedUpdateInput>
    /**
     * Choose, which HotelGroup to update.
     */
    where: HotelGroupWhereUniqueInput
  }

  /**
   * HotelGroup updateMany
   */
  export type HotelGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelGroups.
     */
    data: XOR<HotelGroupUpdateManyMutationInput, HotelGroupUncheckedUpdateManyInput>
    /**
     * Filter which HotelGroups to update
     */
    where?: HotelGroupWhereInput
    /**
     * Limit how many HotelGroups to update.
     */
    limit?: number
  }

  /**
   * HotelGroup updateManyAndReturn
   */
  export type HotelGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * The data used to update HotelGroups.
     */
    data: XOR<HotelGroupUpdateManyMutationInput, HotelGroupUncheckedUpdateManyInput>
    /**
     * Filter which HotelGroups to update
     */
    where?: HotelGroupWhereInput
    /**
     * Limit how many HotelGroups to update.
     */
    limit?: number
  }

  /**
   * HotelGroup upsert
   */
  export type HotelGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelGroup to update in case it exists.
     */
    where: HotelGroupWhereUniqueInput
    /**
     * In case the HotelGroup found by the `where` argument doesn't exist, create a new HotelGroup with this data.
     */
    create: XOR<HotelGroupCreateInput, HotelGroupUncheckedCreateInput>
    /**
     * In case the HotelGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelGroupUpdateInput, HotelGroupUncheckedUpdateInput>
  }

  /**
   * HotelGroup delete
   */
  export type HotelGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    /**
     * Filter which HotelGroup to delete.
     */
    where: HotelGroupWhereUniqueInput
  }

  /**
   * HotelGroup deleteMany
   */
  export type HotelGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelGroups to delete
     */
    where?: HotelGroupWhereInput
    /**
     * Limit how many HotelGroups to delete.
     */
    limit?: number
  }

  /**
   * HotelGroup.HotelCard
   */
  export type HotelGroup$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelGroup without action
   */
  export type HotelGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
  }


  /**
   * Model HotelHighlight
   */

  export type AggregateHotelHighlight = {
    _count: HotelHighlightCountAggregateOutputType | null
    _avg: HotelHighlightAvgAggregateOutputType | null
    _sum: HotelHighlightSumAggregateOutputType | null
    _min: HotelHighlightMinAggregateOutputType | null
    _max: HotelHighlightMaxAggregateOutputType | null
  }

  export type HotelHighlightAvgAggregateOutputType = {
    order: number | null
    priority: number | null
  }

  export type HotelHighlightSumAggregateOutputType = {
    order: number | null
    priority: number | null
  }

  export type HotelHighlightMinAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    description: string | null
    category: string | null
    icon: string | null
    priority: number | null
    isPromoted: boolean | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelHighlightMaxAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    description: string | null
    category: string | null
    icon: string | null
    priority: number | null
    isPromoted: boolean | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelHighlightCountAggregateOutputType = {
    id: number
    title: number
    order: number
    description: number
    category: number
    icon: number
    priority: number
    isPromoted: number
    hotelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelHighlightAvgAggregateInputType = {
    order?: true
    priority?: true
  }

  export type HotelHighlightSumAggregateInputType = {
    order?: true
    priority?: true
  }

  export type HotelHighlightMinAggregateInputType = {
    id?: true
    title?: true
    order?: true
    description?: true
    category?: true
    icon?: true
    priority?: true
    isPromoted?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelHighlightMaxAggregateInputType = {
    id?: true
    title?: true
    order?: true
    description?: true
    category?: true
    icon?: true
    priority?: true
    isPromoted?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelHighlightCountAggregateInputType = {
    id?: true
    title?: true
    order?: true
    description?: true
    category?: true
    icon?: true
    priority?: true
    isPromoted?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelHighlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelHighlight to aggregate.
     */
    where?: HotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelHighlights to fetch.
     */
    orderBy?: HotelHighlightOrderByWithRelationInput | HotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelHighlights
    **/
    _count?: true | HotelHighlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelHighlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelHighlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelHighlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelHighlightMaxAggregateInputType
  }

  export type GetHotelHighlightAggregateType<T extends HotelHighlightAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelHighlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelHighlight[P]>
      : GetScalarType<T[P], AggregateHotelHighlight[P]>
  }




  export type HotelHighlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelHighlightWhereInput
    orderBy?: HotelHighlightOrderByWithAggregationInput | HotelHighlightOrderByWithAggregationInput[]
    by: HotelHighlightScalarFieldEnum[] | HotelHighlightScalarFieldEnum
    having?: HotelHighlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelHighlightCountAggregateInputType | true
    _avg?: HotelHighlightAvgAggregateInputType
    _sum?: HotelHighlightSumAggregateInputType
    _min?: HotelHighlightMinAggregateInputType
    _max?: HotelHighlightMaxAggregateInputType
  }

  export type HotelHighlightGroupByOutputType = {
    id: string
    title: string
    order: number | null
    description: string | null
    category: string
    icon: string | null
    priority: number
    isPromoted: boolean
    hotelId: string
    createdAt: Date
    updatedAt: Date
    _count: HotelHighlightCountAggregateOutputType | null
    _avg: HotelHighlightAvgAggregateOutputType | null
    _sum: HotelHighlightSumAggregateOutputType | null
    _min: HotelHighlightMinAggregateOutputType | null
    _max: HotelHighlightMaxAggregateOutputType | null
  }

  type GetHotelHighlightGroupByPayload<T extends HotelHighlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelHighlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelHighlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelHighlightGroupByOutputType[P]>
            : GetScalarType<T[P], HotelHighlightGroupByOutputType[P]>
        }
      >
    >


  export type HotelHighlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    priority?: boolean
    isPromoted?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCardToHotelHighlight?: boolean | HotelHighlight$HotelCardToHotelHighlightArgs<ExtArgs>
    _count?: boolean | HotelHighlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelHighlight"]>

  export type HotelHighlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    priority?: boolean
    isPromoted?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelHighlight"]>

  export type HotelHighlightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    priority?: boolean
    isPromoted?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelHighlight"]>

  export type HotelHighlightSelectScalar = {
    id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    priority?: boolean
    isPromoted?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelHighlightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "order" | "description" | "category" | "icon" | "priority" | "isPromoted" | "hotelId" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelHighlight"]>
  export type HotelHighlightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCardToHotelHighlight?: boolean | HotelHighlight$HotelCardToHotelHighlightArgs<ExtArgs>
    _count?: boolean | HotelHighlightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelHighlightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelHighlightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelHighlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelHighlight"
    objects: {
      HotelCardToHotelHighlight: Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      order: number | null
      description: string | null
      category: string
      icon: string | null
      priority: number
      isPromoted: boolean
      hotelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelHighlight"]>
    composites: {}
  }

  type HotelHighlightGetPayload<S extends boolean | null | undefined | HotelHighlightDefaultArgs> = $Result.GetResult<Prisma.$HotelHighlightPayload, S>

  type HotelHighlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelHighlightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelHighlightCountAggregateInputType | true
    }

  export interface HotelHighlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelHighlight'], meta: { name: 'HotelHighlight' } }
    /**
     * Find zero or one HotelHighlight that matches the filter.
     * @param {HotelHighlightFindUniqueArgs} args - Arguments to find a HotelHighlight
     * @example
     * // Get one HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelHighlightFindUniqueArgs>(args: SelectSubset<T, HotelHighlightFindUniqueArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelHighlight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelHighlightFindUniqueOrThrowArgs} args - Arguments to find a HotelHighlight
     * @example
     * // Get one HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelHighlightFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelHighlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelHighlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightFindFirstArgs} args - Arguments to find a HotelHighlight
     * @example
     * // Get one HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelHighlightFindFirstArgs>(args?: SelectSubset<T, HotelHighlightFindFirstArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelHighlight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightFindFirstOrThrowArgs} args - Arguments to find a HotelHighlight
     * @example
     * // Get one HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelHighlightFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelHighlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelHighlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelHighlights
     * const hotelHighlights = await prisma.hotelHighlight.findMany()
     * 
     * // Get first 10 HotelHighlights
     * const hotelHighlights = await prisma.hotelHighlight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelHighlightWithIdOnly = await prisma.hotelHighlight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelHighlightFindManyArgs>(args?: SelectSubset<T, HotelHighlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelHighlight.
     * @param {HotelHighlightCreateArgs} args - Arguments to create a HotelHighlight.
     * @example
     * // Create one HotelHighlight
     * const HotelHighlight = await prisma.hotelHighlight.create({
     *   data: {
     *     // ... data to create a HotelHighlight
     *   }
     * })
     * 
     */
    create<T extends HotelHighlightCreateArgs>(args: SelectSubset<T, HotelHighlightCreateArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelHighlights.
     * @param {HotelHighlightCreateManyArgs} args - Arguments to create many HotelHighlights.
     * @example
     * // Create many HotelHighlights
     * const hotelHighlight = await prisma.hotelHighlight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelHighlightCreateManyArgs>(args?: SelectSubset<T, HotelHighlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelHighlights and returns the data saved in the database.
     * @param {HotelHighlightCreateManyAndReturnArgs} args - Arguments to create many HotelHighlights.
     * @example
     * // Create many HotelHighlights
     * const hotelHighlight = await prisma.hotelHighlight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelHighlights and only return the `id`
     * const hotelHighlightWithIdOnly = await prisma.hotelHighlight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelHighlightCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelHighlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelHighlight.
     * @param {HotelHighlightDeleteArgs} args - Arguments to delete one HotelHighlight.
     * @example
     * // Delete one HotelHighlight
     * const HotelHighlight = await prisma.hotelHighlight.delete({
     *   where: {
     *     // ... filter to delete one HotelHighlight
     *   }
     * })
     * 
     */
    delete<T extends HotelHighlightDeleteArgs>(args: SelectSubset<T, HotelHighlightDeleteArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelHighlight.
     * @param {HotelHighlightUpdateArgs} args - Arguments to update one HotelHighlight.
     * @example
     * // Update one HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelHighlightUpdateArgs>(args: SelectSubset<T, HotelHighlightUpdateArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelHighlights.
     * @param {HotelHighlightDeleteManyArgs} args - Arguments to filter HotelHighlights to delete.
     * @example
     * // Delete a few HotelHighlights
     * const { count } = await prisma.hotelHighlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelHighlightDeleteManyArgs>(args?: SelectSubset<T, HotelHighlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelHighlights
     * const hotelHighlight = await prisma.hotelHighlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelHighlightUpdateManyArgs>(args: SelectSubset<T, HotelHighlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelHighlights and returns the data updated in the database.
     * @param {HotelHighlightUpdateManyAndReturnArgs} args - Arguments to update many HotelHighlights.
     * @example
     * // Update many HotelHighlights
     * const hotelHighlight = await prisma.hotelHighlight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelHighlights and only return the `id`
     * const hotelHighlightWithIdOnly = await prisma.hotelHighlight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelHighlightUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelHighlightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelHighlight.
     * @param {HotelHighlightUpsertArgs} args - Arguments to update or create a HotelHighlight.
     * @example
     * // Update or create a HotelHighlight
     * const hotelHighlight = await prisma.hotelHighlight.upsert({
     *   create: {
     *     // ... data to create a HotelHighlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelHighlight we want to update
     *   }
     * })
     */
    upsert<T extends HotelHighlightUpsertArgs>(args: SelectSubset<T, HotelHighlightUpsertArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightCountArgs} args - Arguments to filter HotelHighlights to count.
     * @example
     * // Count the number of HotelHighlights
     * const count = await prisma.hotelHighlight.count({
     *   where: {
     *     // ... the filter for the HotelHighlights we want to count
     *   }
     * })
    **/
    count<T extends HotelHighlightCountArgs>(
      args?: Subset<T, HotelHighlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelHighlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelHighlightAggregateArgs>(args: Subset<T, HotelHighlightAggregateArgs>): Prisma.PrismaPromise<GetHotelHighlightAggregateType<T>>

    /**
     * Group by HotelHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelHighlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelHighlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelHighlightGroupByArgs['orderBy'] }
        : { orderBy?: HotelHighlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelHighlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelHighlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelHighlight model
   */
  readonly fields: HotelHighlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelHighlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelHighlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCardToHotelHighlight<T extends HotelHighlight$HotelCardToHotelHighlightArgs<ExtArgs> = {}>(args?: Subset<T, HotelHighlight$HotelCardToHotelHighlightArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelHighlight model
   */
  interface HotelHighlightFieldRefs {
    readonly id: FieldRef<"HotelHighlight", 'String'>
    readonly title: FieldRef<"HotelHighlight", 'String'>
    readonly order: FieldRef<"HotelHighlight", 'Int'>
    readonly description: FieldRef<"HotelHighlight", 'String'>
    readonly category: FieldRef<"HotelHighlight", 'String'>
    readonly icon: FieldRef<"HotelHighlight", 'String'>
    readonly priority: FieldRef<"HotelHighlight", 'Int'>
    readonly isPromoted: FieldRef<"HotelHighlight", 'Boolean'>
    readonly hotelId: FieldRef<"HotelHighlight", 'String'>
    readonly createdAt: FieldRef<"HotelHighlight", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelHighlight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelHighlight findUnique
   */
  export type HotelHighlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelHighlight to fetch.
     */
    where: HotelHighlightWhereUniqueInput
  }

  /**
   * HotelHighlight findUniqueOrThrow
   */
  export type HotelHighlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelHighlight to fetch.
     */
    where: HotelHighlightWhereUniqueInput
  }

  /**
   * HotelHighlight findFirst
   */
  export type HotelHighlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelHighlight to fetch.
     */
    where?: HotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelHighlights to fetch.
     */
    orderBy?: HotelHighlightOrderByWithRelationInput | HotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelHighlights.
     */
    cursor?: HotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelHighlights.
     */
    distinct?: HotelHighlightScalarFieldEnum | HotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelHighlight findFirstOrThrow
   */
  export type HotelHighlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelHighlight to fetch.
     */
    where?: HotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelHighlights to fetch.
     */
    orderBy?: HotelHighlightOrderByWithRelationInput | HotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelHighlights.
     */
    cursor?: HotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelHighlights.
     */
    distinct?: HotelHighlightScalarFieldEnum | HotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelHighlight findMany
   */
  export type HotelHighlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelHighlights to fetch.
     */
    where?: HotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelHighlights to fetch.
     */
    orderBy?: HotelHighlightOrderByWithRelationInput | HotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelHighlights.
     */
    cursor?: HotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelHighlights.
     */
    skip?: number
    distinct?: HotelHighlightScalarFieldEnum | HotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelHighlight create
   */
  export type HotelHighlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelHighlight.
     */
    data: XOR<HotelHighlightCreateInput, HotelHighlightUncheckedCreateInput>
  }

  /**
   * HotelHighlight createMany
   */
  export type HotelHighlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelHighlights.
     */
    data: HotelHighlightCreateManyInput | HotelHighlightCreateManyInput[]
  }

  /**
   * HotelHighlight createManyAndReturn
   */
  export type HotelHighlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * The data used to create many HotelHighlights.
     */
    data: HotelHighlightCreateManyInput | HotelHighlightCreateManyInput[]
  }

  /**
   * HotelHighlight update
   */
  export type HotelHighlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelHighlight.
     */
    data: XOR<HotelHighlightUpdateInput, HotelHighlightUncheckedUpdateInput>
    /**
     * Choose, which HotelHighlight to update.
     */
    where: HotelHighlightWhereUniqueInput
  }

  /**
   * HotelHighlight updateMany
   */
  export type HotelHighlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelHighlights.
     */
    data: XOR<HotelHighlightUpdateManyMutationInput, HotelHighlightUncheckedUpdateManyInput>
    /**
     * Filter which HotelHighlights to update
     */
    where?: HotelHighlightWhereInput
    /**
     * Limit how many HotelHighlights to update.
     */
    limit?: number
  }

  /**
   * HotelHighlight updateManyAndReturn
   */
  export type HotelHighlightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * The data used to update HotelHighlights.
     */
    data: XOR<HotelHighlightUpdateManyMutationInput, HotelHighlightUncheckedUpdateManyInput>
    /**
     * Filter which HotelHighlights to update
     */
    where?: HotelHighlightWhereInput
    /**
     * Limit how many HotelHighlights to update.
     */
    limit?: number
  }

  /**
   * HotelHighlight upsert
   */
  export type HotelHighlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelHighlight to update in case it exists.
     */
    where: HotelHighlightWhereUniqueInput
    /**
     * In case the HotelHighlight found by the `where` argument doesn't exist, create a new HotelHighlight with this data.
     */
    create: XOR<HotelHighlightCreateInput, HotelHighlightUncheckedCreateInput>
    /**
     * In case the HotelHighlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelHighlightUpdateInput, HotelHighlightUncheckedUpdateInput>
  }

  /**
   * HotelHighlight delete
   */
  export type HotelHighlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
    /**
     * Filter which HotelHighlight to delete.
     */
    where: HotelHighlightWhereUniqueInput
  }

  /**
   * HotelHighlight deleteMany
   */
  export type HotelHighlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelHighlights to delete
     */
    where?: HotelHighlightWhereInput
    /**
     * Limit how many HotelHighlights to delete.
     */
    limit?: number
  }

  /**
   * HotelHighlight.HotelCardToHotelHighlight
   */
  export type HotelHighlight$HotelCardToHotelHighlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    where?: HotelCardToHotelHighlightWhereInput
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToHotelHighlightScalarFieldEnum | HotelCardToHotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelHighlight without action
   */
  export type HotelHighlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelHighlight
     */
    select?: HotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelHighlight
     */
    omit?: HotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelHighlightInclude<ExtArgs> | null
  }


  /**
   * Model HotelAmenity
   */

  export type AggregateHotelAmenity = {
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  export type HotelAmenityAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelAmenitySumAggregateOutputType = {
    order: number | null
  }

  export type HotelAmenityMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    category: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelAmenityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    category: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelAmenityCountAggregateOutputType = {
    id: number
    name: number
    order: number
    category: number
    icon: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelAmenityAvgAggregateInputType = {
    order?: true
  }

  export type HotelAmenitySumAggregateInputType = {
    order?: true
  }

  export type HotelAmenityMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelAmenityMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelAmenityCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenity to aggregate.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelAmenities
    **/
    _count?: true | HotelAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type GetHotelAmenityAggregateType<T extends HotelAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelAmenity[P]>
      : GetScalarType<T[P], AggregateHotelAmenity[P]>
  }




  export type HotelAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithAggregationInput | HotelAmenityOrderByWithAggregationInput[]
    by: HotelAmenityScalarFieldEnum[] | HotelAmenityScalarFieldEnum
    having?: HotelAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelAmenityCountAggregateInputType | true
    _avg?: HotelAmenityAvgAggregateInputType
    _sum?: HotelAmenitySumAggregateInputType
    _min?: HotelAmenityMinAggregateInputType
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type HotelAmenityGroupByOutputType = {
    id: string
    name: string
    order: number | null
    category: string | null
    icon: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  type GetHotelAmenityGroupByPayload<T extends HotelAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
        }
      >
    >


  export type HotelAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | HotelAmenity$HotelCardArgs<ExtArgs>
    HotelCardToHotelAmenity?: boolean | HotelAmenity$HotelCardToHotelAmenityArgs<ExtArgs>
    _count?: boolean | HotelAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "category" | "icon" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelAmenity"]>
  export type HotelAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelAmenity$HotelCardArgs<ExtArgs>
    HotelCardToHotelAmenity?: boolean | HotelAmenity$HotelCardToHotelAmenityArgs<ExtArgs>
    _count?: boolean | HotelAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelAmenity"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
      HotelCardToHotelAmenity: Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      category: string | null
      icon: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelAmenity"]>
    composites: {}
  }

  type HotelAmenityGetPayload<S extends boolean | null | undefined | HotelAmenityDefaultArgs> = $Result.GetResult<Prisma.$HotelAmenityPayload, S>

  type HotelAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelAmenityCountAggregateInputType | true
    }

  export interface HotelAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelAmenity'], meta: { name: 'HotelAmenity' } }
    /**
     * Find zero or one HotelAmenity that matches the filter.
     * @param {HotelAmenityFindUniqueArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelAmenityFindUniqueArgs>(args: SelectSubset<T, HotelAmenityFindUniqueArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelAmenityFindUniqueOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelAmenityFindFirstArgs>(args?: SelectSubset<T, HotelAmenityFindFirstArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany()
     * 
     * // Get first 10 HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelAmenityWithIdOnly = await prisma.hotelAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelAmenityFindManyArgs>(args?: SelectSubset<T, HotelAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelAmenity.
     * @param {HotelAmenityCreateArgs} args - Arguments to create a HotelAmenity.
     * @example
     * // Create one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.create({
     *   data: {
     *     // ... data to create a HotelAmenity
     *   }
     * })
     * 
     */
    create<T extends HotelAmenityCreateArgs>(args: SelectSubset<T, HotelAmenityCreateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelAmenities.
     * @param {HotelAmenityCreateManyArgs} args - Arguments to create many HotelAmenities.
     * @example
     * // Create many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelAmenityCreateManyArgs>(args?: SelectSubset<T, HotelAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelAmenities and returns the data saved in the database.
     * @param {HotelAmenityCreateManyAndReturnArgs} args - Arguments to create many HotelAmenities.
     * @example
     * // Create many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelAmenities and only return the `id`
     * const hotelAmenityWithIdOnly = await prisma.hotelAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelAmenity.
     * @param {HotelAmenityDeleteArgs} args - Arguments to delete one HotelAmenity.
     * @example
     * // Delete one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.delete({
     *   where: {
     *     // ... filter to delete one HotelAmenity
     *   }
     * })
     * 
     */
    delete<T extends HotelAmenityDeleteArgs>(args: SelectSubset<T, HotelAmenityDeleteArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelAmenity.
     * @param {HotelAmenityUpdateArgs} args - Arguments to update one HotelAmenity.
     * @example
     * // Update one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelAmenityUpdateArgs>(args: SelectSubset<T, HotelAmenityUpdateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelAmenities.
     * @param {HotelAmenityDeleteManyArgs} args - Arguments to filter HotelAmenities to delete.
     * @example
     * // Delete a few HotelAmenities
     * const { count } = await prisma.hotelAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelAmenityDeleteManyArgs>(args?: SelectSubset<T, HotelAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelAmenityUpdateManyArgs>(args: SelectSubset<T, HotelAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenities and returns the data updated in the database.
     * @param {HotelAmenityUpdateManyAndReturnArgs} args - Arguments to update many HotelAmenities.
     * @example
     * // Update many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelAmenities and only return the `id`
     * const hotelAmenityWithIdOnly = await prisma.hotelAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelAmenity.
     * @param {HotelAmenityUpsertArgs} args - Arguments to update or create a HotelAmenity.
     * @example
     * // Update or create a HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.upsert({
     *   create: {
     *     // ... data to create a HotelAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelAmenity we want to update
     *   }
     * })
     */
    upsert<T extends HotelAmenityUpsertArgs>(args: SelectSubset<T, HotelAmenityUpsertArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityCountArgs} args - Arguments to filter HotelAmenities to count.
     * @example
     * // Count the number of HotelAmenities
     * const count = await prisma.hotelAmenity.count({
     *   where: {
     *     // ... the filter for the HotelAmenities we want to count
     *   }
     * })
    **/
    count<T extends HotelAmenityCountArgs>(
      args?: Subset<T, HotelAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAmenityAggregateArgs>(args: Subset<T, HotelAmenityAggregateArgs>): Prisma.PrismaPromise<GetHotelAmenityAggregateType<T>>

    /**
     * Group by HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelAmenityGroupByArgs['orderBy'] }
        : { orderBy?: HotelAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelAmenity model
   */
  readonly fields: HotelAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends HotelAmenity$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, HotelAmenity$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelCardToHotelAmenity<T extends HotelAmenity$HotelCardToHotelAmenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelAmenity$HotelCardToHotelAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelAmenity model
   */
  interface HotelAmenityFieldRefs {
    readonly id: FieldRef<"HotelAmenity", 'String'>
    readonly name: FieldRef<"HotelAmenity", 'String'>
    readonly order: FieldRef<"HotelAmenity", 'Int'>
    readonly category: FieldRef<"HotelAmenity", 'String'>
    readonly icon: FieldRef<"HotelAmenity", 'String'>
    readonly description: FieldRef<"HotelAmenity", 'String'>
    readonly createdAt: FieldRef<"HotelAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelAmenity findUnique
   */
  export type HotelAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findUniqueOrThrow
   */
  export type HotelAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findFirst
   */
  export type HotelAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findFirstOrThrow
   */
  export type HotelAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findMany
   */
  export type HotelAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenities to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity create
   */
  export type HotelAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelAmenity.
     */
    data: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
  }

  /**
   * HotelAmenity createMany
   */
  export type HotelAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelAmenities.
     */
    data: HotelAmenityCreateManyInput | HotelAmenityCreateManyInput[]
  }

  /**
   * HotelAmenity createManyAndReturn
   */
  export type HotelAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many HotelAmenities.
     */
    data: HotelAmenityCreateManyInput | HotelAmenityCreateManyInput[]
  }

  /**
   * HotelAmenity update
   */
  export type HotelAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelAmenity.
     */
    data: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
    /**
     * Choose, which HotelAmenity to update.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity updateMany
   */
  export type HotelAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelAmenities.
     */
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenities to update
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelAmenity updateManyAndReturn
   */
  export type HotelAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to update HotelAmenities.
     */
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenities to update
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelAmenity upsert
   */
  export type HotelAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelAmenity to update in case it exists.
     */
    where: HotelAmenityWhereUniqueInput
    /**
     * In case the HotelAmenity found by the `where` argument doesn't exist, create a new HotelAmenity with this data.
     */
    create: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
    /**
     * In case the HotelAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
  }

  /**
   * HotelAmenity delete
   */
  export type HotelAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter which HotelAmenity to delete.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity deleteMany
   */
  export type HotelAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenities to delete
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to delete.
     */
    limit?: number
  }

  /**
   * HotelAmenity.HotelCard
   */
  export type HotelAmenity$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelAmenity.HotelCardToHotelAmenity
   */
  export type HotelAmenity$HotelCardToHotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    where?: HotelCardToHotelAmenityWhereInput
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToHotelAmenityScalarFieldEnum | HotelCardToHotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity without action
   */
  export type HotelAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
  }


  /**
   * Model RoomAmenity
   */

  export type AggregateRoomAmenity = {
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  export type RoomAmenityAvgAggregateOutputType = {
    order: number | null
  }

  export type RoomAmenitySumAggregateOutputType = {
    order: number | null
  }

  export type RoomAmenityMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    category: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAmenityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    category: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAmenityCountAggregateOutputType = {
    id: number
    name: number
    order: number
    category: number
    icon: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAmenityAvgAggregateInputType = {
    order?: true
  }

  export type RoomAmenitySumAggregateInputType = {
    order?: true
  }

  export type RoomAmenityMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAmenityMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAmenityCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    category?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenity to aggregate.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAmenities
    **/
    _count?: true | RoomAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type GetRoomAmenityAggregateType<T extends RoomAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAmenity[P]>
      : GetScalarType<T[P], AggregateRoomAmenity[P]>
  }




  export type RoomAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithAggregationInput | RoomAmenityOrderByWithAggregationInput[]
    by: RoomAmenityScalarFieldEnum[] | RoomAmenityScalarFieldEnum
    having?: RoomAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAmenityCountAggregateInputType | true
    _avg?: RoomAmenityAvgAggregateInputType
    _sum?: RoomAmenitySumAggregateInputType
    _min?: RoomAmenityMinAggregateInputType
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type RoomAmenityGroupByOutputType = {
    id: string
    name: string
    order: number | null
    category: string
    icon: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  type GetRoomAmenityGroupByPayload<T extends RoomAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
        }
      >
    >


  export type RoomAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelDetails?: boolean | RoomAmenity$HotelDetailsArgs<ExtArgs>
    HotelDetailsToRoomAmenity?: boolean | RoomAmenity$HotelDetailsToRoomAmenityArgs<ExtArgs>
    _count?: boolean | RoomAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    category?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "category" | "icon" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["roomAmenity"]>
  export type RoomAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelDetails?: boolean | RoomAmenity$HotelDetailsArgs<ExtArgs>
    HotelDetailsToRoomAmenity?: boolean | RoomAmenity$HotelDetailsToRoomAmenityArgs<ExtArgs>
    _count?: boolean | RoomAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoomAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoomAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAmenity"
    objects: {
      HotelDetails: Prisma.$HotelDetailsPayload<ExtArgs>[]
      HotelDetailsToRoomAmenity: Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      category: string
      icon: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomAmenity"]>
    composites: {}
  }

  type RoomAmenityGetPayload<S extends boolean | null | undefined | RoomAmenityDefaultArgs> = $Result.GetResult<Prisma.$RoomAmenityPayload, S>

  type RoomAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomAmenityCountAggregateInputType | true
    }

  export interface RoomAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAmenity'], meta: { name: 'RoomAmenity' } }
    /**
     * Find zero or one RoomAmenity that matches the filter.
     * @param {RoomAmenityFindUniqueArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAmenityFindUniqueArgs>(args: SelectSubset<T, RoomAmenityFindUniqueArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomAmenityFindUniqueOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAmenityFindFirstArgs>(args?: SelectSubset<T, RoomAmenityFindFirstArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany()
     * 
     * // Get first 10 RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomAmenityWithIdOnly = await prisma.roomAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomAmenityFindManyArgs>(args?: SelectSubset<T, RoomAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomAmenity.
     * @param {RoomAmenityCreateArgs} args - Arguments to create a RoomAmenity.
     * @example
     * // Create one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.create({
     *   data: {
     *     // ... data to create a RoomAmenity
     *   }
     * })
     * 
     */
    create<T extends RoomAmenityCreateArgs>(args: SelectSubset<T, RoomAmenityCreateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomAmenities.
     * @param {RoomAmenityCreateManyArgs} args - Arguments to create many RoomAmenities.
     * @example
     * // Create many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAmenityCreateManyArgs>(args?: SelectSubset<T, RoomAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomAmenities and returns the data saved in the database.
     * @param {RoomAmenityCreateManyAndReturnArgs} args - Arguments to create many RoomAmenities.
     * @example
     * // Create many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomAmenities and only return the `id`
     * const roomAmenityWithIdOnly = await prisma.roomAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomAmenity.
     * @param {RoomAmenityDeleteArgs} args - Arguments to delete one RoomAmenity.
     * @example
     * // Delete one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.delete({
     *   where: {
     *     // ... filter to delete one RoomAmenity
     *   }
     * })
     * 
     */
    delete<T extends RoomAmenityDeleteArgs>(args: SelectSubset<T, RoomAmenityDeleteArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomAmenity.
     * @param {RoomAmenityUpdateArgs} args - Arguments to update one RoomAmenity.
     * @example
     * // Update one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAmenityUpdateArgs>(args: SelectSubset<T, RoomAmenityUpdateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomAmenities.
     * @param {RoomAmenityDeleteManyArgs} args - Arguments to filter RoomAmenities to delete.
     * @example
     * // Delete a few RoomAmenities
     * const { count } = await prisma.roomAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAmenityDeleteManyArgs>(args?: SelectSubset<T, RoomAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAmenityUpdateManyArgs>(args: SelectSubset<T, RoomAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenities and returns the data updated in the database.
     * @param {RoomAmenityUpdateManyAndReturnArgs} args - Arguments to update many RoomAmenities.
     * @example
     * // Update many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomAmenities and only return the `id`
     * const roomAmenityWithIdOnly = await prisma.roomAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomAmenity.
     * @param {RoomAmenityUpsertArgs} args - Arguments to update or create a RoomAmenity.
     * @example
     * // Update or create a RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.upsert({
     *   create: {
     *     // ... data to create a RoomAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAmenity we want to update
     *   }
     * })
     */
    upsert<T extends RoomAmenityUpsertArgs>(args: SelectSubset<T, RoomAmenityUpsertArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityCountArgs} args - Arguments to filter RoomAmenities to count.
     * @example
     * // Count the number of RoomAmenities
     * const count = await prisma.roomAmenity.count({
     *   where: {
     *     // ... the filter for the RoomAmenities we want to count
     *   }
     * })
    **/
    count<T extends RoomAmenityCountArgs>(
      args?: Subset<T, RoomAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAmenityAggregateArgs>(args: Subset<T, RoomAmenityAggregateArgs>): Prisma.PrismaPromise<GetRoomAmenityAggregateType<T>>

    /**
     * Group by RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAmenityGroupByArgs['orderBy'] }
        : { orderBy?: RoomAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAmenity model
   */
  readonly fields: RoomAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelDetails<T extends RoomAmenity$HotelDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RoomAmenity$HotelDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelDetailsToRoomAmenity<T extends RoomAmenity$HotelDetailsToRoomAmenityArgs<ExtArgs> = {}>(args?: Subset<T, RoomAmenity$HotelDetailsToRoomAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAmenity model
   */
  interface RoomAmenityFieldRefs {
    readonly id: FieldRef<"RoomAmenity", 'String'>
    readonly name: FieldRef<"RoomAmenity", 'String'>
    readonly order: FieldRef<"RoomAmenity", 'Int'>
    readonly category: FieldRef<"RoomAmenity", 'String'>
    readonly icon: FieldRef<"RoomAmenity", 'String'>
    readonly description: FieldRef<"RoomAmenity", 'String'>
    readonly createdAt: FieldRef<"RoomAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomAmenity findUnique
   */
  export type RoomAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findUniqueOrThrow
   */
  export type RoomAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findFirst
   */
  export type RoomAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findFirstOrThrow
   */
  export type RoomAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findMany
   */
  export type RoomAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenities to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity create
   */
  export type RoomAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAmenity.
     */
    data: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
  }

  /**
   * RoomAmenity createMany
   */
  export type RoomAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAmenities.
     */
    data: RoomAmenityCreateManyInput | RoomAmenityCreateManyInput[]
  }

  /**
   * RoomAmenity createManyAndReturn
   */
  export type RoomAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many RoomAmenities.
     */
    data: RoomAmenityCreateManyInput | RoomAmenityCreateManyInput[]
  }

  /**
   * RoomAmenity update
   */
  export type RoomAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAmenity.
     */
    data: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
    /**
     * Choose, which RoomAmenity to update.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity updateMany
   */
  export type RoomAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAmenities.
     */
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenities to update
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to update.
     */
    limit?: number
  }

  /**
   * RoomAmenity updateManyAndReturn
   */
  export type RoomAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to update RoomAmenities.
     */
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenities to update
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to update.
     */
    limit?: number
  }

  /**
   * RoomAmenity upsert
   */
  export type RoomAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAmenity to update in case it exists.
     */
    where: RoomAmenityWhereUniqueInput
    /**
     * In case the RoomAmenity found by the `where` argument doesn't exist, create a new RoomAmenity with this data.
     */
    create: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
    /**
     * In case the RoomAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
  }

  /**
   * RoomAmenity delete
   */
  export type RoomAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter which RoomAmenity to delete.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity deleteMany
   */
  export type RoomAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenities to delete
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to delete.
     */
    limit?: number
  }

  /**
   * RoomAmenity.HotelDetails
   */
  export type RoomAmenity$HotelDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    where?: HotelDetailsWhereInput
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    cursor?: HotelDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelDetailsScalarFieldEnum | HotelDetailsScalarFieldEnum[]
  }

  /**
   * RoomAmenity.HotelDetailsToRoomAmenity
   */
  export type RoomAmenity$HotelDetailsToRoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    where?: HotelDetailsToRoomAmenityWhereInput
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelDetailsToRoomAmenityScalarFieldEnum | HotelDetailsToRoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity without action
   */
  export type RoomAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
  }


  /**
   * Model AccessibilityOption
   */

  export type AggregateAccessibilityOption = {
    _count: AccessibilityOptionCountAggregateOutputType | null
    _avg: AccessibilityOptionAvgAggregateOutputType | null
    _sum: AccessibilityOptionSumAggregateOutputType | null
    _min: AccessibilityOptionMinAggregateOutputType | null
    _max: AccessibilityOptionMaxAggregateOutputType | null
  }

  export type AccessibilityOptionAvgAggregateOutputType = {
    order: number | null
  }

  export type AccessibilityOptionSumAggregateOutputType = {
    order: number | null
  }

  export type AccessibilityOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessibilityOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    code: string | null
    description: string | null
    category: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessibilityOptionCountAggregateOutputType = {
    id: number
    name: number
    order: number
    code: number
    description: number
    category: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccessibilityOptionAvgAggregateInputType = {
    order?: true
  }

  export type AccessibilityOptionSumAggregateInputType = {
    order?: true
  }

  export type AccessibilityOptionMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessibilityOptionMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessibilityOptionCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    code?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccessibilityOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessibilityOption to aggregate.
     */
    where?: AccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessibilityOptions to fetch.
     */
    orderBy?: AccessibilityOptionOrderByWithRelationInput | AccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessibilityOptions
    **/
    _count?: true | AccessibilityOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessibilityOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessibilityOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessibilityOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessibilityOptionMaxAggregateInputType
  }

  export type GetAccessibilityOptionAggregateType<T extends AccessibilityOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessibilityOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessibilityOption[P]>
      : GetScalarType<T[P], AggregateAccessibilityOption[P]>
  }




  export type AccessibilityOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessibilityOptionWhereInput
    orderBy?: AccessibilityOptionOrderByWithAggregationInput | AccessibilityOptionOrderByWithAggregationInput[]
    by: AccessibilityOptionScalarFieldEnum[] | AccessibilityOptionScalarFieldEnum
    having?: AccessibilityOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessibilityOptionCountAggregateInputType | true
    _avg?: AccessibilityOptionAvgAggregateInputType
    _sum?: AccessibilityOptionSumAggregateInputType
    _min?: AccessibilityOptionMinAggregateInputType
    _max?: AccessibilityOptionMaxAggregateInputType
  }

  export type AccessibilityOptionGroupByOutputType = {
    id: string
    name: string
    order: number | null
    code: string
    description: string | null
    category: string
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccessibilityOptionCountAggregateOutputType | null
    _avg: AccessibilityOptionAvgAggregateOutputType | null
    _sum: AccessibilityOptionSumAggregateOutputType | null
    _min: AccessibilityOptionMinAggregateOutputType | null
    _max: AccessibilityOptionMaxAggregateOutputType | null
  }

  type GetAccessibilityOptionGroupByPayload<T extends AccessibilityOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessibilityOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessibilityOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessibilityOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AccessibilityOptionGroupByOutputType[P]>
        }
      >
    >


  export type AccessibilityOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCardToAccessibilityOption?: boolean | AccessibilityOption$HotelCardToAccessibilityOptionArgs<ExtArgs>
    _count?: boolean | AccessibilityOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessibilityOption"]>

  export type AccessibilityOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accessibilityOption"]>

  export type AccessibilityOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accessibilityOption"]>

  export type AccessibilityOptionSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccessibilityOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "code" | "description" | "category" | "icon" | "createdAt" | "updatedAt", ExtArgs["result"]["accessibilityOption"]>
  export type AccessibilityOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCardToAccessibilityOption?: boolean | AccessibilityOption$HotelCardToAccessibilityOptionArgs<ExtArgs>
    _count?: boolean | AccessibilityOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccessibilityOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccessibilityOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccessibilityOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessibilityOption"
    objects: {
      HotelCardToAccessibilityOption: Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number | null
      code: string
      description: string | null
      category: string
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accessibilityOption"]>
    composites: {}
  }

  type AccessibilityOptionGetPayload<S extends boolean | null | undefined | AccessibilityOptionDefaultArgs> = $Result.GetResult<Prisma.$AccessibilityOptionPayload, S>

  type AccessibilityOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessibilityOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessibilityOptionCountAggregateInputType | true
    }

  export interface AccessibilityOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessibilityOption'], meta: { name: 'AccessibilityOption' } }
    /**
     * Find zero or one AccessibilityOption that matches the filter.
     * @param {AccessibilityOptionFindUniqueArgs} args - Arguments to find a AccessibilityOption
     * @example
     * // Get one AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessibilityOptionFindUniqueArgs>(args: SelectSubset<T, AccessibilityOptionFindUniqueArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessibilityOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessibilityOptionFindUniqueOrThrowArgs} args - Arguments to find a AccessibilityOption
     * @example
     * // Get one AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessibilityOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessibilityOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessibilityOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionFindFirstArgs} args - Arguments to find a AccessibilityOption
     * @example
     * // Get one AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessibilityOptionFindFirstArgs>(args?: SelectSubset<T, AccessibilityOptionFindFirstArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessibilityOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionFindFirstOrThrowArgs} args - Arguments to find a AccessibilityOption
     * @example
     * // Get one AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessibilityOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessibilityOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessibilityOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessibilityOptions
     * const accessibilityOptions = await prisma.accessibilityOption.findMany()
     * 
     * // Get first 10 AccessibilityOptions
     * const accessibilityOptions = await prisma.accessibilityOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessibilityOptionWithIdOnly = await prisma.accessibilityOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessibilityOptionFindManyArgs>(args?: SelectSubset<T, AccessibilityOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessibilityOption.
     * @param {AccessibilityOptionCreateArgs} args - Arguments to create a AccessibilityOption.
     * @example
     * // Create one AccessibilityOption
     * const AccessibilityOption = await prisma.accessibilityOption.create({
     *   data: {
     *     // ... data to create a AccessibilityOption
     *   }
     * })
     * 
     */
    create<T extends AccessibilityOptionCreateArgs>(args: SelectSubset<T, AccessibilityOptionCreateArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessibilityOptions.
     * @param {AccessibilityOptionCreateManyArgs} args - Arguments to create many AccessibilityOptions.
     * @example
     * // Create many AccessibilityOptions
     * const accessibilityOption = await prisma.accessibilityOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessibilityOptionCreateManyArgs>(args?: SelectSubset<T, AccessibilityOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessibilityOptions and returns the data saved in the database.
     * @param {AccessibilityOptionCreateManyAndReturnArgs} args - Arguments to create many AccessibilityOptions.
     * @example
     * // Create many AccessibilityOptions
     * const accessibilityOption = await prisma.accessibilityOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessibilityOptions and only return the `id`
     * const accessibilityOptionWithIdOnly = await prisma.accessibilityOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessibilityOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessibilityOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessibilityOption.
     * @param {AccessibilityOptionDeleteArgs} args - Arguments to delete one AccessibilityOption.
     * @example
     * // Delete one AccessibilityOption
     * const AccessibilityOption = await prisma.accessibilityOption.delete({
     *   where: {
     *     // ... filter to delete one AccessibilityOption
     *   }
     * })
     * 
     */
    delete<T extends AccessibilityOptionDeleteArgs>(args: SelectSubset<T, AccessibilityOptionDeleteArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessibilityOption.
     * @param {AccessibilityOptionUpdateArgs} args - Arguments to update one AccessibilityOption.
     * @example
     * // Update one AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessibilityOptionUpdateArgs>(args: SelectSubset<T, AccessibilityOptionUpdateArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessibilityOptions.
     * @param {AccessibilityOptionDeleteManyArgs} args - Arguments to filter AccessibilityOptions to delete.
     * @example
     * // Delete a few AccessibilityOptions
     * const { count } = await prisma.accessibilityOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessibilityOptionDeleteManyArgs>(args?: SelectSubset<T, AccessibilityOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessibilityOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessibilityOptions
     * const accessibilityOption = await prisma.accessibilityOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessibilityOptionUpdateManyArgs>(args: SelectSubset<T, AccessibilityOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessibilityOptions and returns the data updated in the database.
     * @param {AccessibilityOptionUpdateManyAndReturnArgs} args - Arguments to update many AccessibilityOptions.
     * @example
     * // Update many AccessibilityOptions
     * const accessibilityOption = await prisma.accessibilityOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessibilityOptions and only return the `id`
     * const accessibilityOptionWithIdOnly = await prisma.accessibilityOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessibilityOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessibilityOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessibilityOption.
     * @param {AccessibilityOptionUpsertArgs} args - Arguments to update or create a AccessibilityOption.
     * @example
     * // Update or create a AccessibilityOption
     * const accessibilityOption = await prisma.accessibilityOption.upsert({
     *   create: {
     *     // ... data to create a AccessibilityOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessibilityOption we want to update
     *   }
     * })
     */
    upsert<T extends AccessibilityOptionUpsertArgs>(args: SelectSubset<T, AccessibilityOptionUpsertArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessibilityOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionCountArgs} args - Arguments to filter AccessibilityOptions to count.
     * @example
     * // Count the number of AccessibilityOptions
     * const count = await prisma.accessibilityOption.count({
     *   where: {
     *     // ... the filter for the AccessibilityOptions we want to count
     *   }
     * })
    **/
    count<T extends AccessibilityOptionCountArgs>(
      args?: Subset<T, AccessibilityOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessibilityOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessibilityOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessibilityOptionAggregateArgs>(args: Subset<T, AccessibilityOptionAggregateArgs>): Prisma.PrismaPromise<GetAccessibilityOptionAggregateType<T>>

    /**
     * Group by AccessibilityOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessibilityOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessibilityOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessibilityOptionGroupByArgs['orderBy'] }
        : { orderBy?: AccessibilityOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessibilityOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessibilityOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessibilityOption model
   */
  readonly fields: AccessibilityOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessibilityOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessibilityOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCardToAccessibilityOption<T extends AccessibilityOption$HotelCardToAccessibilityOptionArgs<ExtArgs> = {}>(args?: Subset<T, AccessibilityOption$HotelCardToAccessibilityOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessibilityOption model
   */
  interface AccessibilityOptionFieldRefs {
    readonly id: FieldRef<"AccessibilityOption", 'String'>
    readonly name: FieldRef<"AccessibilityOption", 'String'>
    readonly order: FieldRef<"AccessibilityOption", 'Int'>
    readonly code: FieldRef<"AccessibilityOption", 'String'>
    readonly description: FieldRef<"AccessibilityOption", 'String'>
    readonly category: FieldRef<"AccessibilityOption", 'String'>
    readonly icon: FieldRef<"AccessibilityOption", 'String'>
    readonly createdAt: FieldRef<"AccessibilityOption", 'DateTime'>
    readonly updatedAt: FieldRef<"AccessibilityOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessibilityOption findUnique
   */
  export type AccessibilityOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which AccessibilityOption to fetch.
     */
    where: AccessibilityOptionWhereUniqueInput
  }

  /**
   * AccessibilityOption findUniqueOrThrow
   */
  export type AccessibilityOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which AccessibilityOption to fetch.
     */
    where: AccessibilityOptionWhereUniqueInput
  }

  /**
   * AccessibilityOption findFirst
   */
  export type AccessibilityOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which AccessibilityOption to fetch.
     */
    where?: AccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessibilityOptions to fetch.
     */
    orderBy?: AccessibilityOptionOrderByWithRelationInput | AccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessibilityOptions.
     */
    cursor?: AccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessibilityOptions.
     */
    distinct?: AccessibilityOptionScalarFieldEnum | AccessibilityOptionScalarFieldEnum[]
  }

  /**
   * AccessibilityOption findFirstOrThrow
   */
  export type AccessibilityOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which AccessibilityOption to fetch.
     */
    where?: AccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessibilityOptions to fetch.
     */
    orderBy?: AccessibilityOptionOrderByWithRelationInput | AccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessibilityOptions.
     */
    cursor?: AccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessibilityOptions.
     */
    distinct?: AccessibilityOptionScalarFieldEnum | AccessibilityOptionScalarFieldEnum[]
  }

  /**
   * AccessibilityOption findMany
   */
  export type AccessibilityOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which AccessibilityOptions to fetch.
     */
    where?: AccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessibilityOptions to fetch.
     */
    orderBy?: AccessibilityOptionOrderByWithRelationInput | AccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessibilityOptions.
     */
    cursor?: AccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessibilityOptions.
     */
    skip?: number
    distinct?: AccessibilityOptionScalarFieldEnum | AccessibilityOptionScalarFieldEnum[]
  }

  /**
   * AccessibilityOption create
   */
  export type AccessibilityOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessibilityOption.
     */
    data: XOR<AccessibilityOptionCreateInput, AccessibilityOptionUncheckedCreateInput>
  }

  /**
   * AccessibilityOption createMany
   */
  export type AccessibilityOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessibilityOptions.
     */
    data: AccessibilityOptionCreateManyInput | AccessibilityOptionCreateManyInput[]
  }

  /**
   * AccessibilityOption createManyAndReturn
   */
  export type AccessibilityOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * The data used to create many AccessibilityOptions.
     */
    data: AccessibilityOptionCreateManyInput | AccessibilityOptionCreateManyInput[]
  }

  /**
   * AccessibilityOption update
   */
  export type AccessibilityOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessibilityOption.
     */
    data: XOR<AccessibilityOptionUpdateInput, AccessibilityOptionUncheckedUpdateInput>
    /**
     * Choose, which AccessibilityOption to update.
     */
    where: AccessibilityOptionWhereUniqueInput
  }

  /**
   * AccessibilityOption updateMany
   */
  export type AccessibilityOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessibilityOptions.
     */
    data: XOR<AccessibilityOptionUpdateManyMutationInput, AccessibilityOptionUncheckedUpdateManyInput>
    /**
     * Filter which AccessibilityOptions to update
     */
    where?: AccessibilityOptionWhereInput
    /**
     * Limit how many AccessibilityOptions to update.
     */
    limit?: number
  }

  /**
   * AccessibilityOption updateManyAndReturn
   */
  export type AccessibilityOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * The data used to update AccessibilityOptions.
     */
    data: XOR<AccessibilityOptionUpdateManyMutationInput, AccessibilityOptionUncheckedUpdateManyInput>
    /**
     * Filter which AccessibilityOptions to update
     */
    where?: AccessibilityOptionWhereInput
    /**
     * Limit how many AccessibilityOptions to update.
     */
    limit?: number
  }

  /**
   * AccessibilityOption upsert
   */
  export type AccessibilityOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessibilityOption to update in case it exists.
     */
    where: AccessibilityOptionWhereUniqueInput
    /**
     * In case the AccessibilityOption found by the `where` argument doesn't exist, create a new AccessibilityOption with this data.
     */
    create: XOR<AccessibilityOptionCreateInput, AccessibilityOptionUncheckedCreateInput>
    /**
     * In case the AccessibilityOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessibilityOptionUpdateInput, AccessibilityOptionUncheckedUpdateInput>
  }

  /**
   * AccessibilityOption delete
   */
  export type AccessibilityOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter which AccessibilityOption to delete.
     */
    where: AccessibilityOptionWhereUniqueInput
  }

  /**
   * AccessibilityOption deleteMany
   */
  export type AccessibilityOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessibilityOptions to delete
     */
    where?: AccessibilityOptionWhereInput
    /**
     * Limit how many AccessibilityOptions to delete.
     */
    limit?: number
  }

  /**
   * AccessibilityOption.HotelCardToAccessibilityOption
   */
  export type AccessibilityOption$HotelCardToAccessibilityOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    where?: HotelCardToAccessibilityOptionWhereInput
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToAccessibilityOptionScalarFieldEnum | HotelCardToAccessibilityOptionScalarFieldEnum[]
  }

  /**
   * AccessibilityOption without action
   */
  export type AccessibilityOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilityOption
     */
    select?: AccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilityOption
     */
    omit?: AccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessibilityOptionInclude<ExtArgs> | null
  }


  /**
   * Model HotelParking
   */

  export type AggregateHotelParking = {
    _count: HotelParkingCountAggregateOutputType | null
    _avg: HotelParkingAvgAggregateOutputType | null
    _sum: HotelParkingSumAggregateOutputType | null
    _min: HotelParkingMinAggregateOutputType | null
    _max: HotelParkingMaxAggregateOutputType | null
  }

  export type HotelParkingAvgAggregateOutputType = {
    spaces: number | null
    order: number | null
  }

  export type HotelParkingSumAggregateOutputType = {
    spaces: number | null
    order: number | null
  }

  export type HotelParkingMinAggregateOutputType = {
    id: string | null
    isAvailable: boolean | null
    spaces: number | null
    order: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelParkingMaxAggregateOutputType = {
    id: string | null
    isAvailable: boolean | null
    spaces: number | null
    order: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelParkingCountAggregateOutputType = {
    id: number
    isAvailable: number
    spaces: number
    order: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelParkingAvgAggregateInputType = {
    spaces?: true
    order?: true
  }

  export type HotelParkingSumAggregateInputType = {
    spaces?: true
    order?: true
  }

  export type HotelParkingMinAggregateInputType = {
    id?: true
    isAvailable?: true
    spaces?: true
    order?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelParkingMaxAggregateInputType = {
    id?: true
    isAvailable?: true
    spaces?: true
    order?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelParkingCountAggregateInputType = {
    id?: true
    isAvailable?: true
    spaces?: true
    order?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelParkingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelParking to aggregate.
     */
    where?: HotelParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelParkings to fetch.
     */
    orderBy?: HotelParkingOrderByWithRelationInput | HotelParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelParkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelParkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelParkings
    **/
    _count?: true | HotelParkingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelParkingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelParkingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelParkingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelParkingMaxAggregateInputType
  }

  export type GetHotelParkingAggregateType<T extends HotelParkingAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelParking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelParking[P]>
      : GetScalarType<T[P], AggregateHotelParking[P]>
  }




  export type HotelParkingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelParkingWhereInput
    orderBy?: HotelParkingOrderByWithAggregationInput | HotelParkingOrderByWithAggregationInput[]
    by: HotelParkingScalarFieldEnum[] | HotelParkingScalarFieldEnum
    having?: HotelParkingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelParkingCountAggregateInputType | true
    _avg?: HotelParkingAvgAggregateInputType
    _sum?: HotelParkingSumAggregateInputType
    _min?: HotelParkingMinAggregateInputType
    _max?: HotelParkingMaxAggregateInputType
  }

  export type HotelParkingGroupByOutputType = {
    id: string
    isAvailable: boolean
    spaces: number | null
    order: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelParkingCountAggregateOutputType | null
    _avg: HotelParkingAvgAggregateOutputType | null
    _sum: HotelParkingSumAggregateOutputType | null
    _min: HotelParkingMinAggregateOutputType | null
    _max: HotelParkingMaxAggregateOutputType | null
  }

  type GetHotelParkingGroupByPayload<T extends HotelParkingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelParkingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelParkingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelParkingGroupByOutputType[P]>
            : GetScalarType<T[P], HotelParkingGroupByOutputType[P]>
        }
      >
    >


  export type HotelParkingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAvailable?: boolean
    spaces?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | HotelParking$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelParkingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelParking"]>

  export type HotelParkingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAvailable?: boolean
    spaces?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelParking"]>

  export type HotelParkingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAvailable?: boolean
    spaces?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelParking"]>

  export type HotelParkingSelectScalar = {
    id?: boolean
    isAvailable?: boolean
    spaces?: boolean
    order?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelParkingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isAvailable" | "spaces" | "order" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelParking"]>
  export type HotelParkingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelParking$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelParkingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelParkingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelParkingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelParkingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelParking"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isAvailable: boolean
      spaces: number | null
      order: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelParking"]>
    composites: {}
  }

  type HotelParkingGetPayload<S extends boolean | null | undefined | HotelParkingDefaultArgs> = $Result.GetResult<Prisma.$HotelParkingPayload, S>

  type HotelParkingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelParkingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelParkingCountAggregateInputType | true
    }

  export interface HotelParkingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelParking'], meta: { name: 'HotelParking' } }
    /**
     * Find zero or one HotelParking that matches the filter.
     * @param {HotelParkingFindUniqueArgs} args - Arguments to find a HotelParking
     * @example
     * // Get one HotelParking
     * const hotelParking = await prisma.hotelParking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelParkingFindUniqueArgs>(args: SelectSubset<T, HotelParkingFindUniqueArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelParking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelParkingFindUniqueOrThrowArgs} args - Arguments to find a HotelParking
     * @example
     * // Get one HotelParking
     * const hotelParking = await prisma.hotelParking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelParkingFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelParkingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelParking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingFindFirstArgs} args - Arguments to find a HotelParking
     * @example
     * // Get one HotelParking
     * const hotelParking = await prisma.hotelParking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelParkingFindFirstArgs>(args?: SelectSubset<T, HotelParkingFindFirstArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelParking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingFindFirstOrThrowArgs} args - Arguments to find a HotelParking
     * @example
     * // Get one HotelParking
     * const hotelParking = await prisma.hotelParking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelParkingFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelParkingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelParkings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelParkings
     * const hotelParkings = await prisma.hotelParking.findMany()
     * 
     * // Get first 10 HotelParkings
     * const hotelParkings = await prisma.hotelParking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelParkingWithIdOnly = await prisma.hotelParking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelParkingFindManyArgs>(args?: SelectSubset<T, HotelParkingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelParking.
     * @param {HotelParkingCreateArgs} args - Arguments to create a HotelParking.
     * @example
     * // Create one HotelParking
     * const HotelParking = await prisma.hotelParking.create({
     *   data: {
     *     // ... data to create a HotelParking
     *   }
     * })
     * 
     */
    create<T extends HotelParkingCreateArgs>(args: SelectSubset<T, HotelParkingCreateArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelParkings.
     * @param {HotelParkingCreateManyArgs} args - Arguments to create many HotelParkings.
     * @example
     * // Create many HotelParkings
     * const hotelParking = await prisma.hotelParking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelParkingCreateManyArgs>(args?: SelectSubset<T, HotelParkingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelParkings and returns the data saved in the database.
     * @param {HotelParkingCreateManyAndReturnArgs} args - Arguments to create many HotelParkings.
     * @example
     * // Create many HotelParkings
     * const hotelParking = await prisma.hotelParking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelParkings and only return the `id`
     * const hotelParkingWithIdOnly = await prisma.hotelParking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelParkingCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelParkingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelParking.
     * @param {HotelParkingDeleteArgs} args - Arguments to delete one HotelParking.
     * @example
     * // Delete one HotelParking
     * const HotelParking = await prisma.hotelParking.delete({
     *   where: {
     *     // ... filter to delete one HotelParking
     *   }
     * })
     * 
     */
    delete<T extends HotelParkingDeleteArgs>(args: SelectSubset<T, HotelParkingDeleteArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelParking.
     * @param {HotelParkingUpdateArgs} args - Arguments to update one HotelParking.
     * @example
     * // Update one HotelParking
     * const hotelParking = await prisma.hotelParking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelParkingUpdateArgs>(args: SelectSubset<T, HotelParkingUpdateArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelParkings.
     * @param {HotelParkingDeleteManyArgs} args - Arguments to filter HotelParkings to delete.
     * @example
     * // Delete a few HotelParkings
     * const { count } = await prisma.hotelParking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelParkingDeleteManyArgs>(args?: SelectSubset<T, HotelParkingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelParkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelParkings
     * const hotelParking = await prisma.hotelParking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelParkingUpdateManyArgs>(args: SelectSubset<T, HotelParkingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelParkings and returns the data updated in the database.
     * @param {HotelParkingUpdateManyAndReturnArgs} args - Arguments to update many HotelParkings.
     * @example
     * // Update many HotelParkings
     * const hotelParking = await prisma.hotelParking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelParkings and only return the `id`
     * const hotelParkingWithIdOnly = await prisma.hotelParking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelParkingUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelParkingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelParking.
     * @param {HotelParkingUpsertArgs} args - Arguments to update or create a HotelParking.
     * @example
     * // Update or create a HotelParking
     * const hotelParking = await prisma.hotelParking.upsert({
     *   create: {
     *     // ... data to create a HotelParking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelParking we want to update
     *   }
     * })
     */
    upsert<T extends HotelParkingUpsertArgs>(args: SelectSubset<T, HotelParkingUpsertArgs<ExtArgs>>): Prisma__HotelParkingClient<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelParkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingCountArgs} args - Arguments to filter HotelParkings to count.
     * @example
     * // Count the number of HotelParkings
     * const count = await prisma.hotelParking.count({
     *   where: {
     *     // ... the filter for the HotelParkings we want to count
     *   }
     * })
    **/
    count<T extends HotelParkingCountArgs>(
      args?: Subset<T, HotelParkingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelParkingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelParking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelParkingAggregateArgs>(args: Subset<T, HotelParkingAggregateArgs>): Prisma.PrismaPromise<GetHotelParkingAggregateType<T>>

    /**
     * Group by HotelParking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelParkingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelParkingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelParkingGroupByArgs['orderBy'] }
        : { orderBy?: HotelParkingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelParkingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelParkingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelParking model
   */
  readonly fields: HotelParkingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelParking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelParkingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends HotelParking$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, HotelParking$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelParking model
   */
  interface HotelParkingFieldRefs {
    readonly id: FieldRef<"HotelParking", 'String'>
    readonly isAvailable: FieldRef<"HotelParking", 'Boolean'>
    readonly spaces: FieldRef<"HotelParking", 'Int'>
    readonly order: FieldRef<"HotelParking", 'Int'>
    readonly notes: FieldRef<"HotelParking", 'String'>
    readonly createdAt: FieldRef<"HotelParking", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelParking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelParking findUnique
   */
  export type HotelParkingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter, which HotelParking to fetch.
     */
    where: HotelParkingWhereUniqueInput
  }

  /**
   * HotelParking findUniqueOrThrow
   */
  export type HotelParkingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter, which HotelParking to fetch.
     */
    where: HotelParkingWhereUniqueInput
  }

  /**
   * HotelParking findFirst
   */
  export type HotelParkingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter, which HotelParking to fetch.
     */
    where?: HotelParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelParkings to fetch.
     */
    orderBy?: HotelParkingOrderByWithRelationInput | HotelParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelParkings.
     */
    cursor?: HotelParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelParkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelParkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelParkings.
     */
    distinct?: HotelParkingScalarFieldEnum | HotelParkingScalarFieldEnum[]
  }

  /**
   * HotelParking findFirstOrThrow
   */
  export type HotelParkingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter, which HotelParking to fetch.
     */
    where?: HotelParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelParkings to fetch.
     */
    orderBy?: HotelParkingOrderByWithRelationInput | HotelParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelParkings.
     */
    cursor?: HotelParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelParkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelParkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelParkings.
     */
    distinct?: HotelParkingScalarFieldEnum | HotelParkingScalarFieldEnum[]
  }

  /**
   * HotelParking findMany
   */
  export type HotelParkingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter, which HotelParkings to fetch.
     */
    where?: HotelParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelParkings to fetch.
     */
    orderBy?: HotelParkingOrderByWithRelationInput | HotelParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelParkings.
     */
    cursor?: HotelParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelParkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelParkings.
     */
    skip?: number
    distinct?: HotelParkingScalarFieldEnum | HotelParkingScalarFieldEnum[]
  }

  /**
   * HotelParking create
   */
  export type HotelParkingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelParking.
     */
    data: XOR<HotelParkingCreateInput, HotelParkingUncheckedCreateInput>
  }

  /**
   * HotelParking createMany
   */
  export type HotelParkingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelParkings.
     */
    data: HotelParkingCreateManyInput | HotelParkingCreateManyInput[]
  }

  /**
   * HotelParking createManyAndReturn
   */
  export type HotelParkingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * The data used to create many HotelParkings.
     */
    data: HotelParkingCreateManyInput | HotelParkingCreateManyInput[]
  }

  /**
   * HotelParking update
   */
  export type HotelParkingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelParking.
     */
    data: XOR<HotelParkingUpdateInput, HotelParkingUncheckedUpdateInput>
    /**
     * Choose, which HotelParking to update.
     */
    where: HotelParkingWhereUniqueInput
  }

  /**
   * HotelParking updateMany
   */
  export type HotelParkingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelParkings.
     */
    data: XOR<HotelParkingUpdateManyMutationInput, HotelParkingUncheckedUpdateManyInput>
    /**
     * Filter which HotelParkings to update
     */
    where?: HotelParkingWhereInput
    /**
     * Limit how many HotelParkings to update.
     */
    limit?: number
  }

  /**
   * HotelParking updateManyAndReturn
   */
  export type HotelParkingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * The data used to update HotelParkings.
     */
    data: XOR<HotelParkingUpdateManyMutationInput, HotelParkingUncheckedUpdateManyInput>
    /**
     * Filter which HotelParkings to update
     */
    where?: HotelParkingWhereInput
    /**
     * Limit how many HotelParkings to update.
     */
    limit?: number
  }

  /**
   * HotelParking upsert
   */
  export type HotelParkingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelParking to update in case it exists.
     */
    where: HotelParkingWhereUniqueInput
    /**
     * In case the HotelParking found by the `where` argument doesn't exist, create a new HotelParking with this data.
     */
    create: XOR<HotelParkingCreateInput, HotelParkingUncheckedCreateInput>
    /**
     * In case the HotelParking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelParkingUpdateInput, HotelParkingUncheckedUpdateInput>
  }

  /**
   * HotelParking delete
   */
  export type HotelParkingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    /**
     * Filter which HotelParking to delete.
     */
    where: HotelParkingWhereUniqueInput
  }

  /**
   * HotelParking deleteMany
   */
  export type HotelParkingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelParkings to delete
     */
    where?: HotelParkingWhereInput
    /**
     * Limit how many HotelParkings to delete.
     */
    limit?: number
  }

  /**
   * HotelParking.HotelCard
   */
  export type HotelParking$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelParking without action
   */
  export type HotelParkingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    streetNumber: string | null
    streetName: string | null
    addressLine2: string | null
    postalCode: string | null
    cityId: string | null
    neighborhoodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    streetNumber: string | null
    streetName: string | null
    addressLine2: string | null
    postalCode: string | null
    cityId: string | null
    neighborhoodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    streetNumber: number
    streetName: number
    addressLine2: number
    postalCode: number
    cityId: number
    neighborhoodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    streetNumber?: true
    streetName?: true
    addressLine2?: true
    postalCode?: true
    cityId?: true
    neighborhoodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    streetNumber?: true
    streetName?: true
    addressLine2?: true
    postalCode?: true
    cityId?: true
    neighborhoodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    streetNumber?: true
    streetName?: true
    addressLine2?: true
    postalCode?: true
    cityId?: true
    neighborhoodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    streetNumber: string | null
    streetName: string
    addressLine2: string | null
    postalCode: string
    cityId: string
    neighborhoodId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetNumber?: boolean
    streetName?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    cityId?: boolean
    neighborhoodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
    hotelDetails?: boolean | Address$hotelDetailsArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetNumber?: boolean
    streetName?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    cityId?: boolean
    neighborhoodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetNumber?: boolean
    streetName?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    cityId?: boolean
    neighborhoodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    streetNumber?: boolean
    streetName?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    cityId?: boolean
    neighborhoodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streetNumber" | "streetName" | "addressLine2" | "postalCode" | "cityId" | "neighborhoodId" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
    hotelDetails?: boolean | Address$hotelDetailsArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    neighborhood?: boolean | Address$neighborhoodArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      neighborhood: Prisma.$NeighborhoodPayload<ExtArgs> | null
      hotelDetails: Prisma.$HotelDetailsPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streetNumber: string | null
      streetName: string
      addressLine2: string | null
      postalCode: string
      cityId: string
      neighborhoodId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    neighborhood<T extends Address$neighborhoodArgs<ExtArgs> = {}>(args?: Subset<T, Address$neighborhoodArgs<ExtArgs>>): Prisma__NeighborhoodClient<$Result.GetResult<Prisma.$NeighborhoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotelDetails<T extends Address$hotelDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Address$hotelDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Address$userArgs<ExtArgs> = {}>(args?: Subset<T, Address$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly streetNumber: FieldRef<"Address", 'String'>
    readonly streetName: FieldRef<"Address", 'String'>
    readonly addressLine2: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly cityId: FieldRef<"Address", 'String'>
    readonly neighborhoodId: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.neighborhood
   */
  export type Address$neighborhoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Neighborhood
     */
    select?: NeighborhoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Neighborhood
     */
    omit?: NeighborhoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeighborhoodInclude<ExtArgs> | null
    where?: NeighborhoodWhereInput
  }

  /**
   * Address.hotelDetails
   */
  export type Address$hotelDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    where?: HotelDetailsWhereInput
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    cursor?: HotelDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelDetailsScalarFieldEnum | HotelDetailsScalarFieldEnum[]
  }

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model HotelImage
   */

  export type AggregateHotelImage = {
    _count: HotelImageCountAggregateOutputType | null
    _avg: HotelImageAvgAggregateOutputType | null
    _sum: HotelImageSumAggregateOutputType | null
    _min: HotelImageMinAggregateOutputType | null
    _max: HotelImageMaxAggregateOutputType | null
  }

  export type HotelImageAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelImageSumAggregateOutputType = {
    order: number | null
  }

  export type HotelImageMinAggregateOutputType = {
    id: string | null
    entityId: string | null
    imageUrl: string | null
    imageType: string | null
    order: number | null
    alt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelImageMaxAggregateOutputType = {
    id: string | null
    entityId: string | null
    imageUrl: string | null
    imageType: string | null
    order: number | null
    alt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelImageCountAggregateOutputType = {
    id: number
    entityId: number
    imageUrl: number
    imageType: number
    order: number
    alt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelImageAvgAggregateInputType = {
    order?: true
  }

  export type HotelImageSumAggregateInputType = {
    order?: true
  }

  export type HotelImageMinAggregateInputType = {
    id?: true
    entityId?: true
    imageUrl?: true
    imageType?: true
    order?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelImageMaxAggregateInputType = {
    id?: true
    entityId?: true
    imageUrl?: true
    imageType?: true
    order?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelImageCountAggregateInputType = {
    id?: true
    entityId?: true
    imageUrl?: true
    imageType?: true
    order?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelImage to aggregate.
     */
    where?: HotelImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelImages to fetch.
     */
    orderBy?: HotelImageOrderByWithRelationInput | HotelImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelImages
    **/
    _count?: true | HotelImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelImageMaxAggregateInputType
  }

  export type GetHotelImageAggregateType<T extends HotelImageAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelImage[P]>
      : GetScalarType<T[P], AggregateHotelImage[P]>
  }




  export type HotelImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelImageWhereInput
    orderBy?: HotelImageOrderByWithAggregationInput | HotelImageOrderByWithAggregationInput[]
    by: HotelImageScalarFieldEnum[] | HotelImageScalarFieldEnum
    having?: HotelImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelImageCountAggregateInputType | true
    _avg?: HotelImageAvgAggregateInputType
    _sum?: HotelImageSumAggregateInputType
    _min?: HotelImageMinAggregateInputType
    _max?: HotelImageMaxAggregateInputType
  }

  export type HotelImageGroupByOutputType = {
    id: string
    entityId: string
    imageUrl: string
    imageType: string
    order: number
    alt: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelImageCountAggregateOutputType | null
    _avg: HotelImageAvgAggregateOutputType | null
    _sum: HotelImageSumAggregateOutputType | null
    _min: HotelImageMinAggregateOutputType | null
    _max: HotelImageMaxAggregateOutputType | null
  }

  type GetHotelImageGroupByPayload<T extends HotelImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelImageGroupByOutputType[P]>
            : GetScalarType<T[P], HotelImageGroupByOutputType[P]>
        }
      >
    >


  export type HotelImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityId?: boolean
    imageUrl?: boolean
    imageType?: boolean
    order?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HotelCard?: boolean | HotelImage$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelImage"]>

  export type HotelImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityId?: boolean
    imageUrl?: boolean
    imageType?: boolean
    order?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelImage"]>

  export type HotelImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityId?: boolean
    imageUrl?: boolean
    imageType?: boolean
    order?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotelImage"]>

  export type HotelImageSelectScalar = {
    id?: boolean
    entityId?: boolean
    imageUrl?: boolean
    imageType?: boolean
    order?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityId" | "imageUrl" | "imageType" | "order" | "alt" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelImage"]>
  export type HotelImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotelCard?: boolean | HotelImage$HotelCardArgs<ExtArgs>
    _count?: boolean | HotelImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelImage"
    objects: {
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityId: string
      imageUrl: string
      imageType: string
      order: number
      alt: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelImage"]>
    composites: {}
  }

  type HotelImageGetPayload<S extends boolean | null | undefined | HotelImageDefaultArgs> = $Result.GetResult<Prisma.$HotelImagePayload, S>

  type HotelImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelImageCountAggregateInputType | true
    }

  export interface HotelImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelImage'], meta: { name: 'HotelImage' } }
    /**
     * Find zero or one HotelImage that matches the filter.
     * @param {HotelImageFindUniqueArgs} args - Arguments to find a HotelImage
     * @example
     * // Get one HotelImage
     * const hotelImage = await prisma.hotelImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelImageFindUniqueArgs>(args: SelectSubset<T, HotelImageFindUniqueArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelImageFindUniqueOrThrowArgs} args - Arguments to find a HotelImage
     * @example
     * // Get one HotelImage
     * const hotelImage = await prisma.hotelImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelImageFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageFindFirstArgs} args - Arguments to find a HotelImage
     * @example
     * // Get one HotelImage
     * const hotelImage = await prisma.hotelImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelImageFindFirstArgs>(args?: SelectSubset<T, HotelImageFindFirstArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageFindFirstOrThrowArgs} args - Arguments to find a HotelImage
     * @example
     * // Get one HotelImage
     * const hotelImage = await prisma.hotelImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelImageFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelImages
     * const hotelImages = await prisma.hotelImage.findMany()
     * 
     * // Get first 10 HotelImages
     * const hotelImages = await prisma.hotelImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelImageWithIdOnly = await prisma.hotelImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelImageFindManyArgs>(args?: SelectSubset<T, HotelImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelImage.
     * @param {HotelImageCreateArgs} args - Arguments to create a HotelImage.
     * @example
     * // Create one HotelImage
     * const HotelImage = await prisma.hotelImage.create({
     *   data: {
     *     // ... data to create a HotelImage
     *   }
     * })
     * 
     */
    create<T extends HotelImageCreateArgs>(args: SelectSubset<T, HotelImageCreateArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelImages.
     * @param {HotelImageCreateManyArgs} args - Arguments to create many HotelImages.
     * @example
     * // Create many HotelImages
     * const hotelImage = await prisma.hotelImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelImageCreateManyArgs>(args?: SelectSubset<T, HotelImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelImages and returns the data saved in the database.
     * @param {HotelImageCreateManyAndReturnArgs} args - Arguments to create many HotelImages.
     * @example
     * // Create many HotelImages
     * const hotelImage = await prisma.hotelImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelImages and only return the `id`
     * const hotelImageWithIdOnly = await prisma.hotelImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelImageCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelImage.
     * @param {HotelImageDeleteArgs} args - Arguments to delete one HotelImage.
     * @example
     * // Delete one HotelImage
     * const HotelImage = await prisma.hotelImage.delete({
     *   where: {
     *     // ... filter to delete one HotelImage
     *   }
     * })
     * 
     */
    delete<T extends HotelImageDeleteArgs>(args: SelectSubset<T, HotelImageDeleteArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelImage.
     * @param {HotelImageUpdateArgs} args - Arguments to update one HotelImage.
     * @example
     * // Update one HotelImage
     * const hotelImage = await prisma.hotelImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelImageUpdateArgs>(args: SelectSubset<T, HotelImageUpdateArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelImages.
     * @param {HotelImageDeleteManyArgs} args - Arguments to filter HotelImages to delete.
     * @example
     * // Delete a few HotelImages
     * const { count } = await prisma.hotelImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelImageDeleteManyArgs>(args?: SelectSubset<T, HotelImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelImages
     * const hotelImage = await prisma.hotelImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelImageUpdateManyArgs>(args: SelectSubset<T, HotelImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelImages and returns the data updated in the database.
     * @param {HotelImageUpdateManyAndReturnArgs} args - Arguments to update many HotelImages.
     * @example
     * // Update many HotelImages
     * const hotelImage = await prisma.hotelImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelImages and only return the `id`
     * const hotelImageWithIdOnly = await prisma.hotelImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelImageUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelImage.
     * @param {HotelImageUpsertArgs} args - Arguments to update or create a HotelImage.
     * @example
     * // Update or create a HotelImage
     * const hotelImage = await prisma.hotelImage.upsert({
     *   create: {
     *     // ... data to create a HotelImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelImage we want to update
     *   }
     * })
     */
    upsert<T extends HotelImageUpsertArgs>(args: SelectSubset<T, HotelImageUpsertArgs<ExtArgs>>): Prisma__HotelImageClient<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageCountArgs} args - Arguments to filter HotelImages to count.
     * @example
     * // Count the number of HotelImages
     * const count = await prisma.hotelImage.count({
     *   where: {
     *     // ... the filter for the HotelImages we want to count
     *   }
     * })
    **/
    count<T extends HotelImageCountArgs>(
      args?: Subset<T, HotelImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelImageAggregateArgs>(args: Subset<T, HotelImageAggregateArgs>): Prisma.PrismaPromise<GetHotelImageAggregateType<T>>

    /**
     * Group by HotelImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelImageGroupByArgs['orderBy'] }
        : { orderBy?: HotelImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelImage model
   */
  readonly fields: HotelImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotelCard<T extends HotelImage$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, HotelImage$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelImage model
   */
  interface HotelImageFieldRefs {
    readonly id: FieldRef<"HotelImage", 'String'>
    readonly entityId: FieldRef<"HotelImage", 'String'>
    readonly imageUrl: FieldRef<"HotelImage", 'String'>
    readonly imageType: FieldRef<"HotelImage", 'String'>
    readonly order: FieldRef<"HotelImage", 'Int'>
    readonly alt: FieldRef<"HotelImage", 'String'>
    readonly createdAt: FieldRef<"HotelImage", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelImage findUnique
   */
  export type HotelImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter, which HotelImage to fetch.
     */
    where: HotelImageWhereUniqueInput
  }

  /**
   * HotelImage findUniqueOrThrow
   */
  export type HotelImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter, which HotelImage to fetch.
     */
    where: HotelImageWhereUniqueInput
  }

  /**
   * HotelImage findFirst
   */
  export type HotelImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter, which HotelImage to fetch.
     */
    where?: HotelImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelImages to fetch.
     */
    orderBy?: HotelImageOrderByWithRelationInput | HotelImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelImages.
     */
    cursor?: HotelImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelImages.
     */
    distinct?: HotelImageScalarFieldEnum | HotelImageScalarFieldEnum[]
  }

  /**
   * HotelImage findFirstOrThrow
   */
  export type HotelImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter, which HotelImage to fetch.
     */
    where?: HotelImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelImages to fetch.
     */
    orderBy?: HotelImageOrderByWithRelationInput | HotelImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelImages.
     */
    cursor?: HotelImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelImages.
     */
    distinct?: HotelImageScalarFieldEnum | HotelImageScalarFieldEnum[]
  }

  /**
   * HotelImage findMany
   */
  export type HotelImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter, which HotelImages to fetch.
     */
    where?: HotelImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelImages to fetch.
     */
    orderBy?: HotelImageOrderByWithRelationInput | HotelImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelImages.
     */
    cursor?: HotelImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelImages.
     */
    skip?: number
    distinct?: HotelImageScalarFieldEnum | HotelImageScalarFieldEnum[]
  }

  /**
   * HotelImage create
   */
  export type HotelImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelImage.
     */
    data: XOR<HotelImageCreateInput, HotelImageUncheckedCreateInput>
  }

  /**
   * HotelImage createMany
   */
  export type HotelImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelImages.
     */
    data: HotelImageCreateManyInput | HotelImageCreateManyInput[]
  }

  /**
   * HotelImage createManyAndReturn
   */
  export type HotelImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * The data used to create many HotelImages.
     */
    data: HotelImageCreateManyInput | HotelImageCreateManyInput[]
  }

  /**
   * HotelImage update
   */
  export type HotelImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelImage.
     */
    data: XOR<HotelImageUpdateInput, HotelImageUncheckedUpdateInput>
    /**
     * Choose, which HotelImage to update.
     */
    where: HotelImageWhereUniqueInput
  }

  /**
   * HotelImage updateMany
   */
  export type HotelImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelImages.
     */
    data: XOR<HotelImageUpdateManyMutationInput, HotelImageUncheckedUpdateManyInput>
    /**
     * Filter which HotelImages to update
     */
    where?: HotelImageWhereInput
    /**
     * Limit how many HotelImages to update.
     */
    limit?: number
  }

  /**
   * HotelImage updateManyAndReturn
   */
  export type HotelImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * The data used to update HotelImages.
     */
    data: XOR<HotelImageUpdateManyMutationInput, HotelImageUncheckedUpdateManyInput>
    /**
     * Filter which HotelImages to update
     */
    where?: HotelImageWhereInput
    /**
     * Limit how many HotelImages to update.
     */
    limit?: number
  }

  /**
   * HotelImage upsert
   */
  export type HotelImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelImage to update in case it exists.
     */
    where: HotelImageWhereUniqueInput
    /**
     * In case the HotelImage found by the `where` argument doesn't exist, create a new HotelImage with this data.
     */
    create: XOR<HotelImageCreateInput, HotelImageUncheckedCreateInput>
    /**
     * In case the HotelImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelImageUpdateInput, HotelImageUncheckedUpdateInput>
  }

  /**
   * HotelImage delete
   */
  export type HotelImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    /**
     * Filter which HotelImage to delete.
     */
    where: HotelImageWhereUniqueInput
  }

  /**
   * HotelImage deleteMany
   */
  export type HotelImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelImages to delete
     */
    where?: HotelImageWhereInput
    /**
     * Limit how many HotelImages to delete.
     */
    limit?: number
  }

  /**
   * HotelImage.HotelCard
   */
  export type HotelImage$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelImage without action
   */
  export type HotelImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
  }


  /**
   * Model HotelCard
   */

  export type AggregateHotelCard = {
    _count: HotelCardCountAggregateOutputType | null
    _avg: HotelCardAvgAggregateOutputType | null
    _sum: HotelCardSumAggregateOutputType | null
    _min: HotelCardMinAggregateOutputType | null
    _max: HotelCardMaxAggregateOutputType | null
  }

  export type HotelCardAvgAggregateOutputType = {
    order: number | null
    starRating: number | null
    overallRating: number | null
    reviewCount: number | null
    basePricePerNight: number | null
    regularPrice: number | null
    latitude: number | null
    longitude: number | null
  }

  export type HotelCardSumAggregateOutputType = {
    order: number | null
    starRating: number | null
    overallRating: number | null
    reviewCount: number | null
    basePricePerNight: number | null
    regularPrice: number | null
    latitude: number | null
    longitude: number | null
  }

  export type HotelCardMinAggregateOutputType = {
    id: string | null
    name: string | null
    idCity: string | null
    order: number | null
    shortDescription: string | null
    starRating: number | null
    overallRating: number | null
    ratingAdjective: string | null
    reviewCount: number | null
    basePricePerNight: number | null
    regularPrice: number | null
    currency: string | null
    isPartner: boolean | null
    promoMessage: string | null
    imageMessage: string | null
    cancellationPolicy: string | null
    accommodationTypeId: string | null
    destinationId: string | null
    hotelGroupId: string | null
    latitude: number | null
    longitude: number | null
    detailsId: string | null
  }

  export type HotelCardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    idCity: string | null
    order: number | null
    shortDescription: string | null
    starRating: number | null
    overallRating: number | null
    ratingAdjective: string | null
    reviewCount: number | null
    basePricePerNight: number | null
    regularPrice: number | null
    currency: string | null
    isPartner: boolean | null
    promoMessage: string | null
    imageMessage: string | null
    cancellationPolicy: string | null
    accommodationTypeId: string | null
    destinationId: string | null
    hotelGroupId: string | null
    latitude: number | null
    longitude: number | null
    detailsId: string | null
  }

  export type HotelCardCountAggregateOutputType = {
    id: number
    name: number
    idCity: number
    order: number
    shortDescription: number
    starRating: number
    overallRating: number
    ratingAdjective: number
    reviewCount: number
    basePricePerNight: number
    regularPrice: number
    currency: number
    isPartner: number
    promoMessage: number
    imageMessage: number
    cancellationPolicy: number
    accommodationTypeId: number
    destinationId: number
    hotelGroupId: number
    latitude: number
    longitude: number
    detailsId: number
    _all: number
  }


  export type HotelCardAvgAggregateInputType = {
    order?: true
    starRating?: true
    overallRating?: true
    reviewCount?: true
    basePricePerNight?: true
    regularPrice?: true
    latitude?: true
    longitude?: true
  }

  export type HotelCardSumAggregateInputType = {
    order?: true
    starRating?: true
    overallRating?: true
    reviewCount?: true
    basePricePerNight?: true
    regularPrice?: true
    latitude?: true
    longitude?: true
  }

  export type HotelCardMinAggregateInputType = {
    id?: true
    name?: true
    idCity?: true
    order?: true
    shortDescription?: true
    starRating?: true
    overallRating?: true
    ratingAdjective?: true
    reviewCount?: true
    basePricePerNight?: true
    regularPrice?: true
    currency?: true
    isPartner?: true
    promoMessage?: true
    imageMessage?: true
    cancellationPolicy?: true
    accommodationTypeId?: true
    destinationId?: true
    hotelGroupId?: true
    latitude?: true
    longitude?: true
    detailsId?: true
  }

  export type HotelCardMaxAggregateInputType = {
    id?: true
    name?: true
    idCity?: true
    order?: true
    shortDescription?: true
    starRating?: true
    overallRating?: true
    ratingAdjective?: true
    reviewCount?: true
    basePricePerNight?: true
    regularPrice?: true
    currency?: true
    isPartner?: true
    promoMessage?: true
    imageMessage?: true
    cancellationPolicy?: true
    accommodationTypeId?: true
    destinationId?: true
    hotelGroupId?: true
    latitude?: true
    longitude?: true
    detailsId?: true
  }

  export type HotelCardCountAggregateInputType = {
    id?: true
    name?: true
    idCity?: true
    order?: true
    shortDescription?: true
    starRating?: true
    overallRating?: true
    ratingAdjective?: true
    reviewCount?: true
    basePricePerNight?: true
    regularPrice?: true
    currency?: true
    isPartner?: true
    promoMessage?: true
    imageMessage?: true
    cancellationPolicy?: true
    accommodationTypeId?: true
    destinationId?: true
    hotelGroupId?: true
    latitude?: true
    longitude?: true
    detailsId?: true
    _all?: true
  }

  export type HotelCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCard to aggregate.
     */
    where?: HotelCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCards to fetch.
     */
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCards
    **/
    _count?: true | HotelCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCardMaxAggregateInputType
  }

  export type GetHotelCardAggregateType<T extends HotelCardAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCard[P]>
      : GetScalarType<T[P], AggregateHotelCard[P]>
  }




  export type HotelCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithAggregationInput | HotelCardOrderByWithAggregationInput[]
    by: HotelCardScalarFieldEnum[] | HotelCardScalarFieldEnum
    having?: HotelCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCardCountAggregateInputType | true
    _avg?: HotelCardAvgAggregateInputType
    _sum?: HotelCardSumAggregateInputType
    _min?: HotelCardMinAggregateInputType
    _max?: HotelCardMaxAggregateInputType
  }

  export type HotelCardGroupByOutputType = {
    id: string
    name: string
    idCity: string
    order: number
    shortDescription: string | null
    starRating: number
    overallRating: number | null
    ratingAdjective: string | null
    reviewCount: number
    basePricePerNight: number
    regularPrice: number | null
    currency: string
    isPartner: boolean
    promoMessage: string | null
    imageMessage: string | null
    cancellationPolicy: string | null
    accommodationTypeId: string | null
    destinationId: string | null
    hotelGroupId: string | null
    latitude: number | null
    longitude: number | null
    detailsId: string | null
    _count: HotelCardCountAggregateOutputType | null
    _avg: HotelCardAvgAggregateOutputType | null
    _sum: HotelCardSumAggregateOutputType | null
    _min: HotelCardMinAggregateOutputType | null
    _max: HotelCardMaxAggregateOutputType | null
  }

  type GetHotelCardGroupByPayload<T extends HotelCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCardGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCardGroupByOutputType[P]>
        }
      >
    >


  export type HotelCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    idCity?: boolean
    order?: boolean
    shortDescription?: boolean
    starRating?: boolean
    overallRating?: boolean
    ratingAdjective?: boolean
    reviewCount?: boolean
    basePricePerNight?: boolean
    regularPrice?: boolean
    currency?: boolean
    isPartner?: boolean
    promoMessage?: boolean
    imageMessage?: boolean
    cancellationPolicy?: boolean
    accommodationTypeId?: boolean
    destinationId?: boolean
    hotelGroupId?: boolean
    latitude?: boolean
    longitude?: boolean
    detailsId?: boolean
    parking?: boolean | HotelCard$parkingArgs<ExtArgs>
    images?: boolean | HotelCard$imagesArgs<ExtArgs>
    HotelAmenity?: boolean | HotelCard$HotelAmenityArgs<ExtArgs>
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
    HotelCardToHotelHighlight?: boolean | HotelCard$HotelCardToHotelHighlightArgs<ExtArgs>
    HotelCardToLabel?: boolean | HotelCard$HotelCardToLabelArgs<ExtArgs>
    HotelCardToAccessibilityOption?: boolean | HotelCard$HotelCardToAccessibilityOptionArgs<ExtArgs>
    HotelCardToHotelAmenity?: boolean | HotelCard$HotelCardToHotelAmenityArgs<ExtArgs>
    _count?: boolean | HotelCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCard"]>

  export type HotelCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    idCity?: boolean
    order?: boolean
    shortDescription?: boolean
    starRating?: boolean
    overallRating?: boolean
    ratingAdjective?: boolean
    reviewCount?: boolean
    basePricePerNight?: boolean
    regularPrice?: boolean
    currency?: boolean
    isPartner?: boolean
    promoMessage?: boolean
    imageMessage?: boolean
    cancellationPolicy?: boolean
    accommodationTypeId?: boolean
    destinationId?: boolean
    hotelGroupId?: boolean
    latitude?: boolean
    longitude?: boolean
    detailsId?: boolean
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCard"]>

  export type HotelCardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    idCity?: boolean
    order?: boolean
    shortDescription?: boolean
    starRating?: boolean
    overallRating?: boolean
    ratingAdjective?: boolean
    reviewCount?: boolean
    basePricePerNight?: boolean
    regularPrice?: boolean
    currency?: boolean
    isPartner?: boolean
    promoMessage?: boolean
    imageMessage?: boolean
    cancellationPolicy?: boolean
    accommodationTypeId?: boolean
    destinationId?: boolean
    hotelGroupId?: boolean
    latitude?: boolean
    longitude?: boolean
    detailsId?: boolean
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCard"]>

  export type HotelCardSelectScalar = {
    id?: boolean
    name?: boolean
    idCity?: boolean
    order?: boolean
    shortDescription?: boolean
    starRating?: boolean
    overallRating?: boolean
    ratingAdjective?: boolean
    reviewCount?: boolean
    basePricePerNight?: boolean
    regularPrice?: boolean
    currency?: boolean
    isPartner?: boolean
    promoMessage?: boolean
    imageMessage?: boolean
    cancellationPolicy?: boolean
    accommodationTypeId?: boolean
    destinationId?: boolean
    hotelGroupId?: boolean
    latitude?: boolean
    longitude?: boolean
    detailsId?: boolean
  }

  export type HotelCardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "idCity" | "order" | "shortDescription" | "starRating" | "overallRating" | "ratingAdjective" | "reviewCount" | "basePricePerNight" | "regularPrice" | "currency" | "isPartner" | "promoMessage" | "imageMessage" | "cancellationPolicy" | "accommodationTypeId" | "destinationId" | "hotelGroupId" | "latitude" | "longitude" | "detailsId", ExtArgs["result"]["hotelCard"]>
  export type HotelCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parking?: boolean | HotelCard$parkingArgs<ExtArgs>
    images?: boolean | HotelCard$imagesArgs<ExtArgs>
    HotelAmenity?: boolean | HotelCard$HotelAmenityArgs<ExtArgs>
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
    HotelCardToHotelHighlight?: boolean | HotelCard$HotelCardToHotelHighlightArgs<ExtArgs>
    HotelCardToLabel?: boolean | HotelCard$HotelCardToLabelArgs<ExtArgs>
    HotelCardToAccessibilityOption?: boolean | HotelCard$HotelCardToAccessibilityOptionArgs<ExtArgs>
    HotelCardToHotelAmenity?: boolean | HotelCard$HotelCardToHotelAmenityArgs<ExtArgs>
    _count?: boolean | HotelCardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
  }
  export type HotelCardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | HotelCard$detailsArgs<ExtArgs>
    accommodationType?: boolean | HotelCard$accommodationTypeArgs<ExtArgs>
    destination?: boolean | HotelCard$destinationArgs<ExtArgs>
    hotelGroup?: boolean | HotelCard$hotelGroupArgs<ExtArgs>
  }

  export type $HotelCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCard"
    objects: {
      parking: Prisma.$HotelParkingPayload<ExtArgs>[]
      images: Prisma.$HotelImagePayload<ExtArgs>[]
      HotelAmenity: Prisma.$HotelAmenityPayload<ExtArgs>[]
      details: Prisma.$HotelDetailsPayload<ExtArgs> | null
      accommodationType: Prisma.$AccommodationTypePayload<ExtArgs> | null
      destination: Prisma.$DestinationPayload<ExtArgs> | null
      hotelGroup: Prisma.$HotelGroupPayload<ExtArgs> | null
      HotelCardToHotelHighlight: Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>[]
      HotelCardToLabel: Prisma.$HotelCardToLabelPayload<ExtArgs>[]
      HotelCardToAccessibilityOption: Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>[]
      HotelCardToHotelAmenity: Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      idCity: string
      order: number
      shortDescription: string | null
      starRating: number
      overallRating: number | null
      ratingAdjective: string | null
      reviewCount: number
      basePricePerNight: number
      regularPrice: number | null
      currency: string
      isPartner: boolean
      promoMessage: string | null
      imageMessage: string | null
      cancellationPolicy: string | null
      accommodationTypeId: string | null
      destinationId: string | null
      hotelGroupId: string | null
      latitude: number | null
      longitude: number | null
      detailsId: string | null
    }, ExtArgs["result"]["hotelCard"]>
    composites: {}
  }

  type HotelCardGetPayload<S extends boolean | null | undefined | HotelCardDefaultArgs> = $Result.GetResult<Prisma.$HotelCardPayload, S>

  type HotelCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelCardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCardCountAggregateInputType | true
    }

  export interface HotelCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCard'], meta: { name: 'HotelCard' } }
    /**
     * Find zero or one HotelCard that matches the filter.
     * @param {HotelCardFindUniqueArgs} args - Arguments to find a HotelCard
     * @example
     * // Get one HotelCard
     * const hotelCard = await prisma.hotelCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCardFindUniqueArgs>(args: SelectSubset<T, HotelCardFindUniqueArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelCard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelCardFindUniqueOrThrowArgs} args - Arguments to find a HotelCard
     * @example
     * // Get one HotelCard
     * const hotelCard = await prisma.hotelCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCardFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardFindFirstArgs} args - Arguments to find a HotelCard
     * @example
     * // Get one HotelCard
     * const hotelCard = await prisma.hotelCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCardFindFirstArgs>(args?: SelectSubset<T, HotelCardFindFirstArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardFindFirstOrThrowArgs} args - Arguments to find a HotelCard
     * @example
     * // Get one HotelCard
     * const hotelCard = await prisma.hotelCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCardFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCards
     * const hotelCards = await prisma.hotelCard.findMany()
     * 
     * // Get first 10 HotelCards
     * const hotelCards = await prisma.hotelCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelCardWithIdOnly = await prisma.hotelCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelCardFindManyArgs>(args?: SelectSubset<T, HotelCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelCard.
     * @param {HotelCardCreateArgs} args - Arguments to create a HotelCard.
     * @example
     * // Create one HotelCard
     * const HotelCard = await prisma.hotelCard.create({
     *   data: {
     *     // ... data to create a HotelCard
     *   }
     * })
     * 
     */
    create<T extends HotelCardCreateArgs>(args: SelectSubset<T, HotelCardCreateArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelCards.
     * @param {HotelCardCreateManyArgs} args - Arguments to create many HotelCards.
     * @example
     * // Create many HotelCards
     * const hotelCard = await prisma.hotelCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCardCreateManyArgs>(args?: SelectSubset<T, HotelCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCards and returns the data saved in the database.
     * @param {HotelCardCreateManyAndReturnArgs} args - Arguments to create many HotelCards.
     * @example
     * // Create many HotelCards
     * const hotelCard = await prisma.hotelCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCards and only return the `id`
     * const hotelCardWithIdOnly = await prisma.hotelCard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCardCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelCard.
     * @param {HotelCardDeleteArgs} args - Arguments to delete one HotelCard.
     * @example
     * // Delete one HotelCard
     * const HotelCard = await prisma.hotelCard.delete({
     *   where: {
     *     // ... filter to delete one HotelCard
     *   }
     * })
     * 
     */
    delete<T extends HotelCardDeleteArgs>(args: SelectSubset<T, HotelCardDeleteArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelCard.
     * @param {HotelCardUpdateArgs} args - Arguments to update one HotelCard.
     * @example
     * // Update one HotelCard
     * const hotelCard = await prisma.hotelCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCardUpdateArgs>(args: SelectSubset<T, HotelCardUpdateArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelCards.
     * @param {HotelCardDeleteManyArgs} args - Arguments to filter HotelCards to delete.
     * @example
     * // Delete a few HotelCards
     * const { count } = await prisma.hotelCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCardDeleteManyArgs>(args?: SelectSubset<T, HotelCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCards
     * const hotelCard = await prisma.hotelCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCardUpdateManyArgs>(args: SelectSubset<T, HotelCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCards and returns the data updated in the database.
     * @param {HotelCardUpdateManyAndReturnArgs} args - Arguments to update many HotelCards.
     * @example
     * // Update many HotelCards
     * const hotelCard = await prisma.hotelCard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelCards and only return the `id`
     * const hotelCardWithIdOnly = await prisma.hotelCard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelCardUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelCardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelCard.
     * @param {HotelCardUpsertArgs} args - Arguments to update or create a HotelCard.
     * @example
     * // Update or create a HotelCard
     * const hotelCard = await prisma.hotelCard.upsert({
     *   create: {
     *     // ... data to create a HotelCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCard we want to update
     *   }
     * })
     */
    upsert<T extends HotelCardUpsertArgs>(args: SelectSubset<T, HotelCardUpsertArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardCountArgs} args - Arguments to filter HotelCards to count.
     * @example
     * // Count the number of HotelCards
     * const count = await prisma.hotelCard.count({
     *   where: {
     *     // ... the filter for the HotelCards we want to count
     *   }
     * })
    **/
    count<T extends HotelCardCountArgs>(
      args?: Subset<T, HotelCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCardAggregateArgs>(args: Subset<T, HotelCardAggregateArgs>): Prisma.PrismaPromise<GetHotelCardAggregateType<T>>

    /**
     * Group by HotelCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCardGroupByArgs['orderBy'] }
        : { orderBy?: HotelCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCard model
   */
  readonly fields: HotelCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parking<T extends HotelCard$parkingArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$parkingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelParkingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends HotelCard$imagesArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelAmenity<T extends HotelCard$HotelAmenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$HotelAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    details<T extends HotelCard$detailsArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$detailsArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accommodationType<T extends HotelCard$accommodationTypeArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$accommodationTypeArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    destination<T extends HotelCard$destinationArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$destinationArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotelGroup<T extends HotelCard$hotelGroupArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$hotelGroupArgs<ExtArgs>>): Prisma__HotelGroupClient<$Result.GetResult<Prisma.$HotelGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    HotelCardToHotelHighlight<T extends HotelCard$HotelCardToHotelHighlightArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$HotelCardToHotelHighlightArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelCardToLabel<T extends HotelCard$HotelCardToLabelArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$HotelCardToLabelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelCardToAccessibilityOption<T extends HotelCard$HotelCardToAccessibilityOptionArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$HotelCardToAccessibilityOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelCardToHotelAmenity<T extends HotelCard$HotelCardToHotelAmenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelCard$HotelCardToHotelAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCard model
   */
  interface HotelCardFieldRefs {
    readonly id: FieldRef<"HotelCard", 'String'>
    readonly name: FieldRef<"HotelCard", 'String'>
    readonly idCity: FieldRef<"HotelCard", 'String'>
    readonly order: FieldRef<"HotelCard", 'Int'>
    readonly shortDescription: FieldRef<"HotelCard", 'String'>
    readonly starRating: FieldRef<"HotelCard", 'Int'>
    readonly overallRating: FieldRef<"HotelCard", 'Float'>
    readonly ratingAdjective: FieldRef<"HotelCard", 'String'>
    readonly reviewCount: FieldRef<"HotelCard", 'Int'>
    readonly basePricePerNight: FieldRef<"HotelCard", 'Float'>
    readonly regularPrice: FieldRef<"HotelCard", 'Float'>
    readonly currency: FieldRef<"HotelCard", 'String'>
    readonly isPartner: FieldRef<"HotelCard", 'Boolean'>
    readonly promoMessage: FieldRef<"HotelCard", 'String'>
    readonly imageMessage: FieldRef<"HotelCard", 'String'>
    readonly cancellationPolicy: FieldRef<"HotelCard", 'String'>
    readonly accommodationTypeId: FieldRef<"HotelCard", 'String'>
    readonly destinationId: FieldRef<"HotelCard", 'String'>
    readonly hotelGroupId: FieldRef<"HotelCard", 'String'>
    readonly latitude: FieldRef<"HotelCard", 'Float'>
    readonly longitude: FieldRef<"HotelCard", 'Float'>
    readonly detailsId: FieldRef<"HotelCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotelCard findUnique
   */
  export type HotelCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter, which HotelCard to fetch.
     */
    where: HotelCardWhereUniqueInput
  }

  /**
   * HotelCard findUniqueOrThrow
   */
  export type HotelCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter, which HotelCard to fetch.
     */
    where: HotelCardWhereUniqueInput
  }

  /**
   * HotelCard findFirst
   */
  export type HotelCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter, which HotelCard to fetch.
     */
    where?: HotelCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCards to fetch.
     */
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCards.
     */
    cursor?: HotelCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCards.
     */
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelCard findFirstOrThrow
   */
  export type HotelCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter, which HotelCard to fetch.
     */
    where?: HotelCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCards to fetch.
     */
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCards.
     */
    cursor?: HotelCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCards.
     */
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelCard findMany
   */
  export type HotelCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter, which HotelCards to fetch.
     */
    where?: HotelCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCards to fetch.
     */
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCards.
     */
    cursor?: HotelCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCards.
     */
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelCard create
   */
  export type HotelCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCard.
     */
    data: XOR<HotelCardCreateInput, HotelCardUncheckedCreateInput>
  }

  /**
   * HotelCard createMany
   */
  export type HotelCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCards.
     */
    data: HotelCardCreateManyInput | HotelCardCreateManyInput[]
  }

  /**
   * HotelCard createManyAndReturn
   */
  export type HotelCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * The data used to create many HotelCards.
     */
    data: HotelCardCreateManyInput | HotelCardCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCard update
   */
  export type HotelCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCard.
     */
    data: XOR<HotelCardUpdateInput, HotelCardUncheckedUpdateInput>
    /**
     * Choose, which HotelCard to update.
     */
    where: HotelCardWhereUniqueInput
  }

  /**
   * HotelCard updateMany
   */
  export type HotelCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCards.
     */
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyInput>
    /**
     * Filter which HotelCards to update
     */
    where?: HotelCardWhereInput
    /**
     * Limit how many HotelCards to update.
     */
    limit?: number
  }

  /**
   * HotelCard updateManyAndReturn
   */
  export type HotelCardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * The data used to update HotelCards.
     */
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyInput>
    /**
     * Filter which HotelCards to update
     */
    where?: HotelCardWhereInput
    /**
     * Limit how many HotelCards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCard upsert
   */
  export type HotelCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCard to update in case it exists.
     */
    where: HotelCardWhereUniqueInput
    /**
     * In case the HotelCard found by the `where` argument doesn't exist, create a new HotelCard with this data.
     */
    create: XOR<HotelCardCreateInput, HotelCardUncheckedCreateInput>
    /**
     * In case the HotelCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCardUpdateInput, HotelCardUncheckedUpdateInput>
  }

  /**
   * HotelCard delete
   */
  export type HotelCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    /**
     * Filter which HotelCard to delete.
     */
    where: HotelCardWhereUniqueInput
  }

  /**
   * HotelCard deleteMany
   */
  export type HotelCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCards to delete
     */
    where?: HotelCardWhereInput
    /**
     * Limit how many HotelCards to delete.
     */
    limit?: number
  }

  /**
   * HotelCard.parking
   */
  export type HotelCard$parkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelParking
     */
    select?: HotelParkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelParking
     */
    omit?: HotelParkingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelParkingInclude<ExtArgs> | null
    where?: HotelParkingWhereInput
    orderBy?: HotelParkingOrderByWithRelationInput | HotelParkingOrderByWithRelationInput[]
    cursor?: HotelParkingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelParkingScalarFieldEnum | HotelParkingScalarFieldEnum[]
  }

  /**
   * HotelCard.images
   */
  export type HotelCard$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelImage
     */
    select?: HotelImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelImage
     */
    omit?: HotelImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelImageInclude<ExtArgs> | null
    where?: HotelImageWhereInput
    orderBy?: HotelImageOrderByWithRelationInput | HotelImageOrderByWithRelationInput[]
    cursor?: HotelImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelImageScalarFieldEnum | HotelImageScalarFieldEnum[]
  }

  /**
   * HotelCard.HotelAmenity
   */
  export type HotelCard$HotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    cursor?: HotelAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelCard.details
   */
  export type HotelCard$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    where?: HotelDetailsWhereInput
  }

  /**
   * HotelCard.accommodationType
   */
  export type HotelCard$accommodationTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationType
     */
    omit?: AccommodationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationTypeInclude<ExtArgs> | null
    where?: AccommodationTypeWhereInput
  }

  /**
   * HotelCard.destination
   */
  export type HotelCard$destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
  }

  /**
   * HotelCard.hotelGroup
   */
  export type HotelCard$hotelGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelGroup
     */
    select?: HotelGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelGroup
     */
    omit?: HotelGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelGroupInclude<ExtArgs> | null
    where?: HotelGroupWhereInput
  }

  /**
   * HotelCard.HotelCardToHotelHighlight
   */
  export type HotelCard$HotelCardToHotelHighlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    where?: HotelCardToHotelHighlightWhereInput
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToHotelHighlightScalarFieldEnum | HotelCardToHotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelCard.HotelCardToLabel
   */
  export type HotelCard$HotelCardToLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    where?: HotelCardToLabelWhereInput
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    cursor?: HotelCardToLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToLabelScalarFieldEnum | HotelCardToLabelScalarFieldEnum[]
  }

  /**
   * HotelCard.HotelCardToAccessibilityOption
   */
  export type HotelCard$HotelCardToAccessibilityOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    where?: HotelCardToAccessibilityOptionWhereInput
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToAccessibilityOptionScalarFieldEnum | HotelCardToAccessibilityOptionScalarFieldEnum[]
  }

  /**
   * HotelCard.HotelCardToHotelAmenity
   */
  export type HotelCard$HotelCardToHotelAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    where?: HotelCardToHotelAmenityWhereInput
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardToHotelAmenityScalarFieldEnum | HotelCardToHotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelCard without action
   */
  export type HotelCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
  }


  /**
   * Model HotelDetails
   */

  export type AggregateHotelDetails = {
    _count: HotelDetailsCountAggregateOutputType | null
    _avg: HotelDetailsAvgAggregateOutputType | null
    _sum: HotelDetailsSumAggregateOutputType | null
    _min: HotelDetailsMinAggregateOutputType | null
    _max: HotelDetailsMaxAggregateOutputType | null
  }

  export type HotelDetailsAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelDetailsSumAggregateOutputType = {
    order: number | null
  }

  export type HotelDetailsMinAggregateOutputType = {
    id: string | null
    idHotelCard: string | null
    description: string | null
    addressId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelDetailsMaxAggregateOutputType = {
    id: string | null
    idHotelCard: string | null
    description: string | null
    addressId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelDetailsCountAggregateOutputType = {
    id: number
    idHotelCard: number
    description: number
    addressId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelDetailsAvgAggregateInputType = {
    order?: true
  }

  export type HotelDetailsSumAggregateInputType = {
    order?: true
  }

  export type HotelDetailsMinAggregateInputType = {
    id?: true
    idHotelCard?: true
    description?: true
    addressId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelDetailsMaxAggregateInputType = {
    id?: true
    idHotelCard?: true
    description?: true
    addressId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelDetailsCountAggregateInputType = {
    id?: true
    idHotelCard?: true
    description?: true
    addressId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelDetails to aggregate.
     */
    where?: HotelDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetails to fetch.
     */
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelDetails
    **/
    _count?: true | HotelDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelDetailsMaxAggregateInputType
  }

  export type GetHotelDetailsAggregateType<T extends HotelDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelDetails[P]>
      : GetScalarType<T[P], AggregateHotelDetails[P]>
  }




  export type HotelDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsWhereInput
    orderBy?: HotelDetailsOrderByWithAggregationInput | HotelDetailsOrderByWithAggregationInput[]
    by: HotelDetailsScalarFieldEnum[] | HotelDetailsScalarFieldEnum
    having?: HotelDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelDetailsCountAggregateInputType | true
    _avg?: HotelDetailsAvgAggregateInputType
    _sum?: HotelDetailsSumAggregateInputType
    _min?: HotelDetailsMinAggregateInputType
    _max?: HotelDetailsMaxAggregateInputType
  }

  export type HotelDetailsGroupByOutputType = {
    id: string
    idHotelCard: string
    description: string | null
    addressId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelDetailsCountAggregateOutputType | null
    _avg: HotelDetailsAvgAggregateOutputType | null
    _sum: HotelDetailsSumAggregateOutputType | null
    _min: HotelDetailsMinAggregateOutputType | null
    _max: HotelDetailsMaxAggregateOutputType | null
  }

  type GetHotelDetailsGroupByPayload<T extends HotelDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], HotelDetailsGroupByOutputType[P]>
        }
      >
    >


  export type HotelDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idHotelCard?: boolean
    description?: boolean
    addressId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    RoomAmenity?: boolean | HotelDetails$RoomAmenityArgs<ExtArgs>
    Label?: boolean | HotelDetails$LabelArgs<ExtArgs>
    HotelCard?: boolean | HotelDetails$HotelCardArgs<ExtArgs>
    HotelDetailsToRoomAmenity?: boolean | HotelDetails$HotelDetailsToRoomAmenityArgs<ExtArgs>
    _count?: boolean | HotelDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetails"]>

  export type HotelDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idHotelCard?: boolean
    description?: boolean
    addressId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetails"]>

  export type HotelDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idHotelCard?: boolean
    description?: boolean
    addressId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetails"]>

  export type HotelDetailsSelectScalar = {
    id?: boolean
    idHotelCard?: boolean
    description?: boolean
    addressId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idHotelCard" | "description" | "addressId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelDetails"]>
  export type HotelDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    RoomAmenity?: boolean | HotelDetails$RoomAmenityArgs<ExtArgs>
    Label?: boolean | HotelDetails$LabelArgs<ExtArgs>
    HotelCard?: boolean | HotelDetails$HotelCardArgs<ExtArgs>
    HotelDetailsToRoomAmenity?: boolean | HotelDetails$HotelDetailsToRoomAmenityArgs<ExtArgs>
    _count?: boolean | HotelDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type HotelDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }

  export type $HotelDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelDetails"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
      RoomAmenity: Prisma.$RoomAmenityPayload<ExtArgs>[]
      Label: Prisma.$LabelPayload<ExtArgs>[]
      HotelCard: Prisma.$HotelCardPayload<ExtArgs>[]
      HotelDetailsToRoomAmenity: Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idHotelCard: string
      description: string | null
      addressId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelDetails"]>
    composites: {}
  }

  type HotelDetailsGetPayload<S extends boolean | null | undefined | HotelDetailsDefaultArgs> = $Result.GetResult<Prisma.$HotelDetailsPayload, S>

  type HotelDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelDetailsCountAggregateInputType | true
    }

  export interface HotelDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelDetails'], meta: { name: 'HotelDetails' } }
    /**
     * Find zero or one HotelDetails that matches the filter.
     * @param {HotelDetailsFindUniqueArgs} args - Arguments to find a HotelDetails
     * @example
     * // Get one HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelDetailsFindUniqueArgs>(args: SelectSubset<T, HotelDetailsFindUniqueArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelDetailsFindUniqueOrThrowArgs} args - Arguments to find a HotelDetails
     * @example
     * // Get one HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsFindFirstArgs} args - Arguments to find a HotelDetails
     * @example
     * // Get one HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelDetailsFindFirstArgs>(args?: SelectSubset<T, HotelDetailsFindFirstArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsFindFirstOrThrowArgs} args - Arguments to find a HotelDetails
     * @example
     * // Get one HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findMany()
     * 
     * // Get first 10 HotelDetails
     * const hotelDetails = await prisma.hotelDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelDetailsWithIdOnly = await prisma.hotelDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelDetailsFindManyArgs>(args?: SelectSubset<T, HotelDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelDetails.
     * @param {HotelDetailsCreateArgs} args - Arguments to create a HotelDetails.
     * @example
     * // Create one HotelDetails
     * const HotelDetails = await prisma.hotelDetails.create({
     *   data: {
     *     // ... data to create a HotelDetails
     *   }
     * })
     * 
     */
    create<T extends HotelDetailsCreateArgs>(args: SelectSubset<T, HotelDetailsCreateArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelDetails.
     * @param {HotelDetailsCreateManyArgs} args - Arguments to create many HotelDetails.
     * @example
     * // Create many HotelDetails
     * const hotelDetails = await prisma.hotelDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelDetailsCreateManyArgs>(args?: SelectSubset<T, HotelDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelDetails and returns the data saved in the database.
     * @param {HotelDetailsCreateManyAndReturnArgs} args - Arguments to create many HotelDetails.
     * @example
     * // Create many HotelDetails
     * const hotelDetails = await prisma.hotelDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelDetails and only return the `id`
     * const hotelDetailsWithIdOnly = await prisma.hotelDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelDetails.
     * @param {HotelDetailsDeleteArgs} args - Arguments to delete one HotelDetails.
     * @example
     * // Delete one HotelDetails
     * const HotelDetails = await prisma.hotelDetails.delete({
     *   where: {
     *     // ... filter to delete one HotelDetails
     *   }
     * })
     * 
     */
    delete<T extends HotelDetailsDeleteArgs>(args: SelectSubset<T, HotelDetailsDeleteArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelDetails.
     * @param {HotelDetailsUpdateArgs} args - Arguments to update one HotelDetails.
     * @example
     * // Update one HotelDetails
     * const hotelDetails = await prisma.hotelDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelDetailsUpdateArgs>(args: SelectSubset<T, HotelDetailsUpdateArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelDetails.
     * @param {HotelDetailsDeleteManyArgs} args - Arguments to filter HotelDetails to delete.
     * @example
     * // Delete a few HotelDetails
     * const { count } = await prisma.hotelDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDetailsDeleteManyArgs>(args?: SelectSubset<T, HotelDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelDetails
     * const hotelDetails = await prisma.hotelDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelDetailsUpdateManyArgs>(args: SelectSubset<T, HotelDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelDetails and returns the data updated in the database.
     * @param {HotelDetailsUpdateManyAndReturnArgs} args - Arguments to update many HotelDetails.
     * @example
     * // Update many HotelDetails
     * const hotelDetails = await prisma.hotelDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelDetails and only return the `id`
     * const hotelDetailsWithIdOnly = await prisma.hotelDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelDetails.
     * @param {HotelDetailsUpsertArgs} args - Arguments to update or create a HotelDetails.
     * @example
     * // Update or create a HotelDetails
     * const hotelDetails = await prisma.hotelDetails.upsert({
     *   create: {
     *     // ... data to create a HotelDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelDetails we want to update
     *   }
     * })
     */
    upsert<T extends HotelDetailsUpsertArgs>(args: SelectSubset<T, HotelDetailsUpsertArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsCountArgs} args - Arguments to filter HotelDetails to count.
     * @example
     * // Count the number of HotelDetails
     * const count = await prisma.hotelDetails.count({
     *   where: {
     *     // ... the filter for the HotelDetails we want to count
     *   }
     * })
    **/
    count<T extends HotelDetailsCountArgs>(
      args?: Subset<T, HotelDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelDetailsAggregateArgs>(args: Subset<T, HotelDetailsAggregateArgs>): Prisma.PrismaPromise<GetHotelDetailsAggregateType<T>>

    /**
     * Group by HotelDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelDetailsGroupByArgs['orderBy'] }
        : { orderBy?: HotelDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelDetails model
   */
  readonly fields: HotelDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RoomAmenity<T extends HotelDetails$RoomAmenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelDetails$RoomAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Label<T extends HotelDetails$LabelArgs<ExtArgs> = {}>(args?: Subset<T, HotelDetails$LabelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelCard<T extends HotelDetails$HotelCardArgs<ExtArgs> = {}>(args?: Subset<T, HotelDetails$HotelCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HotelDetailsToRoomAmenity<T extends HotelDetails$HotelDetailsToRoomAmenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelDetails$HotelDetailsToRoomAmenityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelDetails model
   */
  interface HotelDetailsFieldRefs {
    readonly id: FieldRef<"HotelDetails", 'String'>
    readonly idHotelCard: FieldRef<"HotelDetails", 'String'>
    readonly description: FieldRef<"HotelDetails", 'String'>
    readonly addressId: FieldRef<"HotelDetails", 'String'>
    readonly order: FieldRef<"HotelDetails", 'Int'>
    readonly createdAt: FieldRef<"HotelDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelDetails findUnique
   */
  export type HotelDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetails to fetch.
     */
    where: HotelDetailsWhereUniqueInput
  }

  /**
   * HotelDetails findUniqueOrThrow
   */
  export type HotelDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetails to fetch.
     */
    where: HotelDetailsWhereUniqueInput
  }

  /**
   * HotelDetails findFirst
   */
  export type HotelDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetails to fetch.
     */
    where?: HotelDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetails to fetch.
     */
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelDetails.
     */
    cursor?: HotelDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelDetails.
     */
    distinct?: HotelDetailsScalarFieldEnum | HotelDetailsScalarFieldEnum[]
  }

  /**
   * HotelDetails findFirstOrThrow
   */
  export type HotelDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetails to fetch.
     */
    where?: HotelDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetails to fetch.
     */
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelDetails.
     */
    cursor?: HotelDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelDetails.
     */
    distinct?: HotelDetailsScalarFieldEnum | HotelDetailsScalarFieldEnum[]
  }

  /**
   * HotelDetails findMany
   */
  export type HotelDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetails to fetch.
     */
    where?: HotelDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetails to fetch.
     */
    orderBy?: HotelDetailsOrderByWithRelationInput | HotelDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelDetails.
     */
    cursor?: HotelDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetails.
     */
    skip?: number
    distinct?: HotelDetailsScalarFieldEnum | HotelDetailsScalarFieldEnum[]
  }

  /**
   * HotelDetails create
   */
  export type HotelDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelDetails.
     */
    data: XOR<HotelDetailsCreateInput, HotelDetailsUncheckedCreateInput>
  }

  /**
   * HotelDetails createMany
   */
  export type HotelDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelDetails.
     */
    data: HotelDetailsCreateManyInput | HotelDetailsCreateManyInput[]
  }

  /**
   * HotelDetails createManyAndReturn
   */
  export type HotelDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many HotelDetails.
     */
    data: HotelDetailsCreateManyInput | HotelDetailsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelDetails update
   */
  export type HotelDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelDetails.
     */
    data: XOR<HotelDetailsUpdateInput, HotelDetailsUncheckedUpdateInput>
    /**
     * Choose, which HotelDetails to update.
     */
    where: HotelDetailsWhereUniqueInput
  }

  /**
   * HotelDetails updateMany
   */
  export type HotelDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelDetails.
     */
    data: XOR<HotelDetailsUpdateManyMutationInput, HotelDetailsUncheckedUpdateManyInput>
    /**
     * Filter which HotelDetails to update
     */
    where?: HotelDetailsWhereInput
    /**
     * Limit how many HotelDetails to update.
     */
    limit?: number
  }

  /**
   * HotelDetails updateManyAndReturn
   */
  export type HotelDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * The data used to update HotelDetails.
     */
    data: XOR<HotelDetailsUpdateManyMutationInput, HotelDetailsUncheckedUpdateManyInput>
    /**
     * Filter which HotelDetails to update
     */
    where?: HotelDetailsWhereInput
    /**
     * Limit how many HotelDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelDetails upsert
   */
  export type HotelDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelDetails to update in case it exists.
     */
    where: HotelDetailsWhereUniqueInput
    /**
     * In case the HotelDetails found by the `where` argument doesn't exist, create a new HotelDetails with this data.
     */
    create: XOR<HotelDetailsCreateInput, HotelDetailsUncheckedCreateInput>
    /**
     * In case the HotelDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelDetailsUpdateInput, HotelDetailsUncheckedUpdateInput>
  }

  /**
   * HotelDetails delete
   */
  export type HotelDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
    /**
     * Filter which HotelDetails to delete.
     */
    where: HotelDetailsWhereUniqueInput
  }

  /**
   * HotelDetails deleteMany
   */
  export type HotelDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelDetails to delete
     */
    where?: HotelDetailsWhereInput
    /**
     * Limit how many HotelDetails to delete.
     */
    limit?: number
  }

  /**
   * HotelDetails.RoomAmenity
   */
  export type HotelDetails$RoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    cursor?: RoomAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * HotelDetails.Label
   */
  export type HotelDetails$LabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * HotelDetails.HotelCard
   */
  export type HotelDetails$HotelCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCard
     */
    select?: HotelCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCard
     */
    omit?: HotelCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardInclude<ExtArgs> | null
    where?: HotelCardWhereInput
    orderBy?: HotelCardOrderByWithRelationInput | HotelCardOrderByWithRelationInput[]
    cursor?: HotelCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelCardScalarFieldEnum | HotelCardScalarFieldEnum[]
  }

  /**
   * HotelDetails.HotelDetailsToRoomAmenity
   */
  export type HotelDetails$HotelDetailsToRoomAmenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    where?: HotelDetailsToRoomAmenityWhereInput
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelDetailsToRoomAmenityScalarFieldEnum | HotelDetailsToRoomAmenityScalarFieldEnum[]
  }

  /**
   * HotelDetails without action
   */
  export type HotelDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetails
     */
    select?: HotelDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetails
     */
    omit?: HotelDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsInclude<ExtArgs> | null
  }


  /**
   * Model HotelCardToHotelHighlight
   */

  export type AggregateHotelCardToHotelHighlight = {
    _count: HotelCardToHotelHighlightCountAggregateOutputType | null
    _avg: HotelCardToHotelHighlightAvgAggregateOutputType | null
    _sum: HotelCardToHotelHighlightSumAggregateOutputType | null
    _min: HotelCardToHotelHighlightMinAggregateOutputType | null
    _max: HotelCardToHotelHighlightMaxAggregateOutputType | null
  }

  export type HotelCardToHotelHighlightAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToHotelHighlightSumAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToHotelHighlightMinAggregateOutputType = {
    hotelCardId: string | null
    hotelHighlightId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToHotelHighlightMaxAggregateOutputType = {
    hotelCardId: string | null
    hotelHighlightId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToHotelHighlightCountAggregateOutputType = {
    hotelCardId: number
    hotelHighlightId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelCardToHotelHighlightAvgAggregateInputType = {
    order?: true
  }

  export type HotelCardToHotelHighlightSumAggregateInputType = {
    order?: true
  }

  export type HotelCardToHotelHighlightMinAggregateInputType = {
    hotelCardId?: true
    hotelHighlightId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToHotelHighlightMaxAggregateInputType = {
    hotelCardId?: true
    hotelHighlightId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToHotelHighlightCountAggregateInputType = {
    hotelCardId?: true
    hotelHighlightId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelCardToHotelHighlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToHotelHighlight to aggregate.
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelHighlights to fetch.
     */
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCardToHotelHighlights
    **/
    _count?: true | HotelCardToHotelHighlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCardToHotelHighlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCardToHotelHighlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCardToHotelHighlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCardToHotelHighlightMaxAggregateInputType
  }

  export type GetHotelCardToHotelHighlightAggregateType<T extends HotelCardToHotelHighlightAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCardToHotelHighlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCardToHotelHighlight[P]>
      : GetScalarType<T[P], AggregateHotelCardToHotelHighlight[P]>
  }




  export type HotelCardToHotelHighlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelHighlightWhereInput
    orderBy?: HotelCardToHotelHighlightOrderByWithAggregationInput | HotelCardToHotelHighlightOrderByWithAggregationInput[]
    by: HotelCardToHotelHighlightScalarFieldEnum[] | HotelCardToHotelHighlightScalarFieldEnum
    having?: HotelCardToHotelHighlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCardToHotelHighlightCountAggregateInputType | true
    _avg?: HotelCardToHotelHighlightAvgAggregateInputType
    _sum?: HotelCardToHotelHighlightSumAggregateInputType
    _min?: HotelCardToHotelHighlightMinAggregateInputType
    _max?: HotelCardToHotelHighlightMaxAggregateInputType
  }

  export type HotelCardToHotelHighlightGroupByOutputType = {
    hotelCardId: string
    hotelHighlightId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCardToHotelHighlightCountAggregateOutputType | null
    _avg: HotelCardToHotelHighlightAvgAggregateOutputType | null
    _sum: HotelCardToHotelHighlightSumAggregateOutputType | null
    _min: HotelCardToHotelHighlightMinAggregateOutputType | null
    _max: HotelCardToHotelHighlightMaxAggregateOutputType | null
  }

  type GetHotelCardToHotelHighlightGroupByPayload<T extends HotelCardToHotelHighlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCardToHotelHighlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCardToHotelHighlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCardToHotelHighlightGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCardToHotelHighlightGroupByOutputType[P]>
        }
      >
    >


  export type HotelCardToHotelHighlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelHighlightId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelHighlight"]>

  export type HotelCardToHotelHighlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelHighlightId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelHighlight"]>

  export type HotelCardToHotelHighlightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelHighlightId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelHighlight"]>

  export type HotelCardToHotelHighlightSelectScalar = {
    hotelCardId?: boolean
    hotelHighlightId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelCardToHotelHighlightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelCardId" | "hotelHighlightId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelCardToHotelHighlight"]>
  export type HotelCardToHotelHighlightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }
  export type HotelCardToHotelHighlightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }
  export type HotelCardToHotelHighlightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelHighlight?: boolean | HotelHighlightDefaultArgs<ExtArgs>
  }

  export type $HotelCardToHotelHighlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCardToHotelHighlight"
    objects: {
      hotelCard: Prisma.$HotelCardPayload<ExtArgs>
      hotelHighlight: Prisma.$HotelHighlightPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelCardId: string
      hotelHighlightId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelCardToHotelHighlight"]>
    composites: {}
  }

  type HotelCardToHotelHighlightGetPayload<S extends boolean | null | undefined | HotelCardToHotelHighlightDefaultArgs> = $Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload, S>

  type HotelCardToHotelHighlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelCardToHotelHighlightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCardToHotelHighlightCountAggregateInputType | true
    }

  export interface HotelCardToHotelHighlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCardToHotelHighlight'], meta: { name: 'HotelCardToHotelHighlight' } }
    /**
     * Find zero or one HotelCardToHotelHighlight that matches the filter.
     * @param {HotelCardToHotelHighlightFindUniqueArgs} args - Arguments to find a HotelCardToHotelHighlight
     * @example
     * // Get one HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCardToHotelHighlightFindUniqueArgs>(args: SelectSubset<T, HotelCardToHotelHighlightFindUniqueArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelCardToHotelHighlight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelCardToHotelHighlightFindUniqueOrThrowArgs} args - Arguments to find a HotelCardToHotelHighlight
     * @example
     * // Get one HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCardToHotelHighlightFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCardToHotelHighlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToHotelHighlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightFindFirstArgs} args - Arguments to find a HotelCardToHotelHighlight
     * @example
     * // Get one HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCardToHotelHighlightFindFirstArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightFindFirstArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToHotelHighlight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightFindFirstOrThrowArgs} args - Arguments to find a HotelCardToHotelHighlight
     * @example
     * // Get one HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCardToHotelHighlightFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelCardToHotelHighlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCardToHotelHighlights
     * const hotelCardToHotelHighlights = await prisma.hotelCardToHotelHighlight.findMany()
     * 
     * // Get first 10 HotelCardToHotelHighlights
     * const hotelCardToHotelHighlights = await prisma.hotelCardToHotelHighlight.findMany({ take: 10 })
     * 
     * // Only select the `hotelCardId`
     * const hotelCardToHotelHighlightWithHotelCardIdOnly = await prisma.hotelCardToHotelHighlight.findMany({ select: { hotelCardId: true } })
     * 
     */
    findMany<T extends HotelCardToHotelHighlightFindManyArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelCardToHotelHighlight.
     * @param {HotelCardToHotelHighlightCreateArgs} args - Arguments to create a HotelCardToHotelHighlight.
     * @example
     * // Create one HotelCardToHotelHighlight
     * const HotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.create({
     *   data: {
     *     // ... data to create a HotelCardToHotelHighlight
     *   }
     * })
     * 
     */
    create<T extends HotelCardToHotelHighlightCreateArgs>(args: SelectSubset<T, HotelCardToHotelHighlightCreateArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelCardToHotelHighlights.
     * @param {HotelCardToHotelHighlightCreateManyArgs} args - Arguments to create many HotelCardToHotelHighlights.
     * @example
     * // Create many HotelCardToHotelHighlights
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCardToHotelHighlightCreateManyArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCardToHotelHighlights and returns the data saved in the database.
     * @param {HotelCardToHotelHighlightCreateManyAndReturnArgs} args - Arguments to create many HotelCardToHotelHighlights.
     * @example
     * // Create many HotelCardToHotelHighlights
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCardToHotelHighlights and only return the `hotelCardId`
     * const hotelCardToHotelHighlightWithHotelCardIdOnly = await prisma.hotelCardToHotelHighlight.createManyAndReturn({
     *   select: { hotelCardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCardToHotelHighlightCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelCardToHotelHighlight.
     * @param {HotelCardToHotelHighlightDeleteArgs} args - Arguments to delete one HotelCardToHotelHighlight.
     * @example
     * // Delete one HotelCardToHotelHighlight
     * const HotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.delete({
     *   where: {
     *     // ... filter to delete one HotelCardToHotelHighlight
     *   }
     * })
     * 
     */
    delete<T extends HotelCardToHotelHighlightDeleteArgs>(args: SelectSubset<T, HotelCardToHotelHighlightDeleteArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelCardToHotelHighlight.
     * @param {HotelCardToHotelHighlightUpdateArgs} args - Arguments to update one HotelCardToHotelHighlight.
     * @example
     * // Update one HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCardToHotelHighlightUpdateArgs>(args: SelectSubset<T, HotelCardToHotelHighlightUpdateArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelCardToHotelHighlights.
     * @param {HotelCardToHotelHighlightDeleteManyArgs} args - Arguments to filter HotelCardToHotelHighlights to delete.
     * @example
     * // Delete a few HotelCardToHotelHighlights
     * const { count } = await prisma.hotelCardToHotelHighlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCardToHotelHighlightDeleteManyArgs>(args?: SelectSubset<T, HotelCardToHotelHighlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToHotelHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCardToHotelHighlights
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCardToHotelHighlightUpdateManyArgs>(args: SelectSubset<T, HotelCardToHotelHighlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToHotelHighlights and returns the data updated in the database.
     * @param {HotelCardToHotelHighlightUpdateManyAndReturnArgs} args - Arguments to update many HotelCardToHotelHighlights.
     * @example
     * // Update many HotelCardToHotelHighlights
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelCardToHotelHighlights and only return the `hotelCardId`
     * const hotelCardToHotelHighlightWithHotelCardIdOnly = await prisma.hotelCardToHotelHighlight.updateManyAndReturn({
     *   select: { hotelCardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelCardToHotelHighlightUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelCardToHotelHighlightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelCardToHotelHighlight.
     * @param {HotelCardToHotelHighlightUpsertArgs} args - Arguments to update or create a HotelCardToHotelHighlight.
     * @example
     * // Update or create a HotelCardToHotelHighlight
     * const hotelCardToHotelHighlight = await prisma.hotelCardToHotelHighlight.upsert({
     *   create: {
     *     // ... data to create a HotelCardToHotelHighlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCardToHotelHighlight we want to update
     *   }
     * })
     */
    upsert<T extends HotelCardToHotelHighlightUpsertArgs>(args: SelectSubset<T, HotelCardToHotelHighlightUpsertArgs<ExtArgs>>): Prisma__HotelCardToHotelHighlightClient<$Result.GetResult<Prisma.$HotelCardToHotelHighlightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelCardToHotelHighlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightCountArgs} args - Arguments to filter HotelCardToHotelHighlights to count.
     * @example
     * // Count the number of HotelCardToHotelHighlights
     * const count = await prisma.hotelCardToHotelHighlight.count({
     *   where: {
     *     // ... the filter for the HotelCardToHotelHighlights we want to count
     *   }
     * })
    **/
    count<T extends HotelCardToHotelHighlightCountArgs>(
      args?: Subset<T, HotelCardToHotelHighlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCardToHotelHighlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCardToHotelHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCardToHotelHighlightAggregateArgs>(args: Subset<T, HotelCardToHotelHighlightAggregateArgs>): Prisma.PrismaPromise<GetHotelCardToHotelHighlightAggregateType<T>>

    /**
     * Group by HotelCardToHotelHighlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelHighlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCardToHotelHighlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCardToHotelHighlightGroupByArgs['orderBy'] }
        : { orderBy?: HotelCardToHotelHighlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCardToHotelHighlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCardToHotelHighlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCardToHotelHighlight model
   */
  readonly fields: HotelCardToHotelHighlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCardToHotelHighlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCardToHotelHighlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelCard<T extends HotelCardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelCardDefaultArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hotelHighlight<T extends HotelHighlightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelHighlightDefaultArgs<ExtArgs>>): Prisma__HotelHighlightClient<$Result.GetResult<Prisma.$HotelHighlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCardToHotelHighlight model
   */
  interface HotelCardToHotelHighlightFieldRefs {
    readonly hotelCardId: FieldRef<"HotelCardToHotelHighlight", 'String'>
    readonly hotelHighlightId: FieldRef<"HotelCardToHotelHighlight", 'String'>
    readonly order: FieldRef<"HotelCardToHotelHighlight", 'Int'>
    readonly createdAt: FieldRef<"HotelCardToHotelHighlight", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelCardToHotelHighlight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelCardToHotelHighlight findUnique
   */
  export type HotelCardToHotelHighlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelHighlight to fetch.
     */
    where: HotelCardToHotelHighlightWhereUniqueInput
  }

  /**
   * HotelCardToHotelHighlight findUniqueOrThrow
   */
  export type HotelCardToHotelHighlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelHighlight to fetch.
     */
    where: HotelCardToHotelHighlightWhereUniqueInput
  }

  /**
   * HotelCardToHotelHighlight findFirst
   */
  export type HotelCardToHotelHighlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelHighlight to fetch.
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelHighlights to fetch.
     */
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToHotelHighlights.
     */
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToHotelHighlights.
     */
    distinct?: HotelCardToHotelHighlightScalarFieldEnum | HotelCardToHotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelHighlight findFirstOrThrow
   */
  export type HotelCardToHotelHighlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelHighlight to fetch.
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelHighlights to fetch.
     */
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToHotelHighlights.
     */
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelHighlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToHotelHighlights.
     */
    distinct?: HotelCardToHotelHighlightScalarFieldEnum | HotelCardToHotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelHighlight findMany
   */
  export type HotelCardToHotelHighlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelHighlights to fetch.
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelHighlights to fetch.
     */
    orderBy?: HotelCardToHotelHighlightOrderByWithRelationInput | HotelCardToHotelHighlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCardToHotelHighlights.
     */
    cursor?: HotelCardToHotelHighlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelHighlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelHighlights.
     */
    skip?: number
    distinct?: HotelCardToHotelHighlightScalarFieldEnum | HotelCardToHotelHighlightScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelHighlight create
   */
  export type HotelCardToHotelHighlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCardToHotelHighlight.
     */
    data: XOR<HotelCardToHotelHighlightCreateInput, HotelCardToHotelHighlightUncheckedCreateInput>
  }

  /**
   * HotelCardToHotelHighlight createMany
   */
  export type HotelCardToHotelHighlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCardToHotelHighlights.
     */
    data: HotelCardToHotelHighlightCreateManyInput | HotelCardToHotelHighlightCreateManyInput[]
  }

  /**
   * HotelCardToHotelHighlight createManyAndReturn
   */
  export type HotelCardToHotelHighlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * The data used to create many HotelCardToHotelHighlights.
     */
    data: HotelCardToHotelHighlightCreateManyInput | HotelCardToHotelHighlightCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToHotelHighlight update
   */
  export type HotelCardToHotelHighlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCardToHotelHighlight.
     */
    data: XOR<HotelCardToHotelHighlightUpdateInput, HotelCardToHotelHighlightUncheckedUpdateInput>
    /**
     * Choose, which HotelCardToHotelHighlight to update.
     */
    where: HotelCardToHotelHighlightWhereUniqueInput
  }

  /**
   * HotelCardToHotelHighlight updateMany
   */
  export type HotelCardToHotelHighlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCardToHotelHighlights.
     */
    data: XOR<HotelCardToHotelHighlightUpdateManyMutationInput, HotelCardToHotelHighlightUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToHotelHighlights to update
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * Limit how many HotelCardToHotelHighlights to update.
     */
    limit?: number
  }

  /**
   * HotelCardToHotelHighlight updateManyAndReturn
   */
  export type HotelCardToHotelHighlightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * The data used to update HotelCardToHotelHighlights.
     */
    data: XOR<HotelCardToHotelHighlightUpdateManyMutationInput, HotelCardToHotelHighlightUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToHotelHighlights to update
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * Limit how many HotelCardToHotelHighlights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToHotelHighlight upsert
   */
  export type HotelCardToHotelHighlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCardToHotelHighlight to update in case it exists.
     */
    where: HotelCardToHotelHighlightWhereUniqueInput
    /**
     * In case the HotelCardToHotelHighlight found by the `where` argument doesn't exist, create a new HotelCardToHotelHighlight with this data.
     */
    create: XOR<HotelCardToHotelHighlightCreateInput, HotelCardToHotelHighlightUncheckedCreateInput>
    /**
     * In case the HotelCardToHotelHighlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCardToHotelHighlightUpdateInput, HotelCardToHotelHighlightUncheckedUpdateInput>
  }

  /**
   * HotelCardToHotelHighlight delete
   */
  export type HotelCardToHotelHighlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
    /**
     * Filter which HotelCardToHotelHighlight to delete.
     */
    where: HotelCardToHotelHighlightWhereUniqueInput
  }

  /**
   * HotelCardToHotelHighlight deleteMany
   */
  export type HotelCardToHotelHighlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToHotelHighlights to delete
     */
    where?: HotelCardToHotelHighlightWhereInput
    /**
     * Limit how many HotelCardToHotelHighlights to delete.
     */
    limit?: number
  }

  /**
   * HotelCardToHotelHighlight without action
   */
  export type HotelCardToHotelHighlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelHighlight
     */
    select?: HotelCardToHotelHighlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelHighlight
     */
    omit?: HotelCardToHotelHighlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelHighlightInclude<ExtArgs> | null
  }


  /**
   * Model HotelCardToLabel
   */

  export type AggregateHotelCardToLabel = {
    _count: HotelCardToLabelCountAggregateOutputType | null
    _avg: HotelCardToLabelAvgAggregateOutputType | null
    _sum: HotelCardToLabelSumAggregateOutputType | null
    _min: HotelCardToLabelMinAggregateOutputType | null
    _max: HotelCardToLabelMaxAggregateOutputType | null
  }

  export type HotelCardToLabelAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToLabelSumAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToLabelMinAggregateOutputType = {
    hotelCardId: string | null
    labelId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToLabelMaxAggregateOutputType = {
    hotelCardId: string | null
    labelId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToLabelCountAggregateOutputType = {
    hotelCardId: number
    labelId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelCardToLabelAvgAggregateInputType = {
    order?: true
  }

  export type HotelCardToLabelSumAggregateInputType = {
    order?: true
  }

  export type HotelCardToLabelMinAggregateInputType = {
    hotelCardId?: true
    labelId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToLabelMaxAggregateInputType = {
    hotelCardId?: true
    labelId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToLabelCountAggregateInputType = {
    hotelCardId?: true
    labelId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelCardToLabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToLabel to aggregate.
     */
    where?: HotelCardToLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToLabels to fetch.
     */
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCardToLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCardToLabels
    **/
    _count?: true | HotelCardToLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCardToLabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCardToLabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCardToLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCardToLabelMaxAggregateInputType
  }

  export type GetHotelCardToLabelAggregateType<T extends HotelCardToLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCardToLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCardToLabel[P]>
      : GetScalarType<T[P], AggregateHotelCardToLabel[P]>
  }




  export type HotelCardToLabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToLabelWhereInput
    orderBy?: HotelCardToLabelOrderByWithAggregationInput | HotelCardToLabelOrderByWithAggregationInput[]
    by: HotelCardToLabelScalarFieldEnum[] | HotelCardToLabelScalarFieldEnum
    having?: HotelCardToLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCardToLabelCountAggregateInputType | true
    _avg?: HotelCardToLabelAvgAggregateInputType
    _sum?: HotelCardToLabelSumAggregateInputType
    _min?: HotelCardToLabelMinAggregateInputType
    _max?: HotelCardToLabelMaxAggregateInputType
  }

  export type HotelCardToLabelGroupByOutputType = {
    hotelCardId: string
    labelId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCardToLabelCountAggregateOutputType | null
    _avg: HotelCardToLabelAvgAggregateOutputType | null
    _sum: HotelCardToLabelSumAggregateOutputType | null
    _min: HotelCardToLabelMinAggregateOutputType | null
    _max: HotelCardToLabelMaxAggregateOutputType | null
  }

  type GetHotelCardToLabelGroupByPayload<T extends HotelCardToLabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCardToLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCardToLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCardToLabelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCardToLabelGroupByOutputType[P]>
        }
      >
    >


  export type HotelCardToLabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    labelId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToLabel"]>

  export type HotelCardToLabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    labelId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToLabel"]>

  export type HotelCardToLabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    labelId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToLabel"]>

  export type HotelCardToLabelSelectScalar = {
    hotelCardId?: boolean
    labelId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelCardToLabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelCardId" | "labelId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelCardToLabel"]>
  export type HotelCardToLabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }
  export type HotelCardToLabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }
  export type HotelCardToLabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }

  export type $HotelCardToLabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCardToLabel"
    objects: {
      hotelCard: Prisma.$HotelCardPayload<ExtArgs>
      label: Prisma.$LabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelCardId: string
      labelId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelCardToLabel"]>
    composites: {}
  }

  type HotelCardToLabelGetPayload<S extends boolean | null | undefined | HotelCardToLabelDefaultArgs> = $Result.GetResult<Prisma.$HotelCardToLabelPayload, S>

  type HotelCardToLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelCardToLabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCardToLabelCountAggregateInputType | true
    }

  export interface HotelCardToLabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCardToLabel'], meta: { name: 'HotelCardToLabel' } }
    /**
     * Find zero or one HotelCardToLabel that matches the filter.
     * @param {HotelCardToLabelFindUniqueArgs} args - Arguments to find a HotelCardToLabel
     * @example
     * // Get one HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCardToLabelFindUniqueArgs>(args: SelectSubset<T, HotelCardToLabelFindUniqueArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelCardToLabel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelCardToLabelFindUniqueOrThrowArgs} args - Arguments to find a HotelCardToLabel
     * @example
     * // Get one HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCardToLabelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCardToLabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelFindFirstArgs} args - Arguments to find a HotelCardToLabel
     * @example
     * // Get one HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCardToLabelFindFirstArgs>(args?: SelectSubset<T, HotelCardToLabelFindFirstArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToLabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelFindFirstOrThrowArgs} args - Arguments to find a HotelCardToLabel
     * @example
     * // Get one HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCardToLabelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCardToLabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelCardToLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCardToLabels
     * const hotelCardToLabels = await prisma.hotelCardToLabel.findMany()
     * 
     * // Get first 10 HotelCardToLabels
     * const hotelCardToLabels = await prisma.hotelCardToLabel.findMany({ take: 10 })
     * 
     * // Only select the `hotelCardId`
     * const hotelCardToLabelWithHotelCardIdOnly = await prisma.hotelCardToLabel.findMany({ select: { hotelCardId: true } })
     * 
     */
    findMany<T extends HotelCardToLabelFindManyArgs>(args?: SelectSubset<T, HotelCardToLabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelCardToLabel.
     * @param {HotelCardToLabelCreateArgs} args - Arguments to create a HotelCardToLabel.
     * @example
     * // Create one HotelCardToLabel
     * const HotelCardToLabel = await prisma.hotelCardToLabel.create({
     *   data: {
     *     // ... data to create a HotelCardToLabel
     *   }
     * })
     * 
     */
    create<T extends HotelCardToLabelCreateArgs>(args: SelectSubset<T, HotelCardToLabelCreateArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelCardToLabels.
     * @param {HotelCardToLabelCreateManyArgs} args - Arguments to create many HotelCardToLabels.
     * @example
     * // Create many HotelCardToLabels
     * const hotelCardToLabel = await prisma.hotelCardToLabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCardToLabelCreateManyArgs>(args?: SelectSubset<T, HotelCardToLabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCardToLabels and returns the data saved in the database.
     * @param {HotelCardToLabelCreateManyAndReturnArgs} args - Arguments to create many HotelCardToLabels.
     * @example
     * // Create many HotelCardToLabels
     * const hotelCardToLabel = await prisma.hotelCardToLabel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCardToLabels and only return the `hotelCardId`
     * const hotelCardToLabelWithHotelCardIdOnly = await prisma.hotelCardToLabel.createManyAndReturn({
     *   select: { hotelCardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCardToLabelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCardToLabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelCardToLabel.
     * @param {HotelCardToLabelDeleteArgs} args - Arguments to delete one HotelCardToLabel.
     * @example
     * // Delete one HotelCardToLabel
     * const HotelCardToLabel = await prisma.hotelCardToLabel.delete({
     *   where: {
     *     // ... filter to delete one HotelCardToLabel
     *   }
     * })
     * 
     */
    delete<T extends HotelCardToLabelDeleteArgs>(args: SelectSubset<T, HotelCardToLabelDeleteArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelCardToLabel.
     * @param {HotelCardToLabelUpdateArgs} args - Arguments to update one HotelCardToLabel.
     * @example
     * // Update one HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCardToLabelUpdateArgs>(args: SelectSubset<T, HotelCardToLabelUpdateArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelCardToLabels.
     * @param {HotelCardToLabelDeleteManyArgs} args - Arguments to filter HotelCardToLabels to delete.
     * @example
     * // Delete a few HotelCardToLabels
     * const { count } = await prisma.hotelCardToLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCardToLabelDeleteManyArgs>(args?: SelectSubset<T, HotelCardToLabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCardToLabels
     * const hotelCardToLabel = await prisma.hotelCardToLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCardToLabelUpdateManyArgs>(args: SelectSubset<T, HotelCardToLabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToLabels and returns the data updated in the database.
     * @param {HotelCardToLabelUpdateManyAndReturnArgs} args - Arguments to update many HotelCardToLabels.
     * @example
     * // Update many HotelCardToLabels
     * const hotelCardToLabel = await prisma.hotelCardToLabel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelCardToLabels and only return the `hotelCardId`
     * const hotelCardToLabelWithHotelCardIdOnly = await prisma.hotelCardToLabel.updateManyAndReturn({
     *   select: { hotelCardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelCardToLabelUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelCardToLabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelCardToLabel.
     * @param {HotelCardToLabelUpsertArgs} args - Arguments to update or create a HotelCardToLabel.
     * @example
     * // Update or create a HotelCardToLabel
     * const hotelCardToLabel = await prisma.hotelCardToLabel.upsert({
     *   create: {
     *     // ... data to create a HotelCardToLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCardToLabel we want to update
     *   }
     * })
     */
    upsert<T extends HotelCardToLabelUpsertArgs>(args: SelectSubset<T, HotelCardToLabelUpsertArgs<ExtArgs>>): Prisma__HotelCardToLabelClient<$Result.GetResult<Prisma.$HotelCardToLabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelCardToLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelCountArgs} args - Arguments to filter HotelCardToLabels to count.
     * @example
     * // Count the number of HotelCardToLabels
     * const count = await prisma.hotelCardToLabel.count({
     *   where: {
     *     // ... the filter for the HotelCardToLabels we want to count
     *   }
     * })
    **/
    count<T extends HotelCardToLabelCountArgs>(
      args?: Subset<T, HotelCardToLabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCardToLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCardToLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCardToLabelAggregateArgs>(args: Subset<T, HotelCardToLabelAggregateArgs>): Prisma.PrismaPromise<GetHotelCardToLabelAggregateType<T>>

    /**
     * Group by HotelCardToLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCardToLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCardToLabelGroupByArgs['orderBy'] }
        : { orderBy?: HotelCardToLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCardToLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCardToLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCardToLabel model
   */
  readonly fields: HotelCardToLabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCardToLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCardToLabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelCard<T extends HotelCardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelCardDefaultArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    label<T extends LabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabelDefaultArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCardToLabel model
   */
  interface HotelCardToLabelFieldRefs {
    readonly hotelCardId: FieldRef<"HotelCardToLabel", 'String'>
    readonly labelId: FieldRef<"HotelCardToLabel", 'String'>
    readonly order: FieldRef<"HotelCardToLabel", 'Int'>
    readonly createdAt: FieldRef<"HotelCardToLabel", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelCardToLabel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelCardToLabel findUnique
   */
  export type HotelCardToLabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToLabel to fetch.
     */
    where: HotelCardToLabelWhereUniqueInput
  }

  /**
   * HotelCardToLabel findUniqueOrThrow
   */
  export type HotelCardToLabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToLabel to fetch.
     */
    where: HotelCardToLabelWhereUniqueInput
  }

  /**
   * HotelCardToLabel findFirst
   */
  export type HotelCardToLabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToLabel to fetch.
     */
    where?: HotelCardToLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToLabels to fetch.
     */
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToLabels.
     */
    cursor?: HotelCardToLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToLabels.
     */
    distinct?: HotelCardToLabelScalarFieldEnum | HotelCardToLabelScalarFieldEnum[]
  }

  /**
   * HotelCardToLabel findFirstOrThrow
   */
  export type HotelCardToLabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToLabel to fetch.
     */
    where?: HotelCardToLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToLabels to fetch.
     */
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToLabels.
     */
    cursor?: HotelCardToLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToLabels.
     */
    distinct?: HotelCardToLabelScalarFieldEnum | HotelCardToLabelScalarFieldEnum[]
  }

  /**
   * HotelCardToLabel findMany
   */
  export type HotelCardToLabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToLabels to fetch.
     */
    where?: HotelCardToLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToLabels to fetch.
     */
    orderBy?: HotelCardToLabelOrderByWithRelationInput | HotelCardToLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCardToLabels.
     */
    cursor?: HotelCardToLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToLabels.
     */
    skip?: number
    distinct?: HotelCardToLabelScalarFieldEnum | HotelCardToLabelScalarFieldEnum[]
  }

  /**
   * HotelCardToLabel create
   */
  export type HotelCardToLabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCardToLabel.
     */
    data: XOR<HotelCardToLabelCreateInput, HotelCardToLabelUncheckedCreateInput>
  }

  /**
   * HotelCardToLabel createMany
   */
  export type HotelCardToLabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCardToLabels.
     */
    data: HotelCardToLabelCreateManyInput | HotelCardToLabelCreateManyInput[]
  }

  /**
   * HotelCardToLabel createManyAndReturn
   */
  export type HotelCardToLabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * The data used to create many HotelCardToLabels.
     */
    data: HotelCardToLabelCreateManyInput | HotelCardToLabelCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToLabel update
   */
  export type HotelCardToLabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCardToLabel.
     */
    data: XOR<HotelCardToLabelUpdateInput, HotelCardToLabelUncheckedUpdateInput>
    /**
     * Choose, which HotelCardToLabel to update.
     */
    where: HotelCardToLabelWhereUniqueInput
  }

  /**
   * HotelCardToLabel updateMany
   */
  export type HotelCardToLabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCardToLabels.
     */
    data: XOR<HotelCardToLabelUpdateManyMutationInput, HotelCardToLabelUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToLabels to update
     */
    where?: HotelCardToLabelWhereInput
    /**
     * Limit how many HotelCardToLabels to update.
     */
    limit?: number
  }

  /**
   * HotelCardToLabel updateManyAndReturn
   */
  export type HotelCardToLabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * The data used to update HotelCardToLabels.
     */
    data: XOR<HotelCardToLabelUpdateManyMutationInput, HotelCardToLabelUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToLabels to update
     */
    where?: HotelCardToLabelWhereInput
    /**
     * Limit how many HotelCardToLabels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToLabel upsert
   */
  export type HotelCardToLabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCardToLabel to update in case it exists.
     */
    where: HotelCardToLabelWhereUniqueInput
    /**
     * In case the HotelCardToLabel found by the `where` argument doesn't exist, create a new HotelCardToLabel with this data.
     */
    create: XOR<HotelCardToLabelCreateInput, HotelCardToLabelUncheckedCreateInput>
    /**
     * In case the HotelCardToLabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCardToLabelUpdateInput, HotelCardToLabelUncheckedUpdateInput>
  }

  /**
   * HotelCardToLabel delete
   */
  export type HotelCardToLabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
    /**
     * Filter which HotelCardToLabel to delete.
     */
    where: HotelCardToLabelWhereUniqueInput
  }

  /**
   * HotelCardToLabel deleteMany
   */
  export type HotelCardToLabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToLabels to delete
     */
    where?: HotelCardToLabelWhereInput
    /**
     * Limit how many HotelCardToLabels to delete.
     */
    limit?: number
  }

  /**
   * HotelCardToLabel without action
   */
  export type HotelCardToLabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToLabel
     */
    select?: HotelCardToLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToLabel
     */
    omit?: HotelCardToLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToLabelInclude<ExtArgs> | null
  }


  /**
   * Model HotelCardToAccessibilityOption
   */

  export type AggregateHotelCardToAccessibilityOption = {
    _count: HotelCardToAccessibilityOptionCountAggregateOutputType | null
    _avg: HotelCardToAccessibilityOptionAvgAggregateOutputType | null
    _sum: HotelCardToAccessibilityOptionSumAggregateOutputType | null
    _min: HotelCardToAccessibilityOptionMinAggregateOutputType | null
    _max: HotelCardToAccessibilityOptionMaxAggregateOutputType | null
  }

  export type HotelCardToAccessibilityOptionAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToAccessibilityOptionSumAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToAccessibilityOptionMinAggregateOutputType = {
    hotelCardId: string | null
    accessibilityOptionId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToAccessibilityOptionMaxAggregateOutputType = {
    hotelCardId: string | null
    accessibilityOptionId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToAccessibilityOptionCountAggregateOutputType = {
    hotelCardId: number
    accessibilityOptionId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelCardToAccessibilityOptionAvgAggregateInputType = {
    order?: true
  }

  export type HotelCardToAccessibilityOptionSumAggregateInputType = {
    order?: true
  }

  export type HotelCardToAccessibilityOptionMinAggregateInputType = {
    hotelCardId?: true
    accessibilityOptionId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToAccessibilityOptionMaxAggregateInputType = {
    hotelCardId?: true
    accessibilityOptionId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToAccessibilityOptionCountAggregateInputType = {
    hotelCardId?: true
    accessibilityOptionId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelCardToAccessibilityOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToAccessibilityOption to aggregate.
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToAccessibilityOptions to fetch.
     */
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToAccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToAccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCardToAccessibilityOptions
    **/
    _count?: true | HotelCardToAccessibilityOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCardToAccessibilityOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCardToAccessibilityOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCardToAccessibilityOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCardToAccessibilityOptionMaxAggregateInputType
  }

  export type GetHotelCardToAccessibilityOptionAggregateType<T extends HotelCardToAccessibilityOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCardToAccessibilityOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCardToAccessibilityOption[P]>
      : GetScalarType<T[P], AggregateHotelCardToAccessibilityOption[P]>
  }




  export type HotelCardToAccessibilityOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToAccessibilityOptionWhereInput
    orderBy?: HotelCardToAccessibilityOptionOrderByWithAggregationInput | HotelCardToAccessibilityOptionOrderByWithAggregationInput[]
    by: HotelCardToAccessibilityOptionScalarFieldEnum[] | HotelCardToAccessibilityOptionScalarFieldEnum
    having?: HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCardToAccessibilityOptionCountAggregateInputType | true
    _avg?: HotelCardToAccessibilityOptionAvgAggregateInputType
    _sum?: HotelCardToAccessibilityOptionSumAggregateInputType
    _min?: HotelCardToAccessibilityOptionMinAggregateInputType
    _max?: HotelCardToAccessibilityOptionMaxAggregateInputType
  }

  export type HotelCardToAccessibilityOptionGroupByOutputType = {
    hotelCardId: string
    accessibilityOptionId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCardToAccessibilityOptionCountAggregateOutputType | null
    _avg: HotelCardToAccessibilityOptionAvgAggregateOutputType | null
    _sum: HotelCardToAccessibilityOptionSumAggregateOutputType | null
    _min: HotelCardToAccessibilityOptionMinAggregateOutputType | null
    _max: HotelCardToAccessibilityOptionMaxAggregateOutputType | null
  }

  type GetHotelCardToAccessibilityOptionGroupByPayload<T extends HotelCardToAccessibilityOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCardToAccessibilityOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCardToAccessibilityOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCardToAccessibilityOptionGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCardToAccessibilityOptionGroupByOutputType[P]>
        }
      >
    >


  export type HotelCardToAccessibilityOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    accessibilityOptionId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToAccessibilityOption"]>

  export type HotelCardToAccessibilityOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    accessibilityOptionId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToAccessibilityOption"]>

  export type HotelCardToAccessibilityOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    accessibilityOptionId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToAccessibilityOption"]>

  export type HotelCardToAccessibilityOptionSelectScalar = {
    hotelCardId?: boolean
    accessibilityOptionId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelCardToAccessibilityOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelCardId" | "accessibilityOptionId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelCardToAccessibilityOption"]>
  export type HotelCardToAccessibilityOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }
  export type HotelCardToAccessibilityOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }
  export type HotelCardToAccessibilityOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    accessibilityOption?: boolean | AccessibilityOptionDefaultArgs<ExtArgs>
  }

  export type $HotelCardToAccessibilityOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCardToAccessibilityOption"
    objects: {
      hotelCard: Prisma.$HotelCardPayload<ExtArgs>
      accessibilityOption: Prisma.$AccessibilityOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelCardId: string
      accessibilityOptionId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelCardToAccessibilityOption"]>
    composites: {}
  }

  type HotelCardToAccessibilityOptionGetPayload<S extends boolean | null | undefined | HotelCardToAccessibilityOptionDefaultArgs> = $Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload, S>

  type HotelCardToAccessibilityOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelCardToAccessibilityOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCardToAccessibilityOptionCountAggregateInputType | true
    }

  export interface HotelCardToAccessibilityOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCardToAccessibilityOption'], meta: { name: 'HotelCardToAccessibilityOption' } }
    /**
     * Find zero or one HotelCardToAccessibilityOption that matches the filter.
     * @param {HotelCardToAccessibilityOptionFindUniqueArgs} args - Arguments to find a HotelCardToAccessibilityOption
     * @example
     * // Get one HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCardToAccessibilityOptionFindUniqueArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionFindUniqueArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelCardToAccessibilityOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelCardToAccessibilityOptionFindUniqueOrThrowArgs} args - Arguments to find a HotelCardToAccessibilityOption
     * @example
     * // Get one HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCardToAccessibilityOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToAccessibilityOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionFindFirstArgs} args - Arguments to find a HotelCardToAccessibilityOption
     * @example
     * // Get one HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCardToAccessibilityOptionFindFirstArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionFindFirstArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToAccessibilityOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionFindFirstOrThrowArgs} args - Arguments to find a HotelCardToAccessibilityOption
     * @example
     * // Get one HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCardToAccessibilityOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelCardToAccessibilityOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOptions = await prisma.hotelCardToAccessibilityOption.findMany()
     * 
     * // Get first 10 HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOptions = await prisma.hotelCardToAccessibilityOption.findMany({ take: 10 })
     * 
     * // Only select the `hotelCardId`
     * const hotelCardToAccessibilityOptionWithHotelCardIdOnly = await prisma.hotelCardToAccessibilityOption.findMany({ select: { hotelCardId: true } })
     * 
     */
    findMany<T extends HotelCardToAccessibilityOptionFindManyArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelCardToAccessibilityOption.
     * @param {HotelCardToAccessibilityOptionCreateArgs} args - Arguments to create a HotelCardToAccessibilityOption.
     * @example
     * // Create one HotelCardToAccessibilityOption
     * const HotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.create({
     *   data: {
     *     // ... data to create a HotelCardToAccessibilityOption
     *   }
     * })
     * 
     */
    create<T extends HotelCardToAccessibilityOptionCreateArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionCreateArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelCardToAccessibilityOptions.
     * @param {HotelCardToAccessibilityOptionCreateManyArgs} args - Arguments to create many HotelCardToAccessibilityOptions.
     * @example
     * // Create many HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCardToAccessibilityOptionCreateManyArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCardToAccessibilityOptions and returns the data saved in the database.
     * @param {HotelCardToAccessibilityOptionCreateManyAndReturnArgs} args - Arguments to create many HotelCardToAccessibilityOptions.
     * @example
     * // Create many HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCardToAccessibilityOptions and only return the `hotelCardId`
     * const hotelCardToAccessibilityOptionWithHotelCardIdOnly = await prisma.hotelCardToAccessibilityOption.createManyAndReturn({
     *   select: { hotelCardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCardToAccessibilityOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelCardToAccessibilityOption.
     * @param {HotelCardToAccessibilityOptionDeleteArgs} args - Arguments to delete one HotelCardToAccessibilityOption.
     * @example
     * // Delete one HotelCardToAccessibilityOption
     * const HotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.delete({
     *   where: {
     *     // ... filter to delete one HotelCardToAccessibilityOption
     *   }
     * })
     * 
     */
    delete<T extends HotelCardToAccessibilityOptionDeleteArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionDeleteArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelCardToAccessibilityOption.
     * @param {HotelCardToAccessibilityOptionUpdateArgs} args - Arguments to update one HotelCardToAccessibilityOption.
     * @example
     * // Update one HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCardToAccessibilityOptionUpdateArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionUpdateArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelCardToAccessibilityOptions.
     * @param {HotelCardToAccessibilityOptionDeleteManyArgs} args - Arguments to filter HotelCardToAccessibilityOptions to delete.
     * @example
     * // Delete a few HotelCardToAccessibilityOptions
     * const { count } = await prisma.hotelCardToAccessibilityOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCardToAccessibilityOptionDeleteManyArgs>(args?: SelectSubset<T, HotelCardToAccessibilityOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToAccessibilityOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCardToAccessibilityOptionUpdateManyArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToAccessibilityOptions and returns the data updated in the database.
     * @param {HotelCardToAccessibilityOptionUpdateManyAndReturnArgs} args - Arguments to update many HotelCardToAccessibilityOptions.
     * @example
     * // Update many HotelCardToAccessibilityOptions
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelCardToAccessibilityOptions and only return the `hotelCardId`
     * const hotelCardToAccessibilityOptionWithHotelCardIdOnly = await prisma.hotelCardToAccessibilityOption.updateManyAndReturn({
     *   select: { hotelCardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelCardToAccessibilityOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelCardToAccessibilityOption.
     * @param {HotelCardToAccessibilityOptionUpsertArgs} args - Arguments to update or create a HotelCardToAccessibilityOption.
     * @example
     * // Update or create a HotelCardToAccessibilityOption
     * const hotelCardToAccessibilityOption = await prisma.hotelCardToAccessibilityOption.upsert({
     *   create: {
     *     // ... data to create a HotelCardToAccessibilityOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCardToAccessibilityOption we want to update
     *   }
     * })
     */
    upsert<T extends HotelCardToAccessibilityOptionUpsertArgs>(args: SelectSubset<T, HotelCardToAccessibilityOptionUpsertArgs<ExtArgs>>): Prisma__HotelCardToAccessibilityOptionClient<$Result.GetResult<Prisma.$HotelCardToAccessibilityOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelCardToAccessibilityOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionCountArgs} args - Arguments to filter HotelCardToAccessibilityOptions to count.
     * @example
     * // Count the number of HotelCardToAccessibilityOptions
     * const count = await prisma.hotelCardToAccessibilityOption.count({
     *   where: {
     *     // ... the filter for the HotelCardToAccessibilityOptions we want to count
     *   }
     * })
    **/
    count<T extends HotelCardToAccessibilityOptionCountArgs>(
      args?: Subset<T, HotelCardToAccessibilityOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCardToAccessibilityOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCardToAccessibilityOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCardToAccessibilityOptionAggregateArgs>(args: Subset<T, HotelCardToAccessibilityOptionAggregateArgs>): Prisma.PrismaPromise<GetHotelCardToAccessibilityOptionAggregateType<T>>

    /**
     * Group by HotelCardToAccessibilityOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToAccessibilityOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCardToAccessibilityOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCardToAccessibilityOptionGroupByArgs['orderBy'] }
        : { orderBy?: HotelCardToAccessibilityOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCardToAccessibilityOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCardToAccessibilityOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCardToAccessibilityOption model
   */
  readonly fields: HotelCardToAccessibilityOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCardToAccessibilityOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCardToAccessibilityOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelCard<T extends HotelCardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelCardDefaultArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accessibilityOption<T extends AccessibilityOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccessibilityOptionDefaultArgs<ExtArgs>>): Prisma__AccessibilityOptionClient<$Result.GetResult<Prisma.$AccessibilityOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCardToAccessibilityOption model
   */
  interface HotelCardToAccessibilityOptionFieldRefs {
    readonly hotelCardId: FieldRef<"HotelCardToAccessibilityOption", 'String'>
    readonly accessibilityOptionId: FieldRef<"HotelCardToAccessibilityOption", 'String'>
    readonly order: FieldRef<"HotelCardToAccessibilityOption", 'Int'>
    readonly createdAt: FieldRef<"HotelCardToAccessibilityOption", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelCardToAccessibilityOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelCardToAccessibilityOption findUnique
   */
  export type HotelCardToAccessibilityOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToAccessibilityOption to fetch.
     */
    where: HotelCardToAccessibilityOptionWhereUniqueInput
  }

  /**
   * HotelCardToAccessibilityOption findUniqueOrThrow
   */
  export type HotelCardToAccessibilityOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToAccessibilityOption to fetch.
     */
    where: HotelCardToAccessibilityOptionWhereUniqueInput
  }

  /**
   * HotelCardToAccessibilityOption findFirst
   */
  export type HotelCardToAccessibilityOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToAccessibilityOption to fetch.
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToAccessibilityOptions to fetch.
     */
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToAccessibilityOptions.
     */
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToAccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToAccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToAccessibilityOptions.
     */
    distinct?: HotelCardToAccessibilityOptionScalarFieldEnum | HotelCardToAccessibilityOptionScalarFieldEnum[]
  }

  /**
   * HotelCardToAccessibilityOption findFirstOrThrow
   */
  export type HotelCardToAccessibilityOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToAccessibilityOption to fetch.
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToAccessibilityOptions to fetch.
     */
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToAccessibilityOptions.
     */
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToAccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToAccessibilityOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToAccessibilityOptions.
     */
    distinct?: HotelCardToAccessibilityOptionScalarFieldEnum | HotelCardToAccessibilityOptionScalarFieldEnum[]
  }

  /**
   * HotelCardToAccessibilityOption findMany
   */
  export type HotelCardToAccessibilityOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToAccessibilityOptions to fetch.
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToAccessibilityOptions to fetch.
     */
    orderBy?: HotelCardToAccessibilityOptionOrderByWithRelationInput | HotelCardToAccessibilityOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCardToAccessibilityOptions.
     */
    cursor?: HotelCardToAccessibilityOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToAccessibilityOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToAccessibilityOptions.
     */
    skip?: number
    distinct?: HotelCardToAccessibilityOptionScalarFieldEnum | HotelCardToAccessibilityOptionScalarFieldEnum[]
  }

  /**
   * HotelCardToAccessibilityOption create
   */
  export type HotelCardToAccessibilityOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCardToAccessibilityOption.
     */
    data: XOR<HotelCardToAccessibilityOptionCreateInput, HotelCardToAccessibilityOptionUncheckedCreateInput>
  }

  /**
   * HotelCardToAccessibilityOption createMany
   */
  export type HotelCardToAccessibilityOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCardToAccessibilityOptions.
     */
    data: HotelCardToAccessibilityOptionCreateManyInput | HotelCardToAccessibilityOptionCreateManyInput[]
  }

  /**
   * HotelCardToAccessibilityOption createManyAndReturn
   */
  export type HotelCardToAccessibilityOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * The data used to create many HotelCardToAccessibilityOptions.
     */
    data: HotelCardToAccessibilityOptionCreateManyInput | HotelCardToAccessibilityOptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToAccessibilityOption update
   */
  export type HotelCardToAccessibilityOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCardToAccessibilityOption.
     */
    data: XOR<HotelCardToAccessibilityOptionUpdateInput, HotelCardToAccessibilityOptionUncheckedUpdateInput>
    /**
     * Choose, which HotelCardToAccessibilityOption to update.
     */
    where: HotelCardToAccessibilityOptionWhereUniqueInput
  }

  /**
   * HotelCardToAccessibilityOption updateMany
   */
  export type HotelCardToAccessibilityOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCardToAccessibilityOptions.
     */
    data: XOR<HotelCardToAccessibilityOptionUpdateManyMutationInput, HotelCardToAccessibilityOptionUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToAccessibilityOptions to update
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * Limit how many HotelCardToAccessibilityOptions to update.
     */
    limit?: number
  }

  /**
   * HotelCardToAccessibilityOption updateManyAndReturn
   */
  export type HotelCardToAccessibilityOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * The data used to update HotelCardToAccessibilityOptions.
     */
    data: XOR<HotelCardToAccessibilityOptionUpdateManyMutationInput, HotelCardToAccessibilityOptionUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToAccessibilityOptions to update
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * Limit how many HotelCardToAccessibilityOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToAccessibilityOption upsert
   */
  export type HotelCardToAccessibilityOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCardToAccessibilityOption to update in case it exists.
     */
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    /**
     * In case the HotelCardToAccessibilityOption found by the `where` argument doesn't exist, create a new HotelCardToAccessibilityOption with this data.
     */
    create: XOR<HotelCardToAccessibilityOptionCreateInput, HotelCardToAccessibilityOptionUncheckedCreateInput>
    /**
     * In case the HotelCardToAccessibilityOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCardToAccessibilityOptionUpdateInput, HotelCardToAccessibilityOptionUncheckedUpdateInput>
  }

  /**
   * HotelCardToAccessibilityOption delete
   */
  export type HotelCardToAccessibilityOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
    /**
     * Filter which HotelCardToAccessibilityOption to delete.
     */
    where: HotelCardToAccessibilityOptionWhereUniqueInput
  }

  /**
   * HotelCardToAccessibilityOption deleteMany
   */
  export type HotelCardToAccessibilityOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToAccessibilityOptions to delete
     */
    where?: HotelCardToAccessibilityOptionWhereInput
    /**
     * Limit how many HotelCardToAccessibilityOptions to delete.
     */
    limit?: number
  }

  /**
   * HotelCardToAccessibilityOption without action
   */
  export type HotelCardToAccessibilityOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToAccessibilityOption
     */
    select?: HotelCardToAccessibilityOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToAccessibilityOption
     */
    omit?: HotelCardToAccessibilityOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToAccessibilityOptionInclude<ExtArgs> | null
  }


  /**
   * Model HotelCardToHotelAmenity
   */

  export type AggregateHotelCardToHotelAmenity = {
    _count: HotelCardToHotelAmenityCountAggregateOutputType | null
    _avg: HotelCardToHotelAmenityAvgAggregateOutputType | null
    _sum: HotelCardToHotelAmenitySumAggregateOutputType | null
    _min: HotelCardToHotelAmenityMinAggregateOutputType | null
    _max: HotelCardToHotelAmenityMaxAggregateOutputType | null
  }

  export type HotelCardToHotelAmenityAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToHotelAmenitySumAggregateOutputType = {
    order: number | null
  }

  export type HotelCardToHotelAmenityMinAggregateOutputType = {
    hotelCardId: string | null
    hotelAmenityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToHotelAmenityMaxAggregateOutputType = {
    hotelCardId: string | null
    hotelAmenityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCardToHotelAmenityCountAggregateOutputType = {
    hotelCardId: number
    hotelAmenityId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelCardToHotelAmenityAvgAggregateInputType = {
    order?: true
  }

  export type HotelCardToHotelAmenitySumAggregateInputType = {
    order?: true
  }

  export type HotelCardToHotelAmenityMinAggregateInputType = {
    hotelCardId?: true
    hotelAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToHotelAmenityMaxAggregateInputType = {
    hotelCardId?: true
    hotelAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCardToHotelAmenityCountAggregateInputType = {
    hotelCardId?: true
    hotelAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelCardToHotelAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToHotelAmenity to aggregate.
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelAmenities to fetch.
     */
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCardToHotelAmenities
    **/
    _count?: true | HotelCardToHotelAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCardToHotelAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCardToHotelAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCardToHotelAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCardToHotelAmenityMaxAggregateInputType
  }

  export type GetHotelCardToHotelAmenityAggregateType<T extends HotelCardToHotelAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCardToHotelAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCardToHotelAmenity[P]>
      : GetScalarType<T[P], AggregateHotelCardToHotelAmenity[P]>
  }




  export type HotelCardToHotelAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCardToHotelAmenityWhereInput
    orderBy?: HotelCardToHotelAmenityOrderByWithAggregationInput | HotelCardToHotelAmenityOrderByWithAggregationInput[]
    by: HotelCardToHotelAmenityScalarFieldEnum[] | HotelCardToHotelAmenityScalarFieldEnum
    having?: HotelCardToHotelAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCardToHotelAmenityCountAggregateInputType | true
    _avg?: HotelCardToHotelAmenityAvgAggregateInputType
    _sum?: HotelCardToHotelAmenitySumAggregateInputType
    _min?: HotelCardToHotelAmenityMinAggregateInputType
    _max?: HotelCardToHotelAmenityMaxAggregateInputType
  }

  export type HotelCardToHotelAmenityGroupByOutputType = {
    hotelCardId: string
    hotelAmenityId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCardToHotelAmenityCountAggregateOutputType | null
    _avg: HotelCardToHotelAmenityAvgAggregateOutputType | null
    _sum: HotelCardToHotelAmenitySumAggregateOutputType | null
    _min: HotelCardToHotelAmenityMinAggregateOutputType | null
    _max: HotelCardToHotelAmenityMaxAggregateOutputType | null
  }

  type GetHotelCardToHotelAmenityGroupByPayload<T extends HotelCardToHotelAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCardToHotelAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCardToHotelAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCardToHotelAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCardToHotelAmenityGroupByOutputType[P]>
        }
      >
    >


  export type HotelCardToHotelAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelAmenity"]>

  export type HotelCardToHotelAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelAmenity"]>

  export type HotelCardToHotelAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelCardId?: boolean
    hotelAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCardToHotelAmenity"]>

  export type HotelCardToHotelAmenitySelectScalar = {
    hotelCardId?: boolean
    hotelAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelCardToHotelAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelCardId" | "hotelAmenityId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelCardToHotelAmenity"]>
  export type HotelCardToHotelAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }
  export type HotelCardToHotelAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }
  export type HotelCardToHotelAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelCard?: boolean | HotelCardDefaultArgs<ExtArgs>
    hotelAmenity?: boolean | HotelAmenityDefaultArgs<ExtArgs>
  }

  export type $HotelCardToHotelAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCardToHotelAmenity"
    objects: {
      hotelCard: Prisma.$HotelCardPayload<ExtArgs>
      hotelAmenity: Prisma.$HotelAmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelCardId: string
      hotelAmenityId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelCardToHotelAmenity"]>
    composites: {}
  }

  type HotelCardToHotelAmenityGetPayload<S extends boolean | null | undefined | HotelCardToHotelAmenityDefaultArgs> = $Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload, S>

  type HotelCardToHotelAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelCardToHotelAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCardToHotelAmenityCountAggregateInputType | true
    }

  export interface HotelCardToHotelAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCardToHotelAmenity'], meta: { name: 'HotelCardToHotelAmenity' } }
    /**
     * Find zero or one HotelCardToHotelAmenity that matches the filter.
     * @param {HotelCardToHotelAmenityFindUniqueArgs} args - Arguments to find a HotelCardToHotelAmenity
     * @example
     * // Get one HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCardToHotelAmenityFindUniqueArgs>(args: SelectSubset<T, HotelCardToHotelAmenityFindUniqueArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelCardToHotelAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelCardToHotelAmenityFindUniqueOrThrowArgs} args - Arguments to find a HotelCardToHotelAmenity
     * @example
     * // Get one HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCardToHotelAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCardToHotelAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToHotelAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityFindFirstArgs} args - Arguments to find a HotelCardToHotelAmenity
     * @example
     * // Get one HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCardToHotelAmenityFindFirstArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityFindFirstArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelCardToHotelAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityFindFirstOrThrowArgs} args - Arguments to find a HotelCardToHotelAmenity
     * @example
     * // Get one HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCardToHotelAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelCardToHotelAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCardToHotelAmenities
     * const hotelCardToHotelAmenities = await prisma.hotelCardToHotelAmenity.findMany()
     * 
     * // Get first 10 HotelCardToHotelAmenities
     * const hotelCardToHotelAmenities = await prisma.hotelCardToHotelAmenity.findMany({ take: 10 })
     * 
     * // Only select the `hotelCardId`
     * const hotelCardToHotelAmenityWithHotelCardIdOnly = await prisma.hotelCardToHotelAmenity.findMany({ select: { hotelCardId: true } })
     * 
     */
    findMany<T extends HotelCardToHotelAmenityFindManyArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelCardToHotelAmenity.
     * @param {HotelCardToHotelAmenityCreateArgs} args - Arguments to create a HotelCardToHotelAmenity.
     * @example
     * // Create one HotelCardToHotelAmenity
     * const HotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.create({
     *   data: {
     *     // ... data to create a HotelCardToHotelAmenity
     *   }
     * })
     * 
     */
    create<T extends HotelCardToHotelAmenityCreateArgs>(args: SelectSubset<T, HotelCardToHotelAmenityCreateArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelCardToHotelAmenities.
     * @param {HotelCardToHotelAmenityCreateManyArgs} args - Arguments to create many HotelCardToHotelAmenities.
     * @example
     * // Create many HotelCardToHotelAmenities
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCardToHotelAmenityCreateManyArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCardToHotelAmenities and returns the data saved in the database.
     * @param {HotelCardToHotelAmenityCreateManyAndReturnArgs} args - Arguments to create many HotelCardToHotelAmenities.
     * @example
     * // Create many HotelCardToHotelAmenities
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCardToHotelAmenities and only return the `hotelCardId`
     * const hotelCardToHotelAmenityWithHotelCardIdOnly = await prisma.hotelCardToHotelAmenity.createManyAndReturn({
     *   select: { hotelCardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCardToHotelAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelCardToHotelAmenity.
     * @param {HotelCardToHotelAmenityDeleteArgs} args - Arguments to delete one HotelCardToHotelAmenity.
     * @example
     * // Delete one HotelCardToHotelAmenity
     * const HotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.delete({
     *   where: {
     *     // ... filter to delete one HotelCardToHotelAmenity
     *   }
     * })
     * 
     */
    delete<T extends HotelCardToHotelAmenityDeleteArgs>(args: SelectSubset<T, HotelCardToHotelAmenityDeleteArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelCardToHotelAmenity.
     * @param {HotelCardToHotelAmenityUpdateArgs} args - Arguments to update one HotelCardToHotelAmenity.
     * @example
     * // Update one HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCardToHotelAmenityUpdateArgs>(args: SelectSubset<T, HotelCardToHotelAmenityUpdateArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelCardToHotelAmenities.
     * @param {HotelCardToHotelAmenityDeleteManyArgs} args - Arguments to filter HotelCardToHotelAmenities to delete.
     * @example
     * // Delete a few HotelCardToHotelAmenities
     * const { count } = await prisma.hotelCardToHotelAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCardToHotelAmenityDeleteManyArgs>(args?: SelectSubset<T, HotelCardToHotelAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToHotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCardToHotelAmenities
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCardToHotelAmenityUpdateManyArgs>(args: SelectSubset<T, HotelCardToHotelAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCardToHotelAmenities and returns the data updated in the database.
     * @param {HotelCardToHotelAmenityUpdateManyAndReturnArgs} args - Arguments to update many HotelCardToHotelAmenities.
     * @example
     * // Update many HotelCardToHotelAmenities
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelCardToHotelAmenities and only return the `hotelCardId`
     * const hotelCardToHotelAmenityWithHotelCardIdOnly = await prisma.hotelCardToHotelAmenity.updateManyAndReturn({
     *   select: { hotelCardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelCardToHotelAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelCardToHotelAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelCardToHotelAmenity.
     * @param {HotelCardToHotelAmenityUpsertArgs} args - Arguments to update or create a HotelCardToHotelAmenity.
     * @example
     * // Update or create a HotelCardToHotelAmenity
     * const hotelCardToHotelAmenity = await prisma.hotelCardToHotelAmenity.upsert({
     *   create: {
     *     // ... data to create a HotelCardToHotelAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCardToHotelAmenity we want to update
     *   }
     * })
     */
    upsert<T extends HotelCardToHotelAmenityUpsertArgs>(args: SelectSubset<T, HotelCardToHotelAmenityUpsertArgs<ExtArgs>>): Prisma__HotelCardToHotelAmenityClient<$Result.GetResult<Prisma.$HotelCardToHotelAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelCardToHotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityCountArgs} args - Arguments to filter HotelCardToHotelAmenities to count.
     * @example
     * // Count the number of HotelCardToHotelAmenities
     * const count = await prisma.hotelCardToHotelAmenity.count({
     *   where: {
     *     // ... the filter for the HotelCardToHotelAmenities we want to count
     *   }
     * })
    **/
    count<T extends HotelCardToHotelAmenityCountArgs>(
      args?: Subset<T, HotelCardToHotelAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCardToHotelAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCardToHotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCardToHotelAmenityAggregateArgs>(args: Subset<T, HotelCardToHotelAmenityAggregateArgs>): Prisma.PrismaPromise<GetHotelCardToHotelAmenityAggregateType<T>>

    /**
     * Group by HotelCardToHotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCardToHotelAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCardToHotelAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCardToHotelAmenityGroupByArgs['orderBy'] }
        : { orderBy?: HotelCardToHotelAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCardToHotelAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCardToHotelAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCardToHotelAmenity model
   */
  readonly fields: HotelCardToHotelAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCardToHotelAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCardToHotelAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelCard<T extends HotelCardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelCardDefaultArgs<ExtArgs>>): Prisma__HotelCardClient<$Result.GetResult<Prisma.$HotelCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hotelAmenity<T extends HotelAmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelAmenityDefaultArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCardToHotelAmenity model
   */
  interface HotelCardToHotelAmenityFieldRefs {
    readonly hotelCardId: FieldRef<"HotelCardToHotelAmenity", 'String'>
    readonly hotelAmenityId: FieldRef<"HotelCardToHotelAmenity", 'String'>
    readonly order: FieldRef<"HotelCardToHotelAmenity", 'Int'>
    readonly createdAt: FieldRef<"HotelCardToHotelAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelCardToHotelAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelCardToHotelAmenity findUnique
   */
  export type HotelCardToHotelAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelAmenity to fetch.
     */
    where: HotelCardToHotelAmenityWhereUniqueInput
  }

  /**
   * HotelCardToHotelAmenity findUniqueOrThrow
   */
  export type HotelCardToHotelAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelAmenity to fetch.
     */
    where: HotelCardToHotelAmenityWhereUniqueInput
  }

  /**
   * HotelCardToHotelAmenity findFirst
   */
  export type HotelCardToHotelAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelAmenity to fetch.
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelAmenities to fetch.
     */
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToHotelAmenities.
     */
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToHotelAmenities.
     */
    distinct?: HotelCardToHotelAmenityScalarFieldEnum | HotelCardToHotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelAmenity findFirstOrThrow
   */
  export type HotelCardToHotelAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelAmenity to fetch.
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelAmenities to fetch.
     */
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCardToHotelAmenities.
     */
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCardToHotelAmenities.
     */
    distinct?: HotelCardToHotelAmenityScalarFieldEnum | HotelCardToHotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelAmenity findMany
   */
  export type HotelCardToHotelAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelCardToHotelAmenities to fetch.
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCardToHotelAmenities to fetch.
     */
    orderBy?: HotelCardToHotelAmenityOrderByWithRelationInput | HotelCardToHotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCardToHotelAmenities.
     */
    cursor?: HotelCardToHotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCardToHotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCardToHotelAmenities.
     */
    skip?: number
    distinct?: HotelCardToHotelAmenityScalarFieldEnum | HotelCardToHotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelCardToHotelAmenity create
   */
  export type HotelCardToHotelAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCardToHotelAmenity.
     */
    data: XOR<HotelCardToHotelAmenityCreateInput, HotelCardToHotelAmenityUncheckedCreateInput>
  }

  /**
   * HotelCardToHotelAmenity createMany
   */
  export type HotelCardToHotelAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCardToHotelAmenities.
     */
    data: HotelCardToHotelAmenityCreateManyInput | HotelCardToHotelAmenityCreateManyInput[]
  }

  /**
   * HotelCardToHotelAmenity createManyAndReturn
   */
  export type HotelCardToHotelAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many HotelCardToHotelAmenities.
     */
    data: HotelCardToHotelAmenityCreateManyInput | HotelCardToHotelAmenityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToHotelAmenity update
   */
  export type HotelCardToHotelAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCardToHotelAmenity.
     */
    data: XOR<HotelCardToHotelAmenityUpdateInput, HotelCardToHotelAmenityUncheckedUpdateInput>
    /**
     * Choose, which HotelCardToHotelAmenity to update.
     */
    where: HotelCardToHotelAmenityWhereUniqueInput
  }

  /**
   * HotelCardToHotelAmenity updateMany
   */
  export type HotelCardToHotelAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCardToHotelAmenities.
     */
    data: XOR<HotelCardToHotelAmenityUpdateManyMutationInput, HotelCardToHotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToHotelAmenities to update
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * Limit how many HotelCardToHotelAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelCardToHotelAmenity updateManyAndReturn
   */
  export type HotelCardToHotelAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to update HotelCardToHotelAmenities.
     */
    data: XOR<HotelCardToHotelAmenityUpdateManyMutationInput, HotelCardToHotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelCardToHotelAmenities to update
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * Limit how many HotelCardToHotelAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelCardToHotelAmenity upsert
   */
  export type HotelCardToHotelAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCardToHotelAmenity to update in case it exists.
     */
    where: HotelCardToHotelAmenityWhereUniqueInput
    /**
     * In case the HotelCardToHotelAmenity found by the `where` argument doesn't exist, create a new HotelCardToHotelAmenity with this data.
     */
    create: XOR<HotelCardToHotelAmenityCreateInput, HotelCardToHotelAmenityUncheckedCreateInput>
    /**
     * In case the HotelCardToHotelAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCardToHotelAmenityUpdateInput, HotelCardToHotelAmenityUncheckedUpdateInput>
  }

  /**
   * HotelCardToHotelAmenity delete
   */
  export type HotelCardToHotelAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
    /**
     * Filter which HotelCardToHotelAmenity to delete.
     */
    where: HotelCardToHotelAmenityWhereUniqueInput
  }

  /**
   * HotelCardToHotelAmenity deleteMany
   */
  export type HotelCardToHotelAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCardToHotelAmenities to delete
     */
    where?: HotelCardToHotelAmenityWhereInput
    /**
     * Limit how many HotelCardToHotelAmenities to delete.
     */
    limit?: number
  }

  /**
   * HotelCardToHotelAmenity without action
   */
  export type HotelCardToHotelAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCardToHotelAmenity
     */
    select?: HotelCardToHotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelCardToHotelAmenity
     */
    omit?: HotelCardToHotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCardToHotelAmenityInclude<ExtArgs> | null
  }


  /**
   * Model HotelDetailsToRoomAmenity
   */

  export type AggregateHotelDetailsToRoomAmenity = {
    _count: HotelDetailsToRoomAmenityCountAggregateOutputType | null
    _avg: HotelDetailsToRoomAmenityAvgAggregateOutputType | null
    _sum: HotelDetailsToRoomAmenitySumAggregateOutputType | null
    _min: HotelDetailsToRoomAmenityMinAggregateOutputType | null
    _max: HotelDetailsToRoomAmenityMaxAggregateOutputType | null
  }

  export type HotelDetailsToRoomAmenityAvgAggregateOutputType = {
    order: number | null
  }

  export type HotelDetailsToRoomAmenitySumAggregateOutputType = {
    order: number | null
  }

  export type HotelDetailsToRoomAmenityMinAggregateOutputType = {
    hotelDetailsId: string | null
    roomAmenityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelDetailsToRoomAmenityMaxAggregateOutputType = {
    hotelDetailsId: string | null
    roomAmenityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelDetailsToRoomAmenityCountAggregateOutputType = {
    hotelDetailsId: number
    roomAmenityId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelDetailsToRoomAmenityAvgAggregateInputType = {
    order?: true
  }

  export type HotelDetailsToRoomAmenitySumAggregateInputType = {
    order?: true
  }

  export type HotelDetailsToRoomAmenityMinAggregateInputType = {
    hotelDetailsId?: true
    roomAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelDetailsToRoomAmenityMaxAggregateInputType = {
    hotelDetailsId?: true
    roomAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelDetailsToRoomAmenityCountAggregateInputType = {
    hotelDetailsId?: true
    roomAmenityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelDetailsToRoomAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelDetailsToRoomAmenity to aggregate.
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetailsToRoomAmenities to fetch.
     */
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetailsToRoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetailsToRoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelDetailsToRoomAmenities
    **/
    _count?: true | HotelDetailsToRoomAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelDetailsToRoomAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelDetailsToRoomAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelDetailsToRoomAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelDetailsToRoomAmenityMaxAggregateInputType
  }

  export type GetHotelDetailsToRoomAmenityAggregateType<T extends HotelDetailsToRoomAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelDetailsToRoomAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelDetailsToRoomAmenity[P]>
      : GetScalarType<T[P], AggregateHotelDetailsToRoomAmenity[P]>
  }




  export type HotelDetailsToRoomAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelDetailsToRoomAmenityWhereInput
    orderBy?: HotelDetailsToRoomAmenityOrderByWithAggregationInput | HotelDetailsToRoomAmenityOrderByWithAggregationInput[]
    by: HotelDetailsToRoomAmenityScalarFieldEnum[] | HotelDetailsToRoomAmenityScalarFieldEnum
    having?: HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelDetailsToRoomAmenityCountAggregateInputType | true
    _avg?: HotelDetailsToRoomAmenityAvgAggregateInputType
    _sum?: HotelDetailsToRoomAmenitySumAggregateInputType
    _min?: HotelDetailsToRoomAmenityMinAggregateInputType
    _max?: HotelDetailsToRoomAmenityMaxAggregateInputType
  }

  export type HotelDetailsToRoomAmenityGroupByOutputType = {
    hotelDetailsId: string
    roomAmenityId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelDetailsToRoomAmenityCountAggregateOutputType | null
    _avg: HotelDetailsToRoomAmenityAvgAggregateOutputType | null
    _sum: HotelDetailsToRoomAmenitySumAggregateOutputType | null
    _min: HotelDetailsToRoomAmenityMinAggregateOutputType | null
    _max: HotelDetailsToRoomAmenityMaxAggregateOutputType | null
  }

  type GetHotelDetailsToRoomAmenityGroupByPayload<T extends HotelDetailsToRoomAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelDetailsToRoomAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelDetailsToRoomAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelDetailsToRoomAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], HotelDetailsToRoomAmenityGroupByOutputType[P]>
        }
      >
    >


  export type HotelDetailsToRoomAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelDetailsId?: boolean
    roomAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetailsToRoomAmenity"]>

  export type HotelDetailsToRoomAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelDetailsId?: boolean
    roomAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetailsToRoomAmenity"]>

  export type HotelDetailsToRoomAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelDetailsId?: boolean
    roomAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelDetailsToRoomAmenity"]>

  export type HotelDetailsToRoomAmenitySelectScalar = {
    hotelDetailsId?: boolean
    roomAmenityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelDetailsToRoomAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelDetailsId" | "roomAmenityId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["hotelDetailsToRoomAmenity"]>
  export type HotelDetailsToRoomAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }
  export type HotelDetailsToRoomAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }
  export type HotelDetailsToRoomAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotelDetails?: boolean | HotelDetailsDefaultArgs<ExtArgs>
    roomAmenity?: boolean | RoomAmenityDefaultArgs<ExtArgs>
  }

  export type $HotelDetailsToRoomAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelDetailsToRoomAmenity"
    objects: {
      hotelDetails: Prisma.$HotelDetailsPayload<ExtArgs>
      roomAmenity: Prisma.$RoomAmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelDetailsId: string
      roomAmenityId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotelDetailsToRoomAmenity"]>
    composites: {}
  }

  type HotelDetailsToRoomAmenityGetPayload<S extends boolean | null | undefined | HotelDetailsToRoomAmenityDefaultArgs> = $Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload, S>

  type HotelDetailsToRoomAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelDetailsToRoomAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelDetailsToRoomAmenityCountAggregateInputType | true
    }

  export interface HotelDetailsToRoomAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelDetailsToRoomAmenity'], meta: { name: 'HotelDetailsToRoomAmenity' } }
    /**
     * Find zero or one HotelDetailsToRoomAmenity that matches the filter.
     * @param {HotelDetailsToRoomAmenityFindUniqueArgs} args - Arguments to find a HotelDetailsToRoomAmenity
     * @example
     * // Get one HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelDetailsToRoomAmenityFindUniqueArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityFindUniqueArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelDetailsToRoomAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelDetailsToRoomAmenityFindUniqueOrThrowArgs} args - Arguments to find a HotelDetailsToRoomAmenity
     * @example
     * // Get one HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelDetailsToRoomAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelDetailsToRoomAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityFindFirstArgs} args - Arguments to find a HotelDetailsToRoomAmenity
     * @example
     * // Get one HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelDetailsToRoomAmenityFindFirstArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityFindFirstArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelDetailsToRoomAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityFindFirstOrThrowArgs} args - Arguments to find a HotelDetailsToRoomAmenity
     * @example
     * // Get one HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelDetailsToRoomAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelDetailsToRoomAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenities = await prisma.hotelDetailsToRoomAmenity.findMany()
     * 
     * // Get first 10 HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenities = await prisma.hotelDetailsToRoomAmenity.findMany({ take: 10 })
     * 
     * // Only select the `hotelDetailsId`
     * const hotelDetailsToRoomAmenityWithHotelDetailsIdOnly = await prisma.hotelDetailsToRoomAmenity.findMany({ select: { hotelDetailsId: true } })
     * 
     */
    findMany<T extends HotelDetailsToRoomAmenityFindManyArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelDetailsToRoomAmenity.
     * @param {HotelDetailsToRoomAmenityCreateArgs} args - Arguments to create a HotelDetailsToRoomAmenity.
     * @example
     * // Create one HotelDetailsToRoomAmenity
     * const HotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.create({
     *   data: {
     *     // ... data to create a HotelDetailsToRoomAmenity
     *   }
     * })
     * 
     */
    create<T extends HotelDetailsToRoomAmenityCreateArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityCreateArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelDetailsToRoomAmenities.
     * @param {HotelDetailsToRoomAmenityCreateManyArgs} args - Arguments to create many HotelDetailsToRoomAmenities.
     * @example
     * // Create many HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelDetailsToRoomAmenityCreateManyArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelDetailsToRoomAmenities and returns the data saved in the database.
     * @param {HotelDetailsToRoomAmenityCreateManyAndReturnArgs} args - Arguments to create many HotelDetailsToRoomAmenities.
     * @example
     * // Create many HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelDetailsToRoomAmenities and only return the `hotelDetailsId`
     * const hotelDetailsToRoomAmenityWithHotelDetailsIdOnly = await prisma.hotelDetailsToRoomAmenity.createManyAndReturn({
     *   select: { hotelDetailsId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelDetailsToRoomAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelDetailsToRoomAmenity.
     * @param {HotelDetailsToRoomAmenityDeleteArgs} args - Arguments to delete one HotelDetailsToRoomAmenity.
     * @example
     * // Delete one HotelDetailsToRoomAmenity
     * const HotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.delete({
     *   where: {
     *     // ... filter to delete one HotelDetailsToRoomAmenity
     *   }
     * })
     * 
     */
    delete<T extends HotelDetailsToRoomAmenityDeleteArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityDeleteArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelDetailsToRoomAmenity.
     * @param {HotelDetailsToRoomAmenityUpdateArgs} args - Arguments to update one HotelDetailsToRoomAmenity.
     * @example
     * // Update one HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelDetailsToRoomAmenityUpdateArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityUpdateArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelDetailsToRoomAmenities.
     * @param {HotelDetailsToRoomAmenityDeleteManyArgs} args - Arguments to filter HotelDetailsToRoomAmenities to delete.
     * @example
     * // Delete a few HotelDetailsToRoomAmenities
     * const { count } = await prisma.hotelDetailsToRoomAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDetailsToRoomAmenityDeleteManyArgs>(args?: SelectSubset<T, HotelDetailsToRoomAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelDetailsToRoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelDetailsToRoomAmenityUpdateManyArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelDetailsToRoomAmenities and returns the data updated in the database.
     * @param {HotelDetailsToRoomAmenityUpdateManyAndReturnArgs} args - Arguments to update many HotelDetailsToRoomAmenities.
     * @example
     * // Update many HotelDetailsToRoomAmenities
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelDetailsToRoomAmenities and only return the `hotelDetailsId`
     * const hotelDetailsToRoomAmenityWithHotelDetailsIdOnly = await prisma.hotelDetailsToRoomAmenity.updateManyAndReturn({
     *   select: { hotelDetailsId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelDetailsToRoomAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelDetailsToRoomAmenity.
     * @param {HotelDetailsToRoomAmenityUpsertArgs} args - Arguments to update or create a HotelDetailsToRoomAmenity.
     * @example
     * // Update or create a HotelDetailsToRoomAmenity
     * const hotelDetailsToRoomAmenity = await prisma.hotelDetailsToRoomAmenity.upsert({
     *   create: {
     *     // ... data to create a HotelDetailsToRoomAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelDetailsToRoomAmenity we want to update
     *   }
     * })
     */
    upsert<T extends HotelDetailsToRoomAmenityUpsertArgs>(args: SelectSubset<T, HotelDetailsToRoomAmenityUpsertArgs<ExtArgs>>): Prisma__HotelDetailsToRoomAmenityClient<$Result.GetResult<Prisma.$HotelDetailsToRoomAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelDetailsToRoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityCountArgs} args - Arguments to filter HotelDetailsToRoomAmenities to count.
     * @example
     * // Count the number of HotelDetailsToRoomAmenities
     * const count = await prisma.hotelDetailsToRoomAmenity.count({
     *   where: {
     *     // ... the filter for the HotelDetailsToRoomAmenities we want to count
     *   }
     * })
    **/
    count<T extends HotelDetailsToRoomAmenityCountArgs>(
      args?: Subset<T, HotelDetailsToRoomAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelDetailsToRoomAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelDetailsToRoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelDetailsToRoomAmenityAggregateArgs>(args: Subset<T, HotelDetailsToRoomAmenityAggregateArgs>): Prisma.PrismaPromise<GetHotelDetailsToRoomAmenityAggregateType<T>>

    /**
     * Group by HotelDetailsToRoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelDetailsToRoomAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelDetailsToRoomAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelDetailsToRoomAmenityGroupByArgs['orderBy'] }
        : { orderBy?: HotelDetailsToRoomAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelDetailsToRoomAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelDetailsToRoomAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelDetailsToRoomAmenity model
   */
  readonly fields: HotelDetailsToRoomAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelDetailsToRoomAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelDetailsToRoomAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotelDetails<T extends HotelDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDetailsDefaultArgs<ExtArgs>>): Prisma__HotelDetailsClient<$Result.GetResult<Prisma.$HotelDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roomAmenity<T extends RoomAmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomAmenityDefaultArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelDetailsToRoomAmenity model
   */
  interface HotelDetailsToRoomAmenityFieldRefs {
    readonly hotelDetailsId: FieldRef<"HotelDetailsToRoomAmenity", 'String'>
    readonly roomAmenityId: FieldRef<"HotelDetailsToRoomAmenity", 'String'>
    readonly order: FieldRef<"HotelDetailsToRoomAmenity", 'Int'>
    readonly createdAt: FieldRef<"HotelDetailsToRoomAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"HotelDetailsToRoomAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelDetailsToRoomAmenity findUnique
   */
  export type HotelDetailsToRoomAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetailsToRoomAmenity to fetch.
     */
    where: HotelDetailsToRoomAmenityWhereUniqueInput
  }

  /**
   * HotelDetailsToRoomAmenity findUniqueOrThrow
   */
  export type HotelDetailsToRoomAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetailsToRoomAmenity to fetch.
     */
    where: HotelDetailsToRoomAmenityWhereUniqueInput
  }

  /**
   * HotelDetailsToRoomAmenity findFirst
   */
  export type HotelDetailsToRoomAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetailsToRoomAmenity to fetch.
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetailsToRoomAmenities to fetch.
     */
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelDetailsToRoomAmenities.
     */
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetailsToRoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetailsToRoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelDetailsToRoomAmenities.
     */
    distinct?: HotelDetailsToRoomAmenityScalarFieldEnum | HotelDetailsToRoomAmenityScalarFieldEnum[]
  }

  /**
   * HotelDetailsToRoomAmenity findFirstOrThrow
   */
  export type HotelDetailsToRoomAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetailsToRoomAmenity to fetch.
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetailsToRoomAmenities to fetch.
     */
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelDetailsToRoomAmenities.
     */
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetailsToRoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetailsToRoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelDetailsToRoomAmenities.
     */
    distinct?: HotelDetailsToRoomAmenityScalarFieldEnum | HotelDetailsToRoomAmenityScalarFieldEnum[]
  }

  /**
   * HotelDetailsToRoomAmenity findMany
   */
  export type HotelDetailsToRoomAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelDetailsToRoomAmenities to fetch.
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelDetailsToRoomAmenities to fetch.
     */
    orderBy?: HotelDetailsToRoomAmenityOrderByWithRelationInput | HotelDetailsToRoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelDetailsToRoomAmenities.
     */
    cursor?: HotelDetailsToRoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelDetailsToRoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelDetailsToRoomAmenities.
     */
    skip?: number
    distinct?: HotelDetailsToRoomAmenityScalarFieldEnum | HotelDetailsToRoomAmenityScalarFieldEnum[]
  }

  /**
   * HotelDetailsToRoomAmenity create
   */
  export type HotelDetailsToRoomAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelDetailsToRoomAmenity.
     */
    data: XOR<HotelDetailsToRoomAmenityCreateInput, HotelDetailsToRoomAmenityUncheckedCreateInput>
  }

  /**
   * HotelDetailsToRoomAmenity createMany
   */
  export type HotelDetailsToRoomAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelDetailsToRoomAmenities.
     */
    data: HotelDetailsToRoomAmenityCreateManyInput | HotelDetailsToRoomAmenityCreateManyInput[]
  }

  /**
   * HotelDetailsToRoomAmenity createManyAndReturn
   */
  export type HotelDetailsToRoomAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many HotelDetailsToRoomAmenities.
     */
    data: HotelDetailsToRoomAmenityCreateManyInput | HotelDetailsToRoomAmenityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelDetailsToRoomAmenity update
   */
  export type HotelDetailsToRoomAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelDetailsToRoomAmenity.
     */
    data: XOR<HotelDetailsToRoomAmenityUpdateInput, HotelDetailsToRoomAmenityUncheckedUpdateInput>
    /**
     * Choose, which HotelDetailsToRoomAmenity to update.
     */
    where: HotelDetailsToRoomAmenityWhereUniqueInput
  }

  /**
   * HotelDetailsToRoomAmenity updateMany
   */
  export type HotelDetailsToRoomAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelDetailsToRoomAmenities.
     */
    data: XOR<HotelDetailsToRoomAmenityUpdateManyMutationInput, HotelDetailsToRoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelDetailsToRoomAmenities to update
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * Limit how many HotelDetailsToRoomAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelDetailsToRoomAmenity updateManyAndReturn
   */
  export type HotelDetailsToRoomAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to update HotelDetailsToRoomAmenities.
     */
    data: XOR<HotelDetailsToRoomAmenityUpdateManyMutationInput, HotelDetailsToRoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelDetailsToRoomAmenities to update
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * Limit how many HotelDetailsToRoomAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelDetailsToRoomAmenity upsert
   */
  export type HotelDetailsToRoomAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelDetailsToRoomAmenity to update in case it exists.
     */
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    /**
     * In case the HotelDetailsToRoomAmenity found by the `where` argument doesn't exist, create a new HotelDetailsToRoomAmenity with this data.
     */
    create: XOR<HotelDetailsToRoomAmenityCreateInput, HotelDetailsToRoomAmenityUncheckedCreateInput>
    /**
     * In case the HotelDetailsToRoomAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelDetailsToRoomAmenityUpdateInput, HotelDetailsToRoomAmenityUncheckedUpdateInput>
  }

  /**
   * HotelDetailsToRoomAmenity delete
   */
  export type HotelDetailsToRoomAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
    /**
     * Filter which HotelDetailsToRoomAmenity to delete.
     */
    where: HotelDetailsToRoomAmenityWhereUniqueInput
  }

  /**
   * HotelDetailsToRoomAmenity deleteMany
   */
  export type HotelDetailsToRoomAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelDetailsToRoomAmenities to delete
     */
    where?: HotelDetailsToRoomAmenityWhereInput
    /**
     * Limit how many HotelDetailsToRoomAmenities to delete.
     */
    limit?: number
  }

  /**
   * HotelDetailsToRoomAmenity without action
   */
  export type HotelDetailsToRoomAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelDetailsToRoomAmenity
     */
    select?: HotelDetailsToRoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelDetailsToRoomAmenity
     */
    omit?: HotelDetailsToRoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelDetailsToRoomAmenityInclude<ExtArgs> | null
  }


  /**
   * Model DestinationToCity
   */

  export type AggregateDestinationToCity = {
    _count: DestinationToCityCountAggregateOutputType | null
    _avg: DestinationToCityAvgAggregateOutputType | null
    _sum: DestinationToCitySumAggregateOutputType | null
    _min: DestinationToCityMinAggregateOutputType | null
    _max: DestinationToCityMaxAggregateOutputType | null
  }

  export type DestinationToCityAvgAggregateOutputType = {
    order: number | null
  }

  export type DestinationToCitySumAggregateOutputType = {
    order: number | null
  }

  export type DestinationToCityMinAggregateOutputType = {
    destinationId: string | null
    cityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationToCityMaxAggregateOutputType = {
    destinationId: string | null
    cityId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationToCityCountAggregateOutputType = {
    destinationId: number
    cityId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationToCityAvgAggregateInputType = {
    order?: true
  }

  export type DestinationToCitySumAggregateInputType = {
    order?: true
  }

  export type DestinationToCityMinAggregateInputType = {
    destinationId?: true
    cityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationToCityMaxAggregateInputType = {
    destinationId?: true
    cityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationToCityCountAggregateInputType = {
    destinationId?: true
    cityId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationToCityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationToCity to aggregate.
     */
    where?: DestinationToCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationToCities to fetch.
     */
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationToCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationToCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationToCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DestinationToCities
    **/
    _count?: true | DestinationToCityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinationToCityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinationToCitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationToCityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationToCityMaxAggregateInputType
  }

  export type GetDestinationToCityAggregateType<T extends DestinationToCityAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinationToCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinationToCity[P]>
      : GetScalarType<T[P], AggregateDestinationToCity[P]>
  }




  export type DestinationToCityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationToCityWhereInput
    orderBy?: DestinationToCityOrderByWithAggregationInput | DestinationToCityOrderByWithAggregationInput[]
    by: DestinationToCityScalarFieldEnum[] | DestinationToCityScalarFieldEnum
    having?: DestinationToCityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationToCityCountAggregateInputType | true
    _avg?: DestinationToCityAvgAggregateInputType
    _sum?: DestinationToCitySumAggregateInputType
    _min?: DestinationToCityMinAggregateInputType
    _max?: DestinationToCityMaxAggregateInputType
  }

  export type DestinationToCityGroupByOutputType = {
    destinationId: string
    cityId: string
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: DestinationToCityCountAggregateOutputType | null
    _avg: DestinationToCityAvgAggregateOutputType | null
    _sum: DestinationToCitySumAggregateOutputType | null
    _min: DestinationToCityMinAggregateOutputType | null
    _max: DestinationToCityMaxAggregateOutputType | null
  }

  type GetDestinationToCityGroupByPayload<T extends DestinationToCityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationToCityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationToCityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationToCityGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationToCityGroupByOutputType[P]>
        }
      >
    >


  export type DestinationToCitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    destinationId?: boolean
    cityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destinationToCity"]>

  export type DestinationToCitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    destinationId?: boolean
    cityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destinationToCity"]>

  export type DestinationToCitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    destinationId?: boolean
    cityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destinationToCity"]>

  export type DestinationToCitySelectScalar = {
    destinationId?: boolean
    cityId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationToCityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"destinationId" | "cityId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["destinationToCity"]>
  export type DestinationToCityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type DestinationToCityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type DestinationToCityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $DestinationToCityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DestinationToCity"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      destinationId: string
      cityId: string
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destinationToCity"]>
    composites: {}
  }

  type DestinationToCityGetPayload<S extends boolean | null | undefined | DestinationToCityDefaultArgs> = $Result.GetResult<Prisma.$DestinationToCityPayload, S>

  type DestinationToCityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationToCityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationToCityCountAggregateInputType | true
    }

  export interface DestinationToCityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DestinationToCity'], meta: { name: 'DestinationToCity' } }
    /**
     * Find zero or one DestinationToCity that matches the filter.
     * @param {DestinationToCityFindUniqueArgs} args - Arguments to find a DestinationToCity
     * @example
     * // Get one DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationToCityFindUniqueArgs>(args: SelectSubset<T, DestinationToCityFindUniqueArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DestinationToCity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationToCityFindUniqueOrThrowArgs} args - Arguments to find a DestinationToCity
     * @example
     * // Get one DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationToCityFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationToCityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationToCity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityFindFirstArgs} args - Arguments to find a DestinationToCity
     * @example
     * // Get one DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationToCityFindFirstArgs>(args?: SelectSubset<T, DestinationToCityFindFirstArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DestinationToCity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityFindFirstOrThrowArgs} args - Arguments to find a DestinationToCity
     * @example
     * // Get one DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationToCityFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationToCityFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DestinationToCities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DestinationToCities
     * const destinationToCities = await prisma.destinationToCity.findMany()
     * 
     * // Get first 10 DestinationToCities
     * const destinationToCities = await prisma.destinationToCity.findMany({ take: 10 })
     * 
     * // Only select the `destinationId`
     * const destinationToCityWithDestinationIdOnly = await prisma.destinationToCity.findMany({ select: { destinationId: true } })
     * 
     */
    findMany<T extends DestinationToCityFindManyArgs>(args?: SelectSubset<T, DestinationToCityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DestinationToCity.
     * @param {DestinationToCityCreateArgs} args - Arguments to create a DestinationToCity.
     * @example
     * // Create one DestinationToCity
     * const DestinationToCity = await prisma.destinationToCity.create({
     *   data: {
     *     // ... data to create a DestinationToCity
     *   }
     * })
     * 
     */
    create<T extends DestinationToCityCreateArgs>(args: SelectSubset<T, DestinationToCityCreateArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DestinationToCities.
     * @param {DestinationToCityCreateManyArgs} args - Arguments to create many DestinationToCities.
     * @example
     * // Create many DestinationToCities
     * const destinationToCity = await prisma.destinationToCity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationToCityCreateManyArgs>(args?: SelectSubset<T, DestinationToCityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DestinationToCities and returns the data saved in the database.
     * @param {DestinationToCityCreateManyAndReturnArgs} args - Arguments to create many DestinationToCities.
     * @example
     * // Create many DestinationToCities
     * const destinationToCity = await prisma.destinationToCity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DestinationToCities and only return the `destinationId`
     * const destinationToCityWithDestinationIdOnly = await prisma.destinationToCity.createManyAndReturn({
     *   select: { destinationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationToCityCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationToCityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DestinationToCity.
     * @param {DestinationToCityDeleteArgs} args - Arguments to delete one DestinationToCity.
     * @example
     * // Delete one DestinationToCity
     * const DestinationToCity = await prisma.destinationToCity.delete({
     *   where: {
     *     // ... filter to delete one DestinationToCity
     *   }
     * })
     * 
     */
    delete<T extends DestinationToCityDeleteArgs>(args: SelectSubset<T, DestinationToCityDeleteArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DestinationToCity.
     * @param {DestinationToCityUpdateArgs} args - Arguments to update one DestinationToCity.
     * @example
     * // Update one DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationToCityUpdateArgs>(args: SelectSubset<T, DestinationToCityUpdateArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DestinationToCities.
     * @param {DestinationToCityDeleteManyArgs} args - Arguments to filter DestinationToCities to delete.
     * @example
     * // Delete a few DestinationToCities
     * const { count } = await prisma.destinationToCity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationToCityDeleteManyArgs>(args?: SelectSubset<T, DestinationToCityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationToCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DestinationToCities
     * const destinationToCity = await prisma.destinationToCity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationToCityUpdateManyArgs>(args: SelectSubset<T, DestinationToCityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinationToCities and returns the data updated in the database.
     * @param {DestinationToCityUpdateManyAndReturnArgs} args - Arguments to update many DestinationToCities.
     * @example
     * // Update many DestinationToCities
     * const destinationToCity = await prisma.destinationToCity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DestinationToCities and only return the `destinationId`
     * const destinationToCityWithDestinationIdOnly = await prisma.destinationToCity.updateManyAndReturn({
     *   select: { destinationId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationToCityUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationToCityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DestinationToCity.
     * @param {DestinationToCityUpsertArgs} args - Arguments to update or create a DestinationToCity.
     * @example
     * // Update or create a DestinationToCity
     * const destinationToCity = await prisma.destinationToCity.upsert({
     *   create: {
     *     // ... data to create a DestinationToCity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DestinationToCity we want to update
     *   }
     * })
     */
    upsert<T extends DestinationToCityUpsertArgs>(args: SelectSubset<T, DestinationToCityUpsertArgs<ExtArgs>>): Prisma__DestinationToCityClient<$Result.GetResult<Prisma.$DestinationToCityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DestinationToCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityCountArgs} args - Arguments to filter DestinationToCities to count.
     * @example
     * // Count the number of DestinationToCities
     * const count = await prisma.destinationToCity.count({
     *   where: {
     *     // ... the filter for the DestinationToCities we want to count
     *   }
     * })
    **/
    count<T extends DestinationToCityCountArgs>(
      args?: Subset<T, DestinationToCityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationToCityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DestinationToCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationToCityAggregateArgs>(args: Subset<T, DestinationToCityAggregateArgs>): Prisma.PrismaPromise<GetDestinationToCityAggregateType<T>>

    /**
     * Group by DestinationToCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationToCityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationToCityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationToCityGroupByArgs['orderBy'] }
        : { orderBy?: DestinationToCityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationToCityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationToCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DestinationToCity model
   */
  readonly fields: DestinationToCityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DestinationToCity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationToCityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DestinationToCity model
   */
  interface DestinationToCityFieldRefs {
    readonly destinationId: FieldRef<"DestinationToCity", 'String'>
    readonly cityId: FieldRef<"DestinationToCity", 'String'>
    readonly order: FieldRef<"DestinationToCity", 'Int'>
    readonly createdAt: FieldRef<"DestinationToCity", 'DateTime'>
    readonly updatedAt: FieldRef<"DestinationToCity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DestinationToCity findUnique
   */
  export type DestinationToCityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter, which DestinationToCity to fetch.
     */
    where: DestinationToCityWhereUniqueInput
  }

  /**
   * DestinationToCity findUniqueOrThrow
   */
  export type DestinationToCityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter, which DestinationToCity to fetch.
     */
    where: DestinationToCityWhereUniqueInput
  }

  /**
   * DestinationToCity findFirst
   */
  export type DestinationToCityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter, which DestinationToCity to fetch.
     */
    where?: DestinationToCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationToCities to fetch.
     */
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationToCities.
     */
    cursor?: DestinationToCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationToCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationToCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationToCities.
     */
    distinct?: DestinationToCityScalarFieldEnum | DestinationToCityScalarFieldEnum[]
  }

  /**
   * DestinationToCity findFirstOrThrow
   */
  export type DestinationToCityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter, which DestinationToCity to fetch.
     */
    where?: DestinationToCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationToCities to fetch.
     */
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinationToCities.
     */
    cursor?: DestinationToCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationToCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationToCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinationToCities.
     */
    distinct?: DestinationToCityScalarFieldEnum | DestinationToCityScalarFieldEnum[]
  }

  /**
   * DestinationToCity findMany
   */
  export type DestinationToCityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter, which DestinationToCities to fetch.
     */
    where?: DestinationToCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinationToCities to fetch.
     */
    orderBy?: DestinationToCityOrderByWithRelationInput | DestinationToCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DestinationToCities.
     */
    cursor?: DestinationToCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinationToCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinationToCities.
     */
    skip?: number
    distinct?: DestinationToCityScalarFieldEnum | DestinationToCityScalarFieldEnum[]
  }

  /**
   * DestinationToCity create
   */
  export type DestinationToCityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * The data needed to create a DestinationToCity.
     */
    data: XOR<DestinationToCityCreateInput, DestinationToCityUncheckedCreateInput>
  }

  /**
   * DestinationToCity createMany
   */
  export type DestinationToCityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DestinationToCities.
     */
    data: DestinationToCityCreateManyInput | DestinationToCityCreateManyInput[]
  }

  /**
   * DestinationToCity createManyAndReturn
   */
  export type DestinationToCityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * The data used to create many DestinationToCities.
     */
    data: DestinationToCityCreateManyInput | DestinationToCityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DestinationToCity update
   */
  export type DestinationToCityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * The data needed to update a DestinationToCity.
     */
    data: XOR<DestinationToCityUpdateInput, DestinationToCityUncheckedUpdateInput>
    /**
     * Choose, which DestinationToCity to update.
     */
    where: DestinationToCityWhereUniqueInput
  }

  /**
   * DestinationToCity updateMany
   */
  export type DestinationToCityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DestinationToCities.
     */
    data: XOR<DestinationToCityUpdateManyMutationInput, DestinationToCityUncheckedUpdateManyInput>
    /**
     * Filter which DestinationToCities to update
     */
    where?: DestinationToCityWhereInput
    /**
     * Limit how many DestinationToCities to update.
     */
    limit?: number
  }

  /**
   * DestinationToCity updateManyAndReturn
   */
  export type DestinationToCityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * The data used to update DestinationToCities.
     */
    data: XOR<DestinationToCityUpdateManyMutationInput, DestinationToCityUncheckedUpdateManyInput>
    /**
     * Filter which DestinationToCities to update
     */
    where?: DestinationToCityWhereInput
    /**
     * Limit how many DestinationToCities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DestinationToCity upsert
   */
  export type DestinationToCityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * The filter to search for the DestinationToCity to update in case it exists.
     */
    where: DestinationToCityWhereUniqueInput
    /**
     * In case the DestinationToCity found by the `where` argument doesn't exist, create a new DestinationToCity with this data.
     */
    create: XOR<DestinationToCityCreateInput, DestinationToCityUncheckedCreateInput>
    /**
     * In case the DestinationToCity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationToCityUpdateInput, DestinationToCityUncheckedUpdateInput>
  }

  /**
   * DestinationToCity delete
   */
  export type DestinationToCityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
    /**
     * Filter which DestinationToCity to delete.
     */
    where: DestinationToCityWhereUniqueInput
  }

  /**
   * DestinationToCity deleteMany
   */
  export type DestinationToCityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DestinationToCities to delete
     */
    where?: DestinationToCityWhereInput
    /**
     * Limit how many DestinationToCities to delete.
     */
    limit?: number
  }

  /**
   * DestinationToCity without action
   */
  export type DestinationToCityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationToCity
     */
    select?: DestinationToCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DestinationToCity
     */
    omit?: DestinationToCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationToCityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    code: 'code',
    language: 'language',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    countryId: 'countryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const NeighborhoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NeighborhoodScalarFieldEnum = (typeof NeighborhoodScalarFieldEnum)[keyof typeof NeighborhoodScalarFieldEnum]


  export const LandmarkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    description: 'description',
    type: 'type',
    cityId: 'cityId',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandmarkScalarFieldEnum = (typeof LandmarkScalarFieldEnum)[keyof typeof LandmarkScalarFieldEnum]


  export const AccommodationTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    code: 'code',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccommodationTypeScalarFieldEnum = (typeof AccommodationTypeScalarFieldEnum)[keyof typeof AccommodationTypeScalarFieldEnum]


  export const DestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    description: 'description',
    type: 'type',
    popularityScore: 'popularityScore',
    cityId: 'cityId',
    latitude: 'latitude',
    longitude: 'longitude',
    radius: 'radius',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationScalarFieldEnum = (typeof DestinationScalarFieldEnum)[keyof typeof DestinationScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    code: 'code',
    description: 'description',
    category: 'category',
    icon: 'icon',
    color: 'color',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelDetailsId: 'hotelDetailsId'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const HotelGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    description: 'description',
    website: 'website',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelGroupScalarFieldEnum = (typeof HotelGroupScalarFieldEnum)[keyof typeof HotelGroupScalarFieldEnum]


  export const HotelHighlightScalarFieldEnum: {
    id: 'id',
    title: 'title',
    order: 'order',
    description: 'description',
    category: 'category',
    icon: 'icon',
    priority: 'priority',
    isPromoted: 'isPromoted',
    hotelId: 'hotelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelHighlightScalarFieldEnum = (typeof HotelHighlightScalarFieldEnum)[keyof typeof HotelHighlightScalarFieldEnum]


  export const HotelAmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    category: 'category',
    icon: 'icon',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelAmenityScalarFieldEnum = (typeof HotelAmenityScalarFieldEnum)[keyof typeof HotelAmenityScalarFieldEnum]


  export const RoomAmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    category: 'category',
    icon: 'icon',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomAmenityScalarFieldEnum = (typeof RoomAmenityScalarFieldEnum)[keyof typeof RoomAmenityScalarFieldEnum]


  export const AccessibilityOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    code: 'code',
    description: 'description',
    category: 'category',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccessibilityOptionScalarFieldEnum = (typeof AccessibilityOptionScalarFieldEnum)[keyof typeof AccessibilityOptionScalarFieldEnum]


  export const HotelParkingScalarFieldEnum: {
    id: 'id',
    isAvailable: 'isAvailable',
    spaces: 'spaces',
    order: 'order',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelParkingScalarFieldEnum = (typeof HotelParkingScalarFieldEnum)[keyof typeof HotelParkingScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    streetNumber: 'streetNumber',
    streetName: 'streetName',
    addressLine2: 'addressLine2',
    postalCode: 'postalCode',
    cityId: 'cityId',
    neighborhoodId: 'neighborhoodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const HotelImageScalarFieldEnum: {
    id: 'id',
    entityId: 'entityId',
    imageUrl: 'imageUrl',
    imageType: 'imageType',
    order: 'order',
    alt: 'alt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelImageScalarFieldEnum = (typeof HotelImageScalarFieldEnum)[keyof typeof HotelImageScalarFieldEnum]


  export const HotelCardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    idCity: 'idCity',
    order: 'order',
    shortDescription: 'shortDescription',
    starRating: 'starRating',
    overallRating: 'overallRating',
    ratingAdjective: 'ratingAdjective',
    reviewCount: 'reviewCount',
    basePricePerNight: 'basePricePerNight',
    regularPrice: 'regularPrice',
    currency: 'currency',
    isPartner: 'isPartner',
    promoMessage: 'promoMessage',
    imageMessage: 'imageMessage',
    cancellationPolicy: 'cancellationPolicy',
    accommodationTypeId: 'accommodationTypeId',
    destinationId: 'destinationId',
    hotelGroupId: 'hotelGroupId',
    latitude: 'latitude',
    longitude: 'longitude',
    detailsId: 'detailsId'
  };

  export type HotelCardScalarFieldEnum = (typeof HotelCardScalarFieldEnum)[keyof typeof HotelCardScalarFieldEnum]


  export const HotelDetailsScalarFieldEnum: {
    id: 'id',
    idHotelCard: 'idHotelCard',
    description: 'description',
    addressId: 'addressId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelDetailsScalarFieldEnum = (typeof HotelDetailsScalarFieldEnum)[keyof typeof HotelDetailsScalarFieldEnum]


  export const HotelCardToHotelHighlightScalarFieldEnum: {
    hotelCardId: 'hotelCardId',
    hotelHighlightId: 'hotelHighlightId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelCardToHotelHighlightScalarFieldEnum = (typeof HotelCardToHotelHighlightScalarFieldEnum)[keyof typeof HotelCardToHotelHighlightScalarFieldEnum]


  export const HotelCardToLabelScalarFieldEnum: {
    hotelCardId: 'hotelCardId',
    labelId: 'labelId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelCardToLabelScalarFieldEnum = (typeof HotelCardToLabelScalarFieldEnum)[keyof typeof HotelCardToLabelScalarFieldEnum]


  export const HotelCardToAccessibilityOptionScalarFieldEnum: {
    hotelCardId: 'hotelCardId',
    accessibilityOptionId: 'accessibilityOptionId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelCardToAccessibilityOptionScalarFieldEnum = (typeof HotelCardToAccessibilityOptionScalarFieldEnum)[keyof typeof HotelCardToAccessibilityOptionScalarFieldEnum]


  export const HotelCardToHotelAmenityScalarFieldEnum: {
    hotelCardId: 'hotelCardId',
    hotelAmenityId: 'hotelAmenityId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelCardToHotelAmenityScalarFieldEnum = (typeof HotelCardToHotelAmenityScalarFieldEnum)[keyof typeof HotelCardToHotelAmenityScalarFieldEnum]


  export const HotelDetailsToRoomAmenityScalarFieldEnum: {
    hotelDetailsId: 'hotelDetailsId',
    roomAmenityId: 'roomAmenityId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelDetailsToRoomAmenityScalarFieldEnum = (typeof HotelDetailsToRoomAmenityScalarFieldEnum)[keyof typeof HotelDetailsToRoomAmenityScalarFieldEnum]


  export const DestinationToCityScalarFieldEnum: {
    destinationId: 'destinationId',
    cityId: 'cityId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationToCityScalarFieldEnum = (typeof DestinationToCityScalarFieldEnum)[keyof typeof DestinationToCityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    Address?: AddressListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    Address?: AddressOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    Address?: AddressListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    order?: IntNullableFilter<"Country"> | number | null
    code?: StringFilter<"Country"> | string
    language?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    cities?: CityListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    language?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cities?: CityOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    order?: IntNullableFilter<"Country"> | number | null
    language?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    cities?: CityListRelationFilter
  }, "id" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    language?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    order?: IntNullableWithAggregatesFilter<"Country"> | number | null
    code?: StringWithAggregatesFilter<"Country"> | string
    language?: StringNullableWithAggregatesFilter<"Country"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Country"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    order?: IntNullableFilter<"City"> | number | null
    countryId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    neighborhoods?: NeighborhoodListRelationFilter
    landmarks?: LandmarkListRelationFilter
    addresses?: AddressListRelationFilter
    destinations?: DestinationListRelationFilter
    DestinationToCity?: DestinationToCityListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    country?: CountryOrderByWithRelationInput
    neighborhoods?: NeighborhoodOrderByRelationAggregateInput
    landmarks?: LandmarkOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    destinations?: DestinationOrderByRelationAggregateInput
    DestinationToCity?: DestinationToCityOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    order?: IntNullableFilter<"City"> | number | null
    countryId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    neighborhoods?: NeighborhoodListRelationFilter
    landmarks?: LandmarkListRelationFilter
    addresses?: AddressListRelationFilter
    destinations?: DestinationListRelationFilter
    DestinationToCity?: DestinationToCityListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    order?: IntNullableWithAggregatesFilter<"City"> | number | null
    countryId?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type NeighborhoodWhereInput = {
    AND?: NeighborhoodWhereInput | NeighborhoodWhereInput[]
    OR?: NeighborhoodWhereInput[]
    NOT?: NeighborhoodWhereInput | NeighborhoodWhereInput[]
    id?: StringFilter<"Neighborhood"> | string
    name?: StringFilter<"Neighborhood"> | string
    order?: IntNullableFilter<"Neighborhood"> | number | null
    cityId?: StringFilter<"Neighborhood"> | string
    createdAt?: DateTimeFilter<"Neighborhood"> | Date | string
    updatedAt?: DateTimeFilter<"Neighborhood"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    addresses?: AddressListRelationFilter
  }

  export type NeighborhoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type NeighborhoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NeighborhoodWhereInput | NeighborhoodWhereInput[]
    OR?: NeighborhoodWhereInput[]
    NOT?: NeighborhoodWhereInput | NeighborhoodWhereInput[]
    name?: StringFilter<"Neighborhood"> | string
    order?: IntNullableFilter<"Neighborhood"> | number | null
    cityId?: StringFilter<"Neighborhood"> | string
    createdAt?: DateTimeFilter<"Neighborhood"> | Date | string
    updatedAt?: DateTimeFilter<"Neighborhood"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    addresses?: AddressListRelationFilter
  }, "id">

  export type NeighborhoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NeighborhoodCountOrderByAggregateInput
    _avg?: NeighborhoodAvgOrderByAggregateInput
    _max?: NeighborhoodMaxOrderByAggregateInput
    _min?: NeighborhoodMinOrderByAggregateInput
    _sum?: NeighborhoodSumOrderByAggregateInput
  }

  export type NeighborhoodScalarWhereWithAggregatesInput = {
    AND?: NeighborhoodScalarWhereWithAggregatesInput | NeighborhoodScalarWhereWithAggregatesInput[]
    OR?: NeighborhoodScalarWhereWithAggregatesInput[]
    NOT?: NeighborhoodScalarWhereWithAggregatesInput | NeighborhoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Neighborhood"> | string
    name?: StringWithAggregatesFilter<"Neighborhood"> | string
    order?: IntNullableWithAggregatesFilter<"Neighborhood"> | number | null
    cityId?: StringWithAggregatesFilter<"Neighborhood"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Neighborhood"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Neighborhood"> | Date | string
  }

  export type LandmarkWhereInput = {
    AND?: LandmarkWhereInput | LandmarkWhereInput[]
    OR?: LandmarkWhereInput[]
    NOT?: LandmarkWhereInput | LandmarkWhereInput[]
    id?: StringFilter<"Landmark"> | string
    name?: StringFilter<"Landmark"> | string
    order?: IntNullableFilter<"Landmark"> | number | null
    description?: StringNullableFilter<"Landmark"> | string | null
    type?: StringFilter<"Landmark"> | string
    cityId?: StringFilter<"Landmark"> | string
    latitude?: FloatNullableFilter<"Landmark"> | number | null
    longitude?: FloatNullableFilter<"Landmark"> | number | null
    createdAt?: DateTimeFilter<"Landmark"> | Date | string
    updatedAt?: DateTimeFilter<"Landmark"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type LandmarkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type LandmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LandmarkWhereInput | LandmarkWhereInput[]
    OR?: LandmarkWhereInput[]
    NOT?: LandmarkWhereInput | LandmarkWhereInput[]
    name?: StringFilter<"Landmark"> | string
    order?: IntNullableFilter<"Landmark"> | number | null
    description?: StringNullableFilter<"Landmark"> | string | null
    type?: StringFilter<"Landmark"> | string
    cityId?: StringFilter<"Landmark"> | string
    latitude?: FloatNullableFilter<"Landmark"> | number | null
    longitude?: FloatNullableFilter<"Landmark"> | number | null
    createdAt?: DateTimeFilter<"Landmark"> | Date | string
    updatedAt?: DateTimeFilter<"Landmark"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type LandmarkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandmarkCountOrderByAggregateInput
    _avg?: LandmarkAvgOrderByAggregateInput
    _max?: LandmarkMaxOrderByAggregateInput
    _min?: LandmarkMinOrderByAggregateInput
    _sum?: LandmarkSumOrderByAggregateInput
  }

  export type LandmarkScalarWhereWithAggregatesInput = {
    AND?: LandmarkScalarWhereWithAggregatesInput | LandmarkScalarWhereWithAggregatesInput[]
    OR?: LandmarkScalarWhereWithAggregatesInput[]
    NOT?: LandmarkScalarWhereWithAggregatesInput | LandmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Landmark"> | string
    name?: StringWithAggregatesFilter<"Landmark"> | string
    order?: IntNullableWithAggregatesFilter<"Landmark"> | number | null
    description?: StringNullableWithAggregatesFilter<"Landmark"> | string | null
    type?: StringWithAggregatesFilter<"Landmark"> | string
    cityId?: StringWithAggregatesFilter<"Landmark"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Landmark"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Landmark"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Landmark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Landmark"> | Date | string
  }

  export type AccommodationTypeWhereInput = {
    AND?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    OR?: AccommodationTypeWhereInput[]
    NOT?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    id?: StringFilter<"AccommodationType"> | string
    name?: StringFilter<"AccommodationType"> | string
    order?: IntNullableFilter<"AccommodationType"> | number | null
    code?: StringFilter<"AccommodationType"> | string
    description?: StringNullableFilter<"AccommodationType"> | string | null
    category?: StringFilter<"AccommodationType"> | string
    createdAt?: DateTimeFilter<"AccommodationType"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationType"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }

  export type AccommodationTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
  }

  export type AccommodationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    OR?: AccommodationTypeWhereInput[]
    NOT?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    name?: StringFilter<"AccommodationType"> | string
    order?: IntNullableFilter<"AccommodationType"> | number | null
    description?: StringNullableFilter<"AccommodationType"> | string | null
    category?: StringFilter<"AccommodationType"> | string
    createdAt?: DateTimeFilter<"AccommodationType"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationType"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }, "id" | "code">

  export type AccommodationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccommodationTypeCountOrderByAggregateInput
    _avg?: AccommodationTypeAvgOrderByAggregateInput
    _max?: AccommodationTypeMaxOrderByAggregateInput
    _min?: AccommodationTypeMinOrderByAggregateInput
    _sum?: AccommodationTypeSumOrderByAggregateInput
  }

  export type AccommodationTypeScalarWhereWithAggregatesInput = {
    AND?: AccommodationTypeScalarWhereWithAggregatesInput | AccommodationTypeScalarWhereWithAggregatesInput[]
    OR?: AccommodationTypeScalarWhereWithAggregatesInput[]
    NOT?: AccommodationTypeScalarWhereWithAggregatesInput | AccommodationTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccommodationType"> | string
    name?: StringWithAggregatesFilter<"AccommodationType"> | string
    order?: IntNullableWithAggregatesFilter<"AccommodationType"> | number | null
    code?: StringWithAggregatesFilter<"AccommodationType"> | string
    description?: StringNullableWithAggregatesFilter<"AccommodationType"> | string | null
    category?: StringWithAggregatesFilter<"AccommodationType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccommodationType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccommodationType"> | Date | string
  }

  export type DestinationWhereInput = {
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    order?: IntNullableFilter<"Destination"> | number | null
    description?: StringNullableFilter<"Destination"> | string | null
    type?: StringFilter<"Destination"> | string
    popularityScore?: IntFilter<"Destination"> | number
    cityId?: StringFilter<"Destination"> | string
    latitude?: FloatNullableFilter<"Destination"> | number | null
    longitude?: FloatNullableFilter<"Destination"> | number | null
    radius?: FloatNullableFilter<"Destination"> | number | null
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    HotelCard?: HotelCardListRelationFilter
    City?: CityListRelationFilter
    DestinationToCity?: DestinationToCityListRelationFilter
  }

  export type DestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    popularityScore?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
    City?: CityOrderByRelationAggregateInput
    DestinationToCity?: DestinationToCityOrderByRelationAggregateInput
  }

  export type DestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    name?: StringFilter<"Destination"> | string
    order?: IntNullableFilter<"Destination"> | number | null
    description?: StringNullableFilter<"Destination"> | string | null
    type?: StringFilter<"Destination"> | string
    popularityScore?: IntFilter<"Destination"> | number
    cityId?: StringFilter<"Destination"> | string
    latitude?: FloatNullableFilter<"Destination"> | number | null
    longitude?: FloatNullableFilter<"Destination"> | number | null
    radius?: FloatNullableFilter<"Destination"> | number | null
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    HotelCard?: HotelCardListRelationFilter
    City?: CityListRelationFilter
    DestinationToCity?: DestinationToCityListRelationFilter
  }, "id">

  export type DestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    popularityScore?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationCountOrderByAggregateInput
    _avg?: DestinationAvgOrderByAggregateInput
    _max?: DestinationMaxOrderByAggregateInput
    _min?: DestinationMinOrderByAggregateInput
    _sum?: DestinationSumOrderByAggregateInput
  }

  export type DestinationScalarWhereWithAggregatesInput = {
    AND?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    OR?: DestinationScalarWhereWithAggregatesInput[]
    NOT?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Destination"> | string
    name?: StringWithAggregatesFilter<"Destination"> | string
    order?: IntNullableWithAggregatesFilter<"Destination"> | number | null
    description?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    type?: StringWithAggregatesFilter<"Destination"> | string
    popularityScore?: IntWithAggregatesFilter<"Destination"> | number
    cityId?: StringWithAggregatesFilter<"Destination"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Destination"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Destination"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"Destination"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    order?: IntNullableFilter<"Label"> | number | null
    code?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    category?: StringFilter<"Label"> | string
    icon?: StringNullableFilter<"Label"> | string | null
    color?: StringNullableFilter<"Label"> | string | null
    priority?: IntFilter<"Label"> | number
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    hotelDetailsId?: StringNullableFilter<"Label"> | string | null
    HotelDetails?: XOR<HotelDetailsNullableScalarRelationFilter, HotelDetailsWhereInput> | null
    HotelCardToLabel?: HotelCardToLabelListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetailsId?: SortOrderInput | SortOrder
    HotelDetails?: HotelDetailsOrderByWithRelationInput
    HotelCardToLabel?: HotelCardToLabelOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    name?: StringFilter<"Label"> | string
    order?: IntNullableFilter<"Label"> | number | null
    description?: StringNullableFilter<"Label"> | string | null
    category?: StringFilter<"Label"> | string
    icon?: StringNullableFilter<"Label"> | string | null
    color?: StringNullableFilter<"Label"> | string | null
    priority?: IntFilter<"Label"> | number
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    hotelDetailsId?: StringNullableFilter<"Label"> | string | null
    HotelDetails?: XOR<HotelDetailsNullableScalarRelationFilter, HotelDetailsWhereInput> | null
    HotelCardToLabel?: HotelCardToLabelListRelationFilter
  }, "id" | "code">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetailsId?: SortOrderInput | SortOrder
    _count?: LabelCountOrderByAggregateInput
    _avg?: LabelAvgOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
    _sum?: LabelSumOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Label"> | string
    name?: StringWithAggregatesFilter<"Label"> | string
    order?: IntNullableWithAggregatesFilter<"Label"> | number | null
    code?: StringWithAggregatesFilter<"Label"> | string
    description?: StringNullableWithAggregatesFilter<"Label"> | string | null
    category?: StringWithAggregatesFilter<"Label"> | string
    icon?: StringNullableWithAggregatesFilter<"Label"> | string | null
    color?: StringNullableWithAggregatesFilter<"Label"> | string | null
    priority?: IntWithAggregatesFilter<"Label"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    hotelDetailsId?: StringNullableWithAggregatesFilter<"Label"> | string | null
  }

  export type HotelGroupWhereInput = {
    AND?: HotelGroupWhereInput | HotelGroupWhereInput[]
    OR?: HotelGroupWhereInput[]
    NOT?: HotelGroupWhereInput | HotelGroupWhereInput[]
    id?: StringFilter<"HotelGroup"> | string
    name?: StringFilter<"HotelGroup"> | string
    order?: IntNullableFilter<"HotelGroup"> | number | null
    description?: StringNullableFilter<"HotelGroup"> | string | null
    website?: StringNullableFilter<"HotelGroup"> | string | null
    logoUrl?: StringNullableFilter<"HotelGroup"> | string | null
    createdAt?: DateTimeFilter<"HotelGroup"> | Date | string
    updatedAt?: DateTimeFilter<"HotelGroup"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }

  export type HotelGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
  }

  export type HotelGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelGroupWhereInput | HotelGroupWhereInput[]
    OR?: HotelGroupWhereInput[]
    NOT?: HotelGroupWhereInput | HotelGroupWhereInput[]
    name?: StringFilter<"HotelGroup"> | string
    order?: IntNullableFilter<"HotelGroup"> | number | null
    description?: StringNullableFilter<"HotelGroup"> | string | null
    website?: StringNullableFilter<"HotelGroup"> | string | null
    logoUrl?: StringNullableFilter<"HotelGroup"> | string | null
    createdAt?: DateTimeFilter<"HotelGroup"> | Date | string
    updatedAt?: DateTimeFilter<"HotelGroup"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }, "id">

  export type HotelGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelGroupCountOrderByAggregateInput
    _avg?: HotelGroupAvgOrderByAggregateInput
    _max?: HotelGroupMaxOrderByAggregateInput
    _min?: HotelGroupMinOrderByAggregateInput
    _sum?: HotelGroupSumOrderByAggregateInput
  }

  export type HotelGroupScalarWhereWithAggregatesInput = {
    AND?: HotelGroupScalarWhereWithAggregatesInput | HotelGroupScalarWhereWithAggregatesInput[]
    OR?: HotelGroupScalarWhereWithAggregatesInput[]
    NOT?: HotelGroupScalarWhereWithAggregatesInput | HotelGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelGroup"> | string
    name?: StringWithAggregatesFilter<"HotelGroup"> | string
    order?: IntNullableWithAggregatesFilter<"HotelGroup"> | number | null
    description?: StringNullableWithAggregatesFilter<"HotelGroup"> | string | null
    website?: StringNullableWithAggregatesFilter<"HotelGroup"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"HotelGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelGroup"> | Date | string
  }

  export type HotelHighlightWhereInput = {
    AND?: HotelHighlightWhereInput | HotelHighlightWhereInput[]
    OR?: HotelHighlightWhereInput[]
    NOT?: HotelHighlightWhereInput | HotelHighlightWhereInput[]
    id?: StringFilter<"HotelHighlight"> | string
    title?: StringFilter<"HotelHighlight"> | string
    order?: IntNullableFilter<"HotelHighlight"> | number | null
    description?: StringNullableFilter<"HotelHighlight"> | string | null
    category?: StringFilter<"HotelHighlight"> | string
    icon?: StringNullableFilter<"HotelHighlight"> | string | null
    priority?: IntFilter<"HotelHighlight"> | number
    isPromoted?: BoolFilter<"HotelHighlight"> | boolean
    hotelId?: StringFilter<"HotelHighlight"> | string
    createdAt?: DateTimeFilter<"HotelHighlight"> | Date | string
    updatedAt?: DateTimeFilter<"HotelHighlight"> | Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightListRelationFilter
  }

  export type HotelHighlightOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    priority?: SortOrder
    isPromoted?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightOrderByRelationAggregateInput
  }

  export type HotelHighlightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelHighlightWhereInput | HotelHighlightWhereInput[]
    OR?: HotelHighlightWhereInput[]
    NOT?: HotelHighlightWhereInput | HotelHighlightWhereInput[]
    title?: StringFilter<"HotelHighlight"> | string
    order?: IntNullableFilter<"HotelHighlight"> | number | null
    description?: StringNullableFilter<"HotelHighlight"> | string | null
    category?: StringFilter<"HotelHighlight"> | string
    icon?: StringNullableFilter<"HotelHighlight"> | string | null
    priority?: IntFilter<"HotelHighlight"> | number
    isPromoted?: BoolFilter<"HotelHighlight"> | boolean
    hotelId?: StringFilter<"HotelHighlight"> | string
    createdAt?: DateTimeFilter<"HotelHighlight"> | Date | string
    updatedAt?: DateTimeFilter<"HotelHighlight"> | Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightListRelationFilter
  }, "id">

  export type HotelHighlightOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    priority?: SortOrder
    isPromoted?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelHighlightCountOrderByAggregateInput
    _avg?: HotelHighlightAvgOrderByAggregateInput
    _max?: HotelHighlightMaxOrderByAggregateInput
    _min?: HotelHighlightMinOrderByAggregateInput
    _sum?: HotelHighlightSumOrderByAggregateInput
  }

  export type HotelHighlightScalarWhereWithAggregatesInput = {
    AND?: HotelHighlightScalarWhereWithAggregatesInput | HotelHighlightScalarWhereWithAggregatesInput[]
    OR?: HotelHighlightScalarWhereWithAggregatesInput[]
    NOT?: HotelHighlightScalarWhereWithAggregatesInput | HotelHighlightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelHighlight"> | string
    title?: StringWithAggregatesFilter<"HotelHighlight"> | string
    order?: IntNullableWithAggregatesFilter<"HotelHighlight"> | number | null
    description?: StringNullableWithAggregatesFilter<"HotelHighlight"> | string | null
    category?: StringWithAggregatesFilter<"HotelHighlight"> | string
    icon?: StringNullableWithAggregatesFilter<"HotelHighlight"> | string | null
    priority?: IntWithAggregatesFilter<"HotelHighlight"> | number
    isPromoted?: BoolWithAggregatesFilter<"HotelHighlight"> | boolean
    hotelId?: StringWithAggregatesFilter<"HotelHighlight"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HotelHighlight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelHighlight"> | Date | string
  }

  export type HotelAmenityWhereInput = {
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    id?: StringFilter<"HotelAmenity"> | string
    name?: StringFilter<"HotelAmenity"> | string
    order?: IntNullableFilter<"HotelAmenity"> | number | null
    category?: StringNullableFilter<"HotelAmenity"> | string | null
    icon?: StringNullableFilter<"HotelAmenity"> | string | null
    description?: StringNullableFilter<"HotelAmenity"> | string | null
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    HotelCard?: HotelCardListRelationFilter
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityListRelationFilter
  }

  export type HotelAmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityOrderByRelationAggregateInput
  }

  export type HotelAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    name?: StringFilter<"HotelAmenity"> | string
    order?: IntNullableFilter<"HotelAmenity"> | number | null
    category?: StringNullableFilter<"HotelAmenity"> | string | null
    icon?: StringNullableFilter<"HotelAmenity"> | string | null
    description?: StringNullableFilter<"HotelAmenity"> | string | null
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    HotelCard?: HotelCardListRelationFilter
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityListRelationFilter
  }, "id">

  export type HotelAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelAmenityCountOrderByAggregateInput
    _avg?: HotelAmenityAvgOrderByAggregateInput
    _max?: HotelAmenityMaxOrderByAggregateInput
    _min?: HotelAmenityMinOrderByAggregateInput
    _sum?: HotelAmenitySumOrderByAggregateInput
  }

  export type HotelAmenityScalarWhereWithAggregatesInput = {
    AND?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    OR?: HotelAmenityScalarWhereWithAggregatesInput[]
    NOT?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelAmenity"> | string
    name?: StringWithAggregatesFilter<"HotelAmenity"> | string
    order?: IntNullableWithAggregatesFilter<"HotelAmenity"> | number | null
    category?: StringNullableWithAggregatesFilter<"HotelAmenity"> | string | null
    icon?: StringNullableWithAggregatesFilter<"HotelAmenity"> | string | null
    description?: StringNullableWithAggregatesFilter<"HotelAmenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelAmenity"> | Date | string
  }

  export type RoomAmenityWhereInput = {
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    id?: StringFilter<"RoomAmenity"> | string
    name?: StringFilter<"RoomAmenity"> | string
    order?: IntNullableFilter<"RoomAmenity"> | number | null
    category?: StringFilter<"RoomAmenity"> | string
    icon?: StringNullableFilter<"RoomAmenity"> | string | null
    description?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    HotelDetails?: HotelDetailsListRelationFilter
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityListRelationFilter
  }

  export type RoomAmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelDetails?: HotelDetailsOrderByRelationAggregateInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityOrderByRelationAggregateInput
  }

  export type RoomAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    name?: StringFilter<"RoomAmenity"> | string
    order?: IntNullableFilter<"RoomAmenity"> | number | null
    category?: StringFilter<"RoomAmenity"> | string
    icon?: StringNullableFilter<"RoomAmenity"> | string | null
    description?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    HotelDetails?: HotelDetailsListRelationFilter
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityListRelationFilter
  }, "id">

  export type RoomAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomAmenityCountOrderByAggregateInput
    _avg?: RoomAmenityAvgOrderByAggregateInput
    _max?: RoomAmenityMaxOrderByAggregateInput
    _min?: RoomAmenityMinOrderByAggregateInput
    _sum?: RoomAmenitySumOrderByAggregateInput
  }

  export type RoomAmenityScalarWhereWithAggregatesInput = {
    AND?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    OR?: RoomAmenityScalarWhereWithAggregatesInput[]
    NOT?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomAmenity"> | string
    name?: StringWithAggregatesFilter<"RoomAmenity"> | string
    order?: IntNullableWithAggregatesFilter<"RoomAmenity"> | number | null
    category?: StringWithAggregatesFilter<"RoomAmenity"> | string
    icon?: StringNullableWithAggregatesFilter<"RoomAmenity"> | string | null
    description?: StringNullableWithAggregatesFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomAmenity"> | Date | string
  }

  export type AccessibilityOptionWhereInput = {
    AND?: AccessibilityOptionWhereInput | AccessibilityOptionWhereInput[]
    OR?: AccessibilityOptionWhereInput[]
    NOT?: AccessibilityOptionWhereInput | AccessibilityOptionWhereInput[]
    id?: StringFilter<"AccessibilityOption"> | string
    name?: StringFilter<"AccessibilityOption"> | string
    order?: IntNullableFilter<"AccessibilityOption"> | number | null
    code?: StringFilter<"AccessibilityOption"> | string
    description?: StringNullableFilter<"AccessibilityOption"> | string | null
    category?: StringFilter<"AccessibilityOption"> | string
    icon?: StringNullableFilter<"AccessibilityOption"> | string | null
    createdAt?: DateTimeFilter<"AccessibilityOption"> | Date | string
    updatedAt?: DateTimeFilter<"AccessibilityOption"> | Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionListRelationFilter
  }

  export type AccessibilityOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionOrderByRelationAggregateInput
  }

  export type AccessibilityOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AccessibilityOptionWhereInput | AccessibilityOptionWhereInput[]
    OR?: AccessibilityOptionWhereInput[]
    NOT?: AccessibilityOptionWhereInput | AccessibilityOptionWhereInput[]
    name?: StringFilter<"AccessibilityOption"> | string
    order?: IntNullableFilter<"AccessibilityOption"> | number | null
    description?: StringNullableFilter<"AccessibilityOption"> | string | null
    category?: StringFilter<"AccessibilityOption"> | string
    icon?: StringNullableFilter<"AccessibilityOption"> | string | null
    createdAt?: DateTimeFilter<"AccessibilityOption"> | Date | string
    updatedAt?: DateTimeFilter<"AccessibilityOption"> | Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionListRelationFilter
  }, "id" | "code">

  export type AccessibilityOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrderInput | SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccessibilityOptionCountOrderByAggregateInput
    _avg?: AccessibilityOptionAvgOrderByAggregateInput
    _max?: AccessibilityOptionMaxOrderByAggregateInput
    _min?: AccessibilityOptionMinOrderByAggregateInput
    _sum?: AccessibilityOptionSumOrderByAggregateInput
  }

  export type AccessibilityOptionScalarWhereWithAggregatesInput = {
    AND?: AccessibilityOptionScalarWhereWithAggregatesInput | AccessibilityOptionScalarWhereWithAggregatesInput[]
    OR?: AccessibilityOptionScalarWhereWithAggregatesInput[]
    NOT?: AccessibilityOptionScalarWhereWithAggregatesInput | AccessibilityOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessibilityOption"> | string
    name?: StringWithAggregatesFilter<"AccessibilityOption"> | string
    order?: IntNullableWithAggregatesFilter<"AccessibilityOption"> | number | null
    code?: StringWithAggregatesFilter<"AccessibilityOption"> | string
    description?: StringNullableWithAggregatesFilter<"AccessibilityOption"> | string | null
    category?: StringWithAggregatesFilter<"AccessibilityOption"> | string
    icon?: StringNullableWithAggregatesFilter<"AccessibilityOption"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccessibilityOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccessibilityOption"> | Date | string
  }

  export type HotelParkingWhereInput = {
    AND?: HotelParkingWhereInput | HotelParkingWhereInput[]
    OR?: HotelParkingWhereInput[]
    NOT?: HotelParkingWhereInput | HotelParkingWhereInput[]
    id?: StringFilter<"HotelParking"> | string
    isAvailable?: BoolFilter<"HotelParking"> | boolean
    spaces?: IntNullableFilter<"HotelParking"> | number | null
    order?: IntNullableFilter<"HotelParking"> | number | null
    notes?: StringNullableFilter<"HotelParking"> | string | null
    createdAt?: DateTimeFilter<"HotelParking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelParking"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }

  export type HotelParkingOrderByWithRelationInput = {
    id?: SortOrder
    isAvailable?: SortOrder
    spaces?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
  }

  export type HotelParkingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelParkingWhereInput | HotelParkingWhereInput[]
    OR?: HotelParkingWhereInput[]
    NOT?: HotelParkingWhereInput | HotelParkingWhereInput[]
    isAvailable?: BoolFilter<"HotelParking"> | boolean
    spaces?: IntNullableFilter<"HotelParking"> | number | null
    order?: IntNullableFilter<"HotelParking"> | number | null
    notes?: StringNullableFilter<"HotelParking"> | string | null
    createdAt?: DateTimeFilter<"HotelParking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelParking"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }, "id">

  export type HotelParkingOrderByWithAggregationInput = {
    id?: SortOrder
    isAvailable?: SortOrder
    spaces?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelParkingCountOrderByAggregateInput
    _avg?: HotelParkingAvgOrderByAggregateInput
    _max?: HotelParkingMaxOrderByAggregateInput
    _min?: HotelParkingMinOrderByAggregateInput
    _sum?: HotelParkingSumOrderByAggregateInput
  }

  export type HotelParkingScalarWhereWithAggregatesInput = {
    AND?: HotelParkingScalarWhereWithAggregatesInput | HotelParkingScalarWhereWithAggregatesInput[]
    OR?: HotelParkingScalarWhereWithAggregatesInput[]
    NOT?: HotelParkingScalarWhereWithAggregatesInput | HotelParkingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelParking"> | string
    isAvailable?: BoolWithAggregatesFilter<"HotelParking"> | boolean
    spaces?: IntNullableWithAggregatesFilter<"HotelParking"> | number | null
    order?: IntNullableWithAggregatesFilter<"HotelParking"> | number | null
    notes?: StringNullableWithAggregatesFilter<"HotelParking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelParking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelParking"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    streetNumber?: StringNullableFilter<"Address"> | string | null
    streetName?: StringFilter<"Address"> | string
    addressLine2?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    cityId?: StringFilter<"Address"> | string
    neighborhoodId?: StringNullableFilter<"Address"> | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    neighborhood?: XOR<NeighborhoodNullableScalarRelationFilter, NeighborhoodWhereInput> | null
    hotelDetails?: HotelDetailsListRelationFilter
    user?: UserListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    streetNumber?: SortOrderInput | SortOrder
    streetName?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    cityId?: SortOrder
    neighborhoodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    neighborhood?: NeighborhoodOrderByWithRelationInput
    hotelDetails?: HotelDetailsOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    streetNumber?: StringNullableFilter<"Address"> | string | null
    streetName?: StringFilter<"Address"> | string
    addressLine2?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    cityId?: StringFilter<"Address"> | string
    neighborhoodId?: StringNullableFilter<"Address"> | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    neighborhood?: XOR<NeighborhoodNullableScalarRelationFilter, NeighborhoodWhereInput> | null
    hotelDetails?: HotelDetailsListRelationFilter
    user?: UserListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    streetNumber?: SortOrderInput | SortOrder
    streetName?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    cityId?: SortOrder
    neighborhoodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    streetNumber?: StringNullableWithAggregatesFilter<"Address"> | string | null
    streetName?: StringWithAggregatesFilter<"Address"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    cityId?: StringWithAggregatesFilter<"Address"> | string
    neighborhoodId?: StringNullableWithAggregatesFilter<"Address"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type HotelImageWhereInput = {
    AND?: HotelImageWhereInput | HotelImageWhereInput[]
    OR?: HotelImageWhereInput[]
    NOT?: HotelImageWhereInput | HotelImageWhereInput[]
    id?: StringFilter<"HotelImage"> | string
    entityId?: StringFilter<"HotelImage"> | string
    imageUrl?: StringFilter<"HotelImage"> | string
    imageType?: StringFilter<"HotelImage"> | string
    order?: IntFilter<"HotelImage"> | number
    alt?: StringNullableFilter<"HotelImage"> | string | null
    createdAt?: DateTimeFilter<"HotelImage"> | Date | string
    updatedAt?: DateTimeFilter<"HotelImage"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }

  export type HotelImageOrderByWithRelationInput = {
    id?: SortOrder
    entityId?: SortOrder
    imageUrl?: SortOrder
    imageType?: SortOrder
    order?: SortOrder
    alt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HotelCard?: HotelCardOrderByRelationAggregateInput
  }

  export type HotelImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelImageWhereInput | HotelImageWhereInput[]
    OR?: HotelImageWhereInput[]
    NOT?: HotelImageWhereInput | HotelImageWhereInput[]
    entityId?: StringFilter<"HotelImage"> | string
    imageUrl?: StringFilter<"HotelImage"> | string
    imageType?: StringFilter<"HotelImage"> | string
    order?: IntFilter<"HotelImage"> | number
    alt?: StringNullableFilter<"HotelImage"> | string | null
    createdAt?: DateTimeFilter<"HotelImage"> | Date | string
    updatedAt?: DateTimeFilter<"HotelImage"> | Date | string
    HotelCard?: HotelCardListRelationFilter
  }, "id">

  export type HotelImageOrderByWithAggregationInput = {
    id?: SortOrder
    entityId?: SortOrder
    imageUrl?: SortOrder
    imageType?: SortOrder
    order?: SortOrder
    alt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelImageCountOrderByAggregateInput
    _avg?: HotelImageAvgOrderByAggregateInput
    _max?: HotelImageMaxOrderByAggregateInput
    _min?: HotelImageMinOrderByAggregateInput
    _sum?: HotelImageSumOrderByAggregateInput
  }

  export type HotelImageScalarWhereWithAggregatesInput = {
    AND?: HotelImageScalarWhereWithAggregatesInput | HotelImageScalarWhereWithAggregatesInput[]
    OR?: HotelImageScalarWhereWithAggregatesInput[]
    NOT?: HotelImageScalarWhereWithAggregatesInput | HotelImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelImage"> | string
    entityId?: StringWithAggregatesFilter<"HotelImage"> | string
    imageUrl?: StringWithAggregatesFilter<"HotelImage"> | string
    imageType?: StringWithAggregatesFilter<"HotelImage"> | string
    order?: IntWithAggregatesFilter<"HotelImage"> | number
    alt?: StringNullableWithAggregatesFilter<"HotelImage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelImage"> | Date | string
  }

  export type HotelCardWhereInput = {
    AND?: HotelCardWhereInput | HotelCardWhereInput[]
    OR?: HotelCardWhereInput[]
    NOT?: HotelCardWhereInput | HotelCardWhereInput[]
    id?: StringFilter<"HotelCard"> | string
    name?: StringFilter<"HotelCard"> | string
    idCity?: StringFilter<"HotelCard"> | string
    order?: IntFilter<"HotelCard"> | number
    shortDescription?: StringNullableFilter<"HotelCard"> | string | null
    starRating?: IntFilter<"HotelCard"> | number
    overallRating?: FloatNullableFilter<"HotelCard"> | number | null
    ratingAdjective?: StringNullableFilter<"HotelCard"> | string | null
    reviewCount?: IntFilter<"HotelCard"> | number
    basePricePerNight?: FloatFilter<"HotelCard"> | number
    regularPrice?: FloatNullableFilter<"HotelCard"> | number | null
    currency?: StringFilter<"HotelCard"> | string
    isPartner?: BoolFilter<"HotelCard"> | boolean
    promoMessage?: StringNullableFilter<"HotelCard"> | string | null
    imageMessage?: StringNullableFilter<"HotelCard"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelCard"> | string | null
    accommodationTypeId?: StringNullableFilter<"HotelCard"> | string | null
    destinationId?: StringNullableFilter<"HotelCard"> | string | null
    hotelGroupId?: StringNullableFilter<"HotelCard"> | string | null
    latitude?: FloatNullableFilter<"HotelCard"> | number | null
    longitude?: FloatNullableFilter<"HotelCard"> | number | null
    detailsId?: StringNullableFilter<"HotelCard"> | string | null
    parking?: HotelParkingListRelationFilter
    images?: HotelImageListRelationFilter
    HotelAmenity?: HotelAmenityListRelationFilter
    details?: XOR<HotelDetailsNullableScalarRelationFilter, HotelDetailsWhereInput> | null
    accommodationType?: XOR<AccommodationTypeNullableScalarRelationFilter, AccommodationTypeWhereInput> | null
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    hotelGroup?: XOR<HotelGroupNullableScalarRelationFilter, HotelGroupWhereInput> | null
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightListRelationFilter
    HotelCardToLabel?: HotelCardToLabelListRelationFilter
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionListRelationFilter
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityListRelationFilter
  }

  export type HotelCardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    idCity?: SortOrder
    order?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    starRating?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    ratingAdjective?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    isPartner?: SortOrder
    promoMessage?: SortOrderInput | SortOrder
    imageMessage?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    accommodationTypeId?: SortOrderInput | SortOrder
    destinationId?: SortOrderInput | SortOrder
    hotelGroupId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    detailsId?: SortOrderInput | SortOrder
    parking?: HotelParkingOrderByRelationAggregateInput
    images?: HotelImageOrderByRelationAggregateInput
    HotelAmenity?: HotelAmenityOrderByRelationAggregateInput
    details?: HotelDetailsOrderByWithRelationInput
    accommodationType?: AccommodationTypeOrderByWithRelationInput
    destination?: DestinationOrderByWithRelationInput
    hotelGroup?: HotelGroupOrderByWithRelationInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightOrderByRelationAggregateInput
    HotelCardToLabel?: HotelCardToLabelOrderByRelationAggregateInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionOrderByRelationAggregateInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityOrderByRelationAggregateInput
  }

  export type HotelCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelCardWhereInput | HotelCardWhereInput[]
    OR?: HotelCardWhereInput[]
    NOT?: HotelCardWhereInput | HotelCardWhereInput[]
    name?: StringFilter<"HotelCard"> | string
    idCity?: StringFilter<"HotelCard"> | string
    order?: IntFilter<"HotelCard"> | number
    shortDescription?: StringNullableFilter<"HotelCard"> | string | null
    starRating?: IntFilter<"HotelCard"> | number
    overallRating?: FloatNullableFilter<"HotelCard"> | number | null
    ratingAdjective?: StringNullableFilter<"HotelCard"> | string | null
    reviewCount?: IntFilter<"HotelCard"> | number
    basePricePerNight?: FloatFilter<"HotelCard"> | number
    regularPrice?: FloatNullableFilter<"HotelCard"> | number | null
    currency?: StringFilter<"HotelCard"> | string
    isPartner?: BoolFilter<"HotelCard"> | boolean
    promoMessage?: StringNullableFilter<"HotelCard"> | string | null
    imageMessage?: StringNullableFilter<"HotelCard"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelCard"> | string | null
    accommodationTypeId?: StringNullableFilter<"HotelCard"> | string | null
    destinationId?: StringNullableFilter<"HotelCard"> | string | null
    hotelGroupId?: StringNullableFilter<"HotelCard"> | string | null
    latitude?: FloatNullableFilter<"HotelCard"> | number | null
    longitude?: FloatNullableFilter<"HotelCard"> | number | null
    detailsId?: StringNullableFilter<"HotelCard"> | string | null
    parking?: HotelParkingListRelationFilter
    images?: HotelImageListRelationFilter
    HotelAmenity?: HotelAmenityListRelationFilter
    details?: XOR<HotelDetailsNullableScalarRelationFilter, HotelDetailsWhereInput> | null
    accommodationType?: XOR<AccommodationTypeNullableScalarRelationFilter, AccommodationTypeWhereInput> | null
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    hotelGroup?: XOR<HotelGroupNullableScalarRelationFilter, HotelGroupWhereInput> | null
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightListRelationFilter
    HotelCardToLabel?: HotelCardToLabelListRelationFilter
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionListRelationFilter
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityListRelationFilter
  }, "id">

  export type HotelCardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    idCity?: SortOrder
    order?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    starRating?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    ratingAdjective?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    isPartner?: SortOrder
    promoMessage?: SortOrderInput | SortOrder
    imageMessage?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    accommodationTypeId?: SortOrderInput | SortOrder
    destinationId?: SortOrderInput | SortOrder
    hotelGroupId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    detailsId?: SortOrderInput | SortOrder
    _count?: HotelCardCountOrderByAggregateInput
    _avg?: HotelCardAvgOrderByAggregateInput
    _max?: HotelCardMaxOrderByAggregateInput
    _min?: HotelCardMinOrderByAggregateInput
    _sum?: HotelCardSumOrderByAggregateInput
  }

  export type HotelCardScalarWhereWithAggregatesInput = {
    AND?: HotelCardScalarWhereWithAggregatesInput | HotelCardScalarWhereWithAggregatesInput[]
    OR?: HotelCardScalarWhereWithAggregatesInput[]
    NOT?: HotelCardScalarWhereWithAggregatesInput | HotelCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelCard"> | string
    name?: StringWithAggregatesFilter<"HotelCard"> | string
    idCity?: StringWithAggregatesFilter<"HotelCard"> | string
    order?: IntWithAggregatesFilter<"HotelCard"> | number
    shortDescription?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    starRating?: IntWithAggregatesFilter<"HotelCard"> | number
    overallRating?: FloatNullableWithAggregatesFilter<"HotelCard"> | number | null
    ratingAdjective?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    reviewCount?: IntWithAggregatesFilter<"HotelCard"> | number
    basePricePerNight?: FloatWithAggregatesFilter<"HotelCard"> | number
    regularPrice?: FloatNullableWithAggregatesFilter<"HotelCard"> | number | null
    currency?: StringWithAggregatesFilter<"HotelCard"> | string
    isPartner?: BoolWithAggregatesFilter<"HotelCard"> | boolean
    promoMessage?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    imageMessage?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    cancellationPolicy?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    accommodationTypeId?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    destinationId?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    hotelGroupId?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"HotelCard"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"HotelCard"> | number | null
    detailsId?: StringNullableWithAggregatesFilter<"HotelCard"> | string | null
  }

  export type HotelDetailsWhereInput = {
    AND?: HotelDetailsWhereInput | HotelDetailsWhereInput[]
    OR?: HotelDetailsWhereInput[]
    NOT?: HotelDetailsWhereInput | HotelDetailsWhereInput[]
    id?: StringFilter<"HotelDetails"> | string
    idHotelCard?: StringFilter<"HotelDetails"> | string
    description?: StringNullableFilter<"HotelDetails"> | string | null
    addressId?: StringFilter<"HotelDetails"> | string
    order?: IntNullableFilter<"HotelDetails"> | number | null
    createdAt?: DateTimeFilter<"HotelDetails"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetails"> | Date | string
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    RoomAmenity?: RoomAmenityListRelationFilter
    Label?: LabelListRelationFilter
    HotelCard?: HotelCardListRelationFilter
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityListRelationFilter
  }

  export type HotelDetailsOrderByWithRelationInput = {
    id?: SortOrder
    idHotelCard?: SortOrder
    description?: SortOrderInput | SortOrder
    addressId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: AddressOrderByWithRelationInput
    RoomAmenity?: RoomAmenityOrderByRelationAggregateInput
    Label?: LabelOrderByRelationAggregateInput
    HotelCard?: HotelCardOrderByRelationAggregateInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityOrderByRelationAggregateInput
  }

  export type HotelDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelDetailsWhereInput | HotelDetailsWhereInput[]
    OR?: HotelDetailsWhereInput[]
    NOT?: HotelDetailsWhereInput | HotelDetailsWhereInput[]
    idHotelCard?: StringFilter<"HotelDetails"> | string
    description?: StringNullableFilter<"HotelDetails"> | string | null
    addressId?: StringFilter<"HotelDetails"> | string
    order?: IntNullableFilter<"HotelDetails"> | number | null
    createdAt?: DateTimeFilter<"HotelDetails"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetails"> | Date | string
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    RoomAmenity?: RoomAmenityListRelationFilter
    Label?: LabelListRelationFilter
    HotelCard?: HotelCardListRelationFilter
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityListRelationFilter
  }, "id">

  export type HotelDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    idHotelCard?: SortOrder
    description?: SortOrderInput | SortOrder
    addressId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelDetailsCountOrderByAggregateInput
    _avg?: HotelDetailsAvgOrderByAggregateInput
    _max?: HotelDetailsMaxOrderByAggregateInput
    _min?: HotelDetailsMinOrderByAggregateInput
    _sum?: HotelDetailsSumOrderByAggregateInput
  }

  export type HotelDetailsScalarWhereWithAggregatesInput = {
    AND?: HotelDetailsScalarWhereWithAggregatesInput | HotelDetailsScalarWhereWithAggregatesInput[]
    OR?: HotelDetailsScalarWhereWithAggregatesInput[]
    NOT?: HotelDetailsScalarWhereWithAggregatesInput | HotelDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelDetails"> | string
    idHotelCard?: StringWithAggregatesFilter<"HotelDetails"> | string
    description?: StringNullableWithAggregatesFilter<"HotelDetails"> | string | null
    addressId?: StringWithAggregatesFilter<"HotelDetails"> | string
    order?: IntNullableWithAggregatesFilter<"HotelDetails"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelDetails"> | Date | string
  }

  export type HotelCardToHotelHighlightWhereInput = {
    AND?: HotelCardToHotelHighlightWhereInput | HotelCardToHotelHighlightWhereInput[]
    OR?: HotelCardToHotelHighlightWhereInput[]
    NOT?: HotelCardToHotelHighlightWhereInput | HotelCardToHotelHighlightWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelHighlight"> | string
    hotelHighlightId?: StringFilter<"HotelCardToHotelHighlight"> | string
    order?: IntNullableFilter<"HotelCardToHotelHighlight"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    hotelHighlight?: XOR<HotelHighlightScalarRelationFilter, HotelHighlightWhereInput>
  }

  export type HotelCardToHotelHighlightOrderByWithRelationInput = {
    hotelCardId?: SortOrder
    hotelHighlightId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelCard?: HotelCardOrderByWithRelationInput
    hotelHighlight?: HotelHighlightOrderByWithRelationInput
  }

  export type HotelCardToHotelHighlightWhereUniqueInput = Prisma.AtLeast<{
    hotelCardId_hotelHighlightId?: HotelCardToHotelHighlightHotelCardIdHotelHighlightIdCompoundUniqueInput
    AND?: HotelCardToHotelHighlightWhereInput | HotelCardToHotelHighlightWhereInput[]
    OR?: HotelCardToHotelHighlightWhereInput[]
    NOT?: HotelCardToHotelHighlightWhereInput | HotelCardToHotelHighlightWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelHighlight"> | string
    hotelHighlightId?: StringFilter<"HotelCardToHotelHighlight"> | string
    order?: IntNullableFilter<"HotelCardToHotelHighlight"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    hotelHighlight?: XOR<HotelHighlightScalarRelationFilter, HotelHighlightWhereInput>
  }, "hotelCardId_hotelHighlightId">

  export type HotelCardToHotelHighlightOrderByWithAggregationInput = {
    hotelCardId?: SortOrder
    hotelHighlightId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCardToHotelHighlightCountOrderByAggregateInput
    _avg?: HotelCardToHotelHighlightAvgOrderByAggregateInput
    _max?: HotelCardToHotelHighlightMaxOrderByAggregateInput
    _min?: HotelCardToHotelHighlightMinOrderByAggregateInput
    _sum?: HotelCardToHotelHighlightSumOrderByAggregateInput
  }

  export type HotelCardToHotelHighlightScalarWhereWithAggregatesInput = {
    AND?: HotelCardToHotelHighlightScalarWhereWithAggregatesInput | HotelCardToHotelHighlightScalarWhereWithAggregatesInput[]
    OR?: HotelCardToHotelHighlightScalarWhereWithAggregatesInput[]
    NOT?: HotelCardToHotelHighlightScalarWhereWithAggregatesInput | HotelCardToHotelHighlightScalarWhereWithAggregatesInput[]
    hotelCardId?: StringWithAggregatesFilter<"HotelCardToHotelHighlight"> | string
    hotelHighlightId?: StringWithAggregatesFilter<"HotelCardToHotelHighlight"> | string
    order?: IntNullableWithAggregatesFilter<"HotelCardToHotelHighlight"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelCardToHotelHighlight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelCardToHotelHighlight"> | Date | string
  }

  export type HotelCardToLabelWhereInput = {
    AND?: HotelCardToLabelWhereInput | HotelCardToLabelWhereInput[]
    OR?: HotelCardToLabelWhereInput[]
    NOT?: HotelCardToLabelWhereInput | HotelCardToLabelWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToLabel"> | string
    labelId?: StringFilter<"HotelCardToLabel"> | string
    order?: IntNullableFilter<"HotelCardToLabel"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    label?: XOR<LabelScalarRelationFilter, LabelWhereInput>
  }

  export type HotelCardToLabelOrderByWithRelationInput = {
    hotelCardId?: SortOrder
    labelId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelCard?: HotelCardOrderByWithRelationInput
    label?: LabelOrderByWithRelationInput
  }

  export type HotelCardToLabelWhereUniqueInput = Prisma.AtLeast<{
    hotelCardId_labelId?: HotelCardToLabelHotelCardIdLabelIdCompoundUniqueInput
    AND?: HotelCardToLabelWhereInput | HotelCardToLabelWhereInput[]
    OR?: HotelCardToLabelWhereInput[]
    NOT?: HotelCardToLabelWhereInput | HotelCardToLabelWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToLabel"> | string
    labelId?: StringFilter<"HotelCardToLabel"> | string
    order?: IntNullableFilter<"HotelCardToLabel"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    label?: XOR<LabelScalarRelationFilter, LabelWhereInput>
  }, "hotelCardId_labelId">

  export type HotelCardToLabelOrderByWithAggregationInput = {
    hotelCardId?: SortOrder
    labelId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCardToLabelCountOrderByAggregateInput
    _avg?: HotelCardToLabelAvgOrderByAggregateInput
    _max?: HotelCardToLabelMaxOrderByAggregateInput
    _min?: HotelCardToLabelMinOrderByAggregateInput
    _sum?: HotelCardToLabelSumOrderByAggregateInput
  }

  export type HotelCardToLabelScalarWhereWithAggregatesInput = {
    AND?: HotelCardToLabelScalarWhereWithAggregatesInput | HotelCardToLabelScalarWhereWithAggregatesInput[]
    OR?: HotelCardToLabelScalarWhereWithAggregatesInput[]
    NOT?: HotelCardToLabelScalarWhereWithAggregatesInput | HotelCardToLabelScalarWhereWithAggregatesInput[]
    hotelCardId?: StringWithAggregatesFilter<"HotelCardToLabel"> | string
    labelId?: StringWithAggregatesFilter<"HotelCardToLabel"> | string
    order?: IntNullableWithAggregatesFilter<"HotelCardToLabel"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelCardToLabel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelCardToLabel"> | Date | string
  }

  export type HotelCardToAccessibilityOptionWhereInput = {
    AND?: HotelCardToAccessibilityOptionWhereInput | HotelCardToAccessibilityOptionWhereInput[]
    OR?: HotelCardToAccessibilityOptionWhereInput[]
    NOT?: HotelCardToAccessibilityOptionWhereInput | HotelCardToAccessibilityOptionWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    accessibilityOptionId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    order?: IntNullableFilter<"HotelCardToAccessibilityOption"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    accessibilityOption?: XOR<AccessibilityOptionScalarRelationFilter, AccessibilityOptionWhereInput>
  }

  export type HotelCardToAccessibilityOptionOrderByWithRelationInput = {
    hotelCardId?: SortOrder
    accessibilityOptionId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelCard?: HotelCardOrderByWithRelationInput
    accessibilityOption?: AccessibilityOptionOrderByWithRelationInput
  }

  export type HotelCardToAccessibilityOptionWhereUniqueInput = Prisma.AtLeast<{
    hotelCardId_accessibilityOptionId?: HotelCardToAccessibilityOptionHotelCardIdAccessibilityOptionIdCompoundUniqueInput
    AND?: HotelCardToAccessibilityOptionWhereInput | HotelCardToAccessibilityOptionWhereInput[]
    OR?: HotelCardToAccessibilityOptionWhereInput[]
    NOT?: HotelCardToAccessibilityOptionWhereInput | HotelCardToAccessibilityOptionWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    accessibilityOptionId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    order?: IntNullableFilter<"HotelCardToAccessibilityOption"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    accessibilityOption?: XOR<AccessibilityOptionScalarRelationFilter, AccessibilityOptionWhereInput>
  }, "hotelCardId_accessibilityOptionId">

  export type HotelCardToAccessibilityOptionOrderByWithAggregationInput = {
    hotelCardId?: SortOrder
    accessibilityOptionId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCardToAccessibilityOptionCountOrderByAggregateInput
    _avg?: HotelCardToAccessibilityOptionAvgOrderByAggregateInput
    _max?: HotelCardToAccessibilityOptionMaxOrderByAggregateInput
    _min?: HotelCardToAccessibilityOptionMinOrderByAggregateInput
    _sum?: HotelCardToAccessibilityOptionSumOrderByAggregateInput
  }

  export type HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput = {
    AND?: HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput | HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput[]
    OR?: HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput[]
    NOT?: HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput | HotelCardToAccessibilityOptionScalarWhereWithAggregatesInput[]
    hotelCardId?: StringWithAggregatesFilter<"HotelCardToAccessibilityOption"> | string
    accessibilityOptionId?: StringWithAggregatesFilter<"HotelCardToAccessibilityOption"> | string
    order?: IntNullableWithAggregatesFilter<"HotelCardToAccessibilityOption"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelCardToAccessibilityOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelCardToAccessibilityOption"> | Date | string
  }

  export type HotelCardToHotelAmenityWhereInput = {
    AND?: HotelCardToHotelAmenityWhereInput | HotelCardToHotelAmenityWhereInput[]
    OR?: HotelCardToHotelAmenityWhereInput[]
    NOT?: HotelCardToHotelAmenityWhereInput | HotelCardToHotelAmenityWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelAmenity"> | string
    hotelAmenityId?: StringFilter<"HotelCardToHotelAmenity"> | string
    order?: IntNullableFilter<"HotelCardToHotelAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    hotelAmenity?: XOR<HotelAmenityScalarRelationFilter, HotelAmenityWhereInput>
  }

  export type HotelCardToHotelAmenityOrderByWithRelationInput = {
    hotelCardId?: SortOrder
    hotelAmenityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelCard?: HotelCardOrderByWithRelationInput
    hotelAmenity?: HotelAmenityOrderByWithRelationInput
  }

  export type HotelCardToHotelAmenityWhereUniqueInput = Prisma.AtLeast<{
    hotelCardId_hotelAmenityId?: HotelCardToHotelAmenityHotelCardIdHotelAmenityIdCompoundUniqueInput
    AND?: HotelCardToHotelAmenityWhereInput | HotelCardToHotelAmenityWhereInput[]
    OR?: HotelCardToHotelAmenityWhereInput[]
    NOT?: HotelCardToHotelAmenityWhereInput | HotelCardToHotelAmenityWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelAmenity"> | string
    hotelAmenityId?: StringFilter<"HotelCardToHotelAmenity"> | string
    order?: IntNullableFilter<"HotelCardToHotelAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
    hotelCard?: XOR<HotelCardScalarRelationFilter, HotelCardWhereInput>
    hotelAmenity?: XOR<HotelAmenityScalarRelationFilter, HotelAmenityWhereInput>
  }, "hotelCardId_hotelAmenityId">

  export type HotelCardToHotelAmenityOrderByWithAggregationInput = {
    hotelCardId?: SortOrder
    hotelAmenityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCardToHotelAmenityCountOrderByAggregateInput
    _avg?: HotelCardToHotelAmenityAvgOrderByAggregateInput
    _max?: HotelCardToHotelAmenityMaxOrderByAggregateInput
    _min?: HotelCardToHotelAmenityMinOrderByAggregateInput
    _sum?: HotelCardToHotelAmenitySumOrderByAggregateInput
  }

  export type HotelCardToHotelAmenityScalarWhereWithAggregatesInput = {
    AND?: HotelCardToHotelAmenityScalarWhereWithAggregatesInput | HotelCardToHotelAmenityScalarWhereWithAggregatesInput[]
    OR?: HotelCardToHotelAmenityScalarWhereWithAggregatesInput[]
    NOT?: HotelCardToHotelAmenityScalarWhereWithAggregatesInput | HotelCardToHotelAmenityScalarWhereWithAggregatesInput[]
    hotelCardId?: StringWithAggregatesFilter<"HotelCardToHotelAmenity"> | string
    hotelAmenityId?: StringWithAggregatesFilter<"HotelCardToHotelAmenity"> | string
    order?: IntNullableWithAggregatesFilter<"HotelCardToHotelAmenity"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelCardToHotelAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelCardToHotelAmenity"> | Date | string
  }

  export type HotelDetailsToRoomAmenityWhereInput = {
    AND?: HotelDetailsToRoomAmenityWhereInput | HotelDetailsToRoomAmenityWhereInput[]
    OR?: HotelDetailsToRoomAmenityWhereInput[]
    NOT?: HotelDetailsToRoomAmenityWhereInput | HotelDetailsToRoomAmenityWhereInput[]
    hotelDetailsId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    roomAmenityId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    order?: IntNullableFilter<"HotelDetailsToRoomAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
    hotelDetails?: XOR<HotelDetailsScalarRelationFilter, HotelDetailsWhereInput>
    roomAmenity?: XOR<RoomAmenityScalarRelationFilter, RoomAmenityWhereInput>
  }

  export type HotelDetailsToRoomAmenityOrderByWithRelationInput = {
    hotelDetailsId?: SortOrder
    roomAmenityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetails?: HotelDetailsOrderByWithRelationInput
    roomAmenity?: RoomAmenityOrderByWithRelationInput
  }

  export type HotelDetailsToRoomAmenityWhereUniqueInput = Prisma.AtLeast<{
    hotelDetailsId_roomAmenityId?: HotelDetailsToRoomAmenityHotelDetailsIdRoomAmenityIdCompoundUniqueInput
    AND?: HotelDetailsToRoomAmenityWhereInput | HotelDetailsToRoomAmenityWhereInput[]
    OR?: HotelDetailsToRoomAmenityWhereInput[]
    NOT?: HotelDetailsToRoomAmenityWhereInput | HotelDetailsToRoomAmenityWhereInput[]
    hotelDetailsId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    roomAmenityId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    order?: IntNullableFilter<"HotelDetailsToRoomAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
    hotelDetails?: XOR<HotelDetailsScalarRelationFilter, HotelDetailsWhereInput>
    roomAmenity?: XOR<RoomAmenityScalarRelationFilter, RoomAmenityWhereInput>
  }, "hotelDetailsId_roomAmenityId">

  export type HotelDetailsToRoomAmenityOrderByWithAggregationInput = {
    hotelDetailsId?: SortOrder
    roomAmenityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelDetailsToRoomAmenityCountOrderByAggregateInput
    _avg?: HotelDetailsToRoomAmenityAvgOrderByAggregateInput
    _max?: HotelDetailsToRoomAmenityMaxOrderByAggregateInput
    _min?: HotelDetailsToRoomAmenityMinOrderByAggregateInput
    _sum?: HotelDetailsToRoomAmenitySumOrderByAggregateInput
  }

  export type HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput = {
    AND?: HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput | HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput[]
    OR?: HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput[]
    NOT?: HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput | HotelDetailsToRoomAmenityScalarWhereWithAggregatesInput[]
    hotelDetailsId?: StringWithAggregatesFilter<"HotelDetailsToRoomAmenity"> | string
    roomAmenityId?: StringWithAggregatesFilter<"HotelDetailsToRoomAmenity"> | string
    order?: IntNullableWithAggregatesFilter<"HotelDetailsToRoomAmenity"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HotelDetailsToRoomAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HotelDetailsToRoomAmenity"> | Date | string
  }

  export type DestinationToCityWhereInput = {
    AND?: DestinationToCityWhereInput | DestinationToCityWhereInput[]
    OR?: DestinationToCityWhereInput[]
    NOT?: DestinationToCityWhereInput | DestinationToCityWhereInput[]
    destinationId?: StringFilter<"DestinationToCity"> | string
    cityId?: StringFilter<"DestinationToCity"> | string
    order?: IntNullableFilter<"DestinationToCity"> | number | null
    createdAt?: DateTimeFilter<"DestinationToCity"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationToCity"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type DestinationToCityOrderByWithRelationInput = {
    destinationId?: SortOrder
    cityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
  }

  export type DestinationToCityWhereUniqueInput = Prisma.AtLeast<{
    destinationId_cityId?: DestinationToCityDestinationIdCityIdCompoundUniqueInput
    AND?: DestinationToCityWhereInput | DestinationToCityWhereInput[]
    OR?: DestinationToCityWhereInput[]
    NOT?: DestinationToCityWhereInput | DestinationToCityWhereInput[]
    destinationId?: StringFilter<"DestinationToCity"> | string
    cityId?: StringFilter<"DestinationToCity"> | string
    order?: IntNullableFilter<"DestinationToCity"> | number | null
    createdAt?: DateTimeFilter<"DestinationToCity"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationToCity"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "destinationId_cityId">

  export type DestinationToCityOrderByWithAggregationInput = {
    destinationId?: SortOrder
    cityId?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationToCityCountOrderByAggregateInput
    _avg?: DestinationToCityAvgOrderByAggregateInput
    _max?: DestinationToCityMaxOrderByAggregateInput
    _min?: DestinationToCityMinOrderByAggregateInput
    _sum?: DestinationToCitySumOrderByAggregateInput
  }

  export type DestinationToCityScalarWhereWithAggregatesInput = {
    AND?: DestinationToCityScalarWhereWithAggregatesInput | DestinationToCityScalarWhereWithAggregatesInput[]
    OR?: DestinationToCityScalarWhereWithAggregatesInput[]
    NOT?: DestinationToCityScalarWhereWithAggregatesInput | DestinationToCityScalarWhereWithAggregatesInput[]
    destinationId?: StringWithAggregatesFilter<"DestinationToCity"> | string
    cityId?: StringWithAggregatesFilter<"DestinationToCity"> | string
    order?: IntNullableWithAggregatesFilter<"DestinationToCity"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DestinationToCity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DestinationToCity"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    Address?: AddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Address?: AddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Address?: AddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Address?: AddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    language?: string | null
    currency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    language?: string | null
    currency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    language?: string | null
    currency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeighborhoodCreateInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutNeighborhoodsInput
    addresses?: AddressCreateNestedManyWithoutNeighborhoodInput
  }

  export type NeighborhoodUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutNeighborhoodInput
  }

  export type NeighborhoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutNeighborhoodsNestedInput
    addresses?: AddressUpdateManyWithoutNeighborhoodNestedInput
  }

  export type NeighborhoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutNeighborhoodNestedInput
  }

  export type NeighborhoodCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NeighborhoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeighborhoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutLandmarksInput
  }

  export type LandmarkUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandmarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutLandmarksNestedInput
  }

  export type LandmarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandmarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationTypeCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutAccommodationTypeInput
  }

  export type AccommodationTypeUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutAccommodationTypeInput
  }

  export type AccommodationTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutAccommodationTypeNestedInput
  }

  export type AccommodationTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutAccommodationTypeNestedInput
  }

  export type AccommodationTypeCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutDestinationInput
    City?: CityCreateNestedManyWithoutDestinationsInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDestinationInput
    City?: CityUncheckedCreateNestedManyWithoutDestinationsInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutDestinationNestedInput
    City?: CityUpdateManyWithoutDestinationsNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDestinationNestedInput
    City?: CityUncheckedUpdateManyWithoutDestinationsNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsCreateNestedOneWithoutLabelInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetailsId?: string | null
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUpdateOneWithoutLabelNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetailsId?: string | null
  }

  export type LabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelGroupCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutHotelGroupInput
  }

  export type HotelGroupUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutHotelGroupInput
  }

  export type HotelGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutHotelGroupNestedInput
  }

  export type HotelGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutHotelGroupNestedInput
  }

  export type HotelGroupCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelHighlightCreateInput = {
    id?: string
    title: string
    order?: number | null
    description?: string | null
    category: string
    icon?: string | null
    priority?: number
    isPromoted?: boolean
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelHighlightInput
  }

  export type HotelHighlightUncheckedCreateInput = {
    id?: string
    title: string
    order?: number | null
    description?: string | null
    category: string
    icon?: string | null
    priority?: number
    isPromoted?: boolean
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelHighlightInput
  }

  export type HotelHighlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelHighlightNestedInput
  }

  export type HotelHighlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelHighlightNestedInput
  }

  export type HotelHighlightCreateManyInput = {
    id?: string
    title: string
    order?: number | null
    description?: string | null
    category: string
    icon?: string | null
    priority?: number
    isPromoted?: boolean
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelHighlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelHighlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityCreateInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutHotelAmenityInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutHotelAmenityInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutHotelAmenityNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutHotelAmenityNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelAmenityCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityCreateInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsCreateNestedManyWithoutRoomAmenityInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutRoomAmenityInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUpdateManyWithoutRoomAmenityNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutRoomAmenityNestedInput
  }

  export type RoomAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUncheckedUpdateManyWithoutRoomAmenityNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutRoomAmenityNestedInput
  }

  export type RoomAmenityCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessibilityOptionCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutAccessibilityOptionInput
  }

  export type AccessibilityOptionUncheckedCreateInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutAccessibilityOptionInput
  }

  export type AccessibilityOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutAccessibilityOptionNestedInput
  }

  export type AccessibilityOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutAccessibilityOptionNestedInput
  }

  export type AccessibilityOptionCreateManyInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessibilityOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessibilityOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelParkingCreateInput = {
    id?: string
    isAvailable?: boolean
    spaces?: number | null
    order?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutParkingInput
  }

  export type HotelParkingUncheckedCreateInput = {
    id?: string
    isAvailable?: boolean
    spaces?: number | null
    order?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutParkingInput
  }

  export type HotelParkingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutParkingNestedInput
  }

  export type HotelParkingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutParkingNestedInput
  }

  export type HotelParkingCreateManyInput = {
    id?: string
    isAvailable?: boolean
    spaces?: number | null
    order?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelParkingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelParkingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    neighborhood?: NeighborhoodCreateNestedOneWithoutAddressesInput
    hotelDetails?: HotelDetailsCreateNestedManyWithoutAddressInput
    user?: UserCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutAddressInput
    user?: UserUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    neighborhood?: NeighborhoodUpdateOneWithoutAddressesNestedInput
    hotelDetails?: HotelDetailsUpdateManyWithoutAddressNestedInput
    user?: UserUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUncheckedUpdateManyWithoutAddressNestedInput
    user?: UserUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelImageCreateInput = {
    id?: string
    entityId: string
    imageUrl: string
    imageType: string
    order?: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutImagesInput
  }

  export type HotelImageUncheckedCreateInput = {
    id?: string
    entityId: string
    imageUrl: string
    imageType: string
    order?: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutImagesInput
  }

  export type HotelImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutImagesNestedInput
  }

  export type HotelImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type HotelImageCreateManyInput = {
    id?: string
    entityId: string
    imageUrl: string
    imageType: string
    order?: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardCreateInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardCreateManyInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
  }

  export type HotelCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HotelCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelDetailsCreateInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutHotelDetailsInput
    RoomAmenity?: RoomAmenityCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUncheckedCreateInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutHotelDetailsNestedInput
    RoomAmenity?: RoomAmenityUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsCreateManyInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToHotelHighlightInput
    hotelHighlight: HotelHighlightCreateNestedOneWithoutHotelCardToHotelHighlightInput
  }

  export type HotelCardToHotelHighlightUncheckedCreateInput = {
    hotelCardId: string
    hotelHighlightId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelHighlightUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput
    hotelHighlight?: HotelHighlightUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput
  }

  export type HotelCardToHotelHighlightUncheckedUpdateInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    hotelHighlightId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightCreateManyInput = {
    hotelCardId: string
    hotelHighlightId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelHighlightUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightUncheckedUpdateManyInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    hotelHighlightId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToLabelInput
    label: LabelCreateNestedOneWithoutHotelCardToLabelInput
  }

  export type HotelCardToLabelUncheckedCreateInput = {
    hotelCardId: string
    labelId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToLabelNestedInput
    label?: LabelUpdateOneRequiredWithoutHotelCardToLabelNestedInput
  }

  export type HotelCardToLabelUncheckedUpdateInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelCreateManyInput = {
    hotelCardId: string
    labelId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelUncheckedUpdateManyInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToAccessibilityOptionInput
    accessibilityOption: AccessibilityOptionCreateNestedOneWithoutHotelCardToAccessibilityOptionInput
  }

  export type HotelCardToAccessibilityOptionUncheckedCreateInput = {
    hotelCardId: string
    accessibilityOptionId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput
    accessibilityOption?: AccessibilityOptionUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    accessibilityOptionId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionCreateManyInput = {
    hotelCardId: string
    accessibilityOptionId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateManyInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    accessibilityOptionId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToHotelAmenityInput
    hotelAmenity: HotelAmenityCreateNestedOneWithoutHotelCardToHotelAmenityInput
  }

  export type HotelCardToHotelAmenityUncheckedCreateInput = {
    hotelCardId: string
    hotelAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelAmenityUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput
    hotelAmenity?: HotelAmenityUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput
  }

  export type HotelCardToHotelAmenityUncheckedUpdateInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    hotelAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityCreateManyInput = {
    hotelCardId: string
    hotelAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelAmenityUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityUncheckedUpdateManyInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    hotelAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails: HotelDetailsCreateNestedOneWithoutHotelDetailsToRoomAmenityInput
    roomAmenity: RoomAmenityCreateNestedOneWithoutHotelDetailsToRoomAmenityInput
  }

  export type HotelDetailsToRoomAmenityUncheckedCreateInput = {
    hotelDetailsId: string
    roomAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsToRoomAmenityUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput
    roomAmenity?: RoomAmenityUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateInput = {
    hotelDetailsId?: StringFieldUpdateOperationsInput | string
    roomAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityCreateManyInput = {
    hotelDetailsId: string
    roomAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsToRoomAmenityUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateManyInput = {
    hotelDetailsId?: StringFieldUpdateOperationsInput | string
    roomAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityCreateInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutDestinationToCityInput
    city: CityCreateNestedOneWithoutDestinationToCityInput
  }

  export type DestinationToCityUncheckedCreateInput = {
    destinationId: string
    cityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationToCityUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutDestinationToCityNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationToCityNestedInput
  }

  export type DestinationToCityUncheckedUpdateInput = {
    destinationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityCreateManyInput = {
    destinationId: string
    cityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationToCityUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityUncheckedUpdateManyInput = {
    destinationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type NeighborhoodListRelationFilter = {
    every?: NeighborhoodWhereInput
    some?: NeighborhoodWhereInput
    none?: NeighborhoodWhereInput
  }

  export type LandmarkListRelationFilter = {
    every?: LandmarkWhereInput
    some?: LandmarkWhereInput
    none?: LandmarkWhereInput
  }

  export type DestinationListRelationFilter = {
    every?: DestinationWhereInput
    some?: DestinationWhereInput
    none?: DestinationWhereInput
  }

  export type DestinationToCityListRelationFilter = {
    every?: DestinationToCityWhereInput
    some?: DestinationToCityWhereInput
    none?: DestinationToCityWhereInput
  }

  export type NeighborhoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LandmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationToCityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type NeighborhoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NeighborhoodAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NeighborhoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NeighborhoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NeighborhoodSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LandmarkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandmarkAvgOrderByAggregateInput = {
    order?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LandmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandmarkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandmarkSumOrderByAggregateInput = {
    order?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type HotelCardListRelationFilter = {
    every?: HotelCardWhereInput
    some?: HotelCardWhereInput
    none?: HotelCardWhereInput
  }

  export type HotelCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccommodationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationTypeAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AccommodationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationTypeSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    popularityScore?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationAvgOrderByAggregateInput = {
    order?: SortOrder
    popularityScore?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
  }

  export type DestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    popularityScore?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    type?: SortOrder
    popularityScore?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationSumOrderByAggregateInput = {
    order?: SortOrder
    popularityScore?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type HotelDetailsNullableScalarRelationFilter = {
    is?: HotelDetailsWhereInput | null
    isNot?: HotelDetailsWhereInput | null
  }

  export type HotelCardToLabelListRelationFilter = {
    every?: HotelCardToLabelWhereInput
    some?: HotelCardToLabelWhereInput
    none?: HotelCardToLabelWhereInput
  }

  export type HotelCardToLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetailsId?: SortOrder
  }

  export type LabelAvgOrderByAggregateInput = {
    order?: SortOrder
    priority?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetailsId?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelDetailsId?: SortOrder
  }

  export type LabelSumOrderByAggregateInput = {
    order?: SortOrder
    priority?: SortOrder
  }

  export type HotelGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelGroupAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelGroupSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToHotelHighlightListRelationFilter = {
    every?: HotelCardToHotelHighlightWhereInput
    some?: HotelCardToHotelHighlightWhereInput
    none?: HotelCardToHotelHighlightWhereInput
  }

  export type HotelCardToHotelHighlightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelHighlightCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    isPromoted?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelHighlightAvgOrderByAggregateInput = {
    order?: SortOrder
    priority?: SortOrder
  }

  export type HotelHighlightMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    isPromoted?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelHighlightMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    isPromoted?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelHighlightSumOrderByAggregateInput = {
    order?: SortOrder
    priority?: SortOrder
  }

  export type HotelCardToHotelAmenityListRelationFilter = {
    every?: HotelCardToHotelAmenityWhereInput
    some?: HotelCardToHotelAmenityWhereInput
    none?: HotelCardToHotelAmenityWhereInput
  }

  export type HotelCardToHotelAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelAmenityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelAmenitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelDetailsListRelationFilter = {
    every?: HotelDetailsWhereInput
    some?: HotelDetailsWhereInput
    none?: HotelDetailsWhereInput
  }

  export type HotelDetailsToRoomAmenityListRelationFilter = {
    every?: HotelDetailsToRoomAmenityWhereInput
    some?: HotelDetailsToRoomAmenityWhereInput
    none?: HotelDetailsToRoomAmenityWhereInput
  }

  export type HotelDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelDetailsToRoomAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoomAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToAccessibilityOptionListRelationFilter = {
    every?: HotelCardToAccessibilityOptionWhereInput
    some?: HotelCardToAccessibilityOptionWhereInput
    none?: HotelCardToAccessibilityOptionWhereInput
  }

  export type HotelCardToAccessibilityOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessibilityOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessibilityOptionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AccessibilityOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessibilityOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessibilityOptionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelParkingCountOrderByAggregateInput = {
    id?: SortOrder
    isAvailable?: SortOrder
    spaces?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelParkingAvgOrderByAggregateInput = {
    spaces?: SortOrder
    order?: SortOrder
  }

  export type HotelParkingMaxOrderByAggregateInput = {
    id?: SortOrder
    isAvailable?: SortOrder
    spaces?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelParkingMinOrderByAggregateInput = {
    id?: SortOrder
    isAvailable?: SortOrder
    spaces?: SortOrder
    order?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelParkingSumOrderByAggregateInput = {
    spaces?: SortOrder
    order?: SortOrder
  }

  export type NeighborhoodNullableScalarRelationFilter = {
    is?: NeighborhoodWhereInput | null
    isNot?: NeighborhoodWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    streetNumber?: SortOrder
    streetName?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    cityId?: SortOrder
    neighborhoodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    streetNumber?: SortOrder
    streetName?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    cityId?: SortOrder
    neighborhoodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    streetNumber?: SortOrder
    streetName?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    cityId?: SortOrder
    neighborhoodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelImageCountOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    imageUrl?: SortOrder
    imageType?: SortOrder
    order?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelImageMaxOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    imageUrl?: SortOrder
    imageType?: SortOrder
    order?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelImageMinOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    imageUrl?: SortOrder
    imageType?: SortOrder
    order?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type HotelParkingListRelationFilter = {
    every?: HotelParkingWhereInput
    some?: HotelParkingWhereInput
    none?: HotelParkingWhereInput
  }

  export type HotelImageListRelationFilter = {
    every?: HotelImageWhereInput
    some?: HotelImageWhereInput
    none?: HotelImageWhereInput
  }

  export type HotelAmenityListRelationFilter = {
    every?: HotelAmenityWhereInput
    some?: HotelAmenityWhereInput
    none?: HotelAmenityWhereInput
  }

  export type AccommodationTypeNullableScalarRelationFilter = {
    is?: AccommodationTypeWhereInput | null
    isNot?: AccommodationTypeWhereInput | null
  }

  export type DestinationNullableScalarRelationFilter = {
    is?: DestinationWhereInput | null
    isNot?: DestinationWhereInput | null
  }

  export type HotelGroupNullableScalarRelationFilter = {
    is?: HotelGroupWhereInput | null
    isNot?: HotelGroupWhereInput | null
  }

  export type HotelParkingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    idCity?: SortOrder
    order?: SortOrder
    shortDescription?: SortOrder
    starRating?: SortOrder
    overallRating?: SortOrder
    ratingAdjective?: SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrder
    currency?: SortOrder
    isPartner?: SortOrder
    promoMessage?: SortOrder
    imageMessage?: SortOrder
    cancellationPolicy?: SortOrder
    accommodationTypeId?: SortOrder
    destinationId?: SortOrder
    hotelGroupId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    detailsId?: SortOrder
  }

  export type HotelCardAvgOrderByAggregateInput = {
    order?: SortOrder
    starRating?: SortOrder
    overallRating?: SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HotelCardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    idCity?: SortOrder
    order?: SortOrder
    shortDescription?: SortOrder
    starRating?: SortOrder
    overallRating?: SortOrder
    ratingAdjective?: SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrder
    currency?: SortOrder
    isPartner?: SortOrder
    promoMessage?: SortOrder
    imageMessage?: SortOrder
    cancellationPolicy?: SortOrder
    accommodationTypeId?: SortOrder
    destinationId?: SortOrder
    hotelGroupId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    detailsId?: SortOrder
  }

  export type HotelCardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    idCity?: SortOrder
    order?: SortOrder
    shortDescription?: SortOrder
    starRating?: SortOrder
    overallRating?: SortOrder
    ratingAdjective?: SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrder
    currency?: SortOrder
    isPartner?: SortOrder
    promoMessage?: SortOrder
    imageMessage?: SortOrder
    cancellationPolicy?: SortOrder
    accommodationTypeId?: SortOrder
    destinationId?: SortOrder
    hotelGroupId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    detailsId?: SortOrder
  }

  export type HotelCardSumOrderByAggregateInput = {
    order?: SortOrder
    starRating?: SortOrder
    overallRating?: SortOrder
    reviewCount?: SortOrder
    basePricePerNight?: SortOrder
    regularPrice?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type RoomAmenityListRelationFilter = {
    every?: RoomAmenityWhereInput
    some?: RoomAmenityWhereInput
    none?: RoomAmenityWhereInput
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type RoomAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    idHotelCard?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    idHotelCard?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    idHotelCard?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardScalarRelationFilter = {
    is?: HotelCardWhereInput
    isNot?: HotelCardWhereInput
  }

  export type HotelHighlightScalarRelationFilter = {
    is?: HotelHighlightWhereInput
    isNot?: HotelHighlightWhereInput
  }

  export type HotelCardToHotelHighlightHotelCardIdHotelHighlightIdCompoundUniqueInput = {
    hotelCardId: string
    hotelHighlightId: string
  }

  export type HotelCardToHotelHighlightCountOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelHighlightId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelHighlightAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToHotelHighlightMaxOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelHighlightId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelHighlightMinOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelHighlightId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelHighlightSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LabelScalarRelationFilter = {
    is?: LabelWhereInput
    isNot?: LabelWhereInput
  }

  export type HotelCardToLabelHotelCardIdLabelIdCompoundUniqueInput = {
    hotelCardId: string
    labelId: string
  }

  export type HotelCardToLabelCountOrderByAggregateInput = {
    hotelCardId?: SortOrder
    labelId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToLabelAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToLabelMaxOrderByAggregateInput = {
    hotelCardId?: SortOrder
    labelId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToLabelMinOrderByAggregateInput = {
    hotelCardId?: SortOrder
    labelId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToLabelSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AccessibilityOptionScalarRelationFilter = {
    is?: AccessibilityOptionWhereInput
    isNot?: AccessibilityOptionWhereInput
  }

  export type HotelCardToAccessibilityOptionHotelCardIdAccessibilityOptionIdCompoundUniqueInput = {
    hotelCardId: string
    accessibilityOptionId: string
  }

  export type HotelCardToAccessibilityOptionCountOrderByAggregateInput = {
    hotelCardId?: SortOrder
    accessibilityOptionId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToAccessibilityOptionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToAccessibilityOptionMaxOrderByAggregateInput = {
    hotelCardId?: SortOrder
    accessibilityOptionId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToAccessibilityOptionMinOrderByAggregateInput = {
    hotelCardId?: SortOrder
    accessibilityOptionId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToAccessibilityOptionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelAmenityScalarRelationFilter = {
    is?: HotelAmenityWhereInput
    isNot?: HotelAmenityWhereInput
  }

  export type HotelCardToHotelAmenityHotelCardIdHotelAmenityIdCompoundUniqueInput = {
    hotelCardId: string
    hotelAmenityId: string
  }

  export type HotelCardToHotelAmenityCountOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelAmenityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelCardToHotelAmenityMaxOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelAmenityMinOrderByAggregateInput = {
    hotelCardId?: SortOrder
    hotelAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelCardToHotelAmenitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelDetailsScalarRelationFilter = {
    is?: HotelDetailsWhereInput
    isNot?: HotelDetailsWhereInput
  }

  export type RoomAmenityScalarRelationFilter = {
    is?: RoomAmenityWhereInput
    isNot?: RoomAmenityWhereInput
  }

  export type HotelDetailsToRoomAmenityHotelDetailsIdRoomAmenityIdCompoundUniqueInput = {
    hotelDetailsId: string
    roomAmenityId: string
  }

  export type HotelDetailsToRoomAmenityCountOrderByAggregateInput = {
    hotelDetailsId?: SortOrder
    roomAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsToRoomAmenityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HotelDetailsToRoomAmenityMaxOrderByAggregateInput = {
    hotelDetailsId?: SortOrder
    roomAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsToRoomAmenityMinOrderByAggregateInput = {
    hotelDetailsId?: SortOrder
    roomAmenityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelDetailsToRoomAmenitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DestinationScalarRelationFilter = {
    is?: DestinationWhereInput
    isNot?: DestinationWhereInput
  }

  export type DestinationToCityDestinationIdCityIdCompoundUniqueInput = {
    destinationId: string
    cityId: string
  }

  export type DestinationToCityCountOrderByAggregateInput = {
    destinationId?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationToCityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DestinationToCityMaxOrderByAggregateInput = {
    destinationId?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationToCityMinOrderByAggregateInput = {
    destinationId?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationToCitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type NeighborhoodCreateNestedManyWithoutCityInput = {
    create?: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput> | NeighborhoodCreateWithoutCityInput[] | NeighborhoodUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutCityInput | NeighborhoodCreateOrConnectWithoutCityInput[]
    createMany?: NeighborhoodCreateManyCityInputEnvelope
    connect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
  }

  export type LandmarkCreateNestedManyWithoutCityInput = {
    create?: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput> | LandmarkCreateWithoutCityInput[] | LandmarkUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LandmarkCreateOrConnectWithoutCityInput | LandmarkCreateOrConnectWithoutCityInput[]
    createMany?: LandmarkCreateManyCityInputEnvelope
    connect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type DestinationCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type DestinationToCityCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput> | DestinationToCityCreateWithoutCityInput[] | DestinationToCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutCityInput | DestinationToCityCreateOrConnectWithoutCityInput[]
    createMany?: DestinationToCityCreateManyCityInputEnvelope
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
  }

  export type NeighborhoodUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput> | NeighborhoodCreateWithoutCityInput[] | NeighborhoodUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutCityInput | NeighborhoodCreateOrConnectWithoutCityInput[]
    createMany?: NeighborhoodCreateManyCityInputEnvelope
    connect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
  }

  export type LandmarkUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput> | LandmarkCreateWithoutCityInput[] | LandmarkUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LandmarkCreateOrConnectWithoutCityInput | LandmarkCreateOrConnectWithoutCityInput[]
    createMany?: LandmarkCreateManyCityInputEnvelope
    connect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type DestinationUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type DestinationToCityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput> | DestinationToCityCreateWithoutCityInput[] | DestinationToCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutCityInput | DestinationToCityCreateOrConnectWithoutCityInput[]
    createMany?: DestinationToCityCreateManyCityInputEnvelope
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type NeighborhoodUpdateManyWithoutCityNestedInput = {
    create?: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput> | NeighborhoodCreateWithoutCityInput[] | NeighborhoodUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutCityInput | NeighborhoodCreateOrConnectWithoutCityInput[]
    upsert?: NeighborhoodUpsertWithWhereUniqueWithoutCityInput | NeighborhoodUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: NeighborhoodCreateManyCityInputEnvelope
    set?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    disconnect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    delete?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    connect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    update?: NeighborhoodUpdateWithWhereUniqueWithoutCityInput | NeighborhoodUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: NeighborhoodUpdateManyWithWhereWithoutCityInput | NeighborhoodUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: NeighborhoodScalarWhereInput | NeighborhoodScalarWhereInput[]
  }

  export type LandmarkUpdateManyWithoutCityNestedInput = {
    create?: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput> | LandmarkCreateWithoutCityInput[] | LandmarkUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LandmarkCreateOrConnectWithoutCityInput | LandmarkCreateOrConnectWithoutCityInput[]
    upsert?: LandmarkUpsertWithWhereUniqueWithoutCityInput | LandmarkUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LandmarkCreateManyCityInputEnvelope
    set?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    disconnect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    delete?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    connect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    update?: LandmarkUpdateWithWhereUniqueWithoutCityInput | LandmarkUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LandmarkUpdateManyWithWhereWithoutCityInput | LandmarkUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LandmarkScalarWhereInput | LandmarkScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type DestinationUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCityInput | DestinationUpsertWithWhereUniqueWithoutCityInput[]
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCityInput | DestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCityInput | DestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type DestinationToCityUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput> | DestinationToCityCreateWithoutCityInput[] | DestinationToCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutCityInput | DestinationToCityCreateOrConnectWithoutCityInput[]
    upsert?: DestinationToCityUpsertWithWhereUniqueWithoutCityInput | DestinationToCityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DestinationToCityCreateManyCityInputEnvelope
    set?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    disconnect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    delete?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    update?: DestinationToCityUpdateWithWhereUniqueWithoutCityInput | DestinationToCityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationToCityUpdateManyWithWhereWithoutCityInput | DestinationToCityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
  }

  export type NeighborhoodUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput> | NeighborhoodCreateWithoutCityInput[] | NeighborhoodUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutCityInput | NeighborhoodCreateOrConnectWithoutCityInput[]
    upsert?: NeighborhoodUpsertWithWhereUniqueWithoutCityInput | NeighborhoodUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: NeighborhoodCreateManyCityInputEnvelope
    set?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    disconnect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    delete?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    connect?: NeighborhoodWhereUniqueInput | NeighborhoodWhereUniqueInput[]
    update?: NeighborhoodUpdateWithWhereUniqueWithoutCityInput | NeighborhoodUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: NeighborhoodUpdateManyWithWhereWithoutCityInput | NeighborhoodUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: NeighborhoodScalarWhereInput | NeighborhoodScalarWhereInput[]
  }

  export type LandmarkUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput> | LandmarkCreateWithoutCityInput[] | LandmarkUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LandmarkCreateOrConnectWithoutCityInput | LandmarkCreateOrConnectWithoutCityInput[]
    upsert?: LandmarkUpsertWithWhereUniqueWithoutCityInput | LandmarkUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LandmarkCreateManyCityInputEnvelope
    set?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    disconnect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    delete?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    connect?: LandmarkWhereUniqueInput | LandmarkWhereUniqueInput[]
    update?: LandmarkUpdateWithWhereUniqueWithoutCityInput | LandmarkUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LandmarkUpdateManyWithWhereWithoutCityInput | LandmarkUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LandmarkScalarWhereInput | LandmarkScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type DestinationUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCityInput | DestinationUpsertWithWhereUniqueWithoutCityInput[]
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCityInput | DestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCityInput | DestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type DestinationToCityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput> | DestinationToCityCreateWithoutCityInput[] | DestinationToCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutCityInput | DestinationToCityCreateOrConnectWithoutCityInput[]
    upsert?: DestinationToCityUpsertWithWhereUniqueWithoutCityInput | DestinationToCityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DestinationToCityCreateManyCityInputEnvelope
    set?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    disconnect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    delete?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    update?: DestinationToCityUpdateWithWhereUniqueWithoutCityInput | DestinationToCityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationToCityUpdateManyWithWhereWithoutCityInput | DestinationToCityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutNeighborhoodsInput = {
    create?: XOR<CityCreateWithoutNeighborhoodsInput, CityUncheckedCreateWithoutNeighborhoodsInput>
    connectOrCreate?: CityCreateOrConnectWithoutNeighborhoodsInput
    connect?: CityWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutNeighborhoodInput = {
    create?: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput> | AddressCreateWithoutNeighborhoodInput[] | AddressUncheckedCreateWithoutNeighborhoodInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutNeighborhoodInput | AddressCreateOrConnectWithoutNeighborhoodInput[]
    createMany?: AddressCreateManyNeighborhoodInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutNeighborhoodInput = {
    create?: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput> | AddressCreateWithoutNeighborhoodInput[] | AddressUncheckedCreateWithoutNeighborhoodInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutNeighborhoodInput | AddressCreateOrConnectWithoutNeighborhoodInput[]
    createMany?: AddressCreateManyNeighborhoodInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutNeighborhoodsNestedInput = {
    create?: XOR<CityCreateWithoutNeighborhoodsInput, CityUncheckedCreateWithoutNeighborhoodsInput>
    connectOrCreate?: CityCreateOrConnectWithoutNeighborhoodsInput
    upsert?: CityUpsertWithoutNeighborhoodsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutNeighborhoodsInput, CityUpdateWithoutNeighborhoodsInput>, CityUncheckedUpdateWithoutNeighborhoodsInput>
  }

  export type AddressUpdateManyWithoutNeighborhoodNestedInput = {
    create?: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput> | AddressCreateWithoutNeighborhoodInput[] | AddressUncheckedCreateWithoutNeighborhoodInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutNeighborhoodInput | AddressCreateOrConnectWithoutNeighborhoodInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutNeighborhoodInput | AddressUpsertWithWhereUniqueWithoutNeighborhoodInput[]
    createMany?: AddressCreateManyNeighborhoodInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutNeighborhoodInput | AddressUpdateWithWhereUniqueWithoutNeighborhoodInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutNeighborhoodInput | AddressUpdateManyWithWhereWithoutNeighborhoodInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutNeighborhoodNestedInput = {
    create?: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput> | AddressCreateWithoutNeighborhoodInput[] | AddressUncheckedCreateWithoutNeighborhoodInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutNeighborhoodInput | AddressCreateOrConnectWithoutNeighborhoodInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutNeighborhoodInput | AddressUpsertWithWhereUniqueWithoutNeighborhoodInput[]
    createMany?: AddressCreateManyNeighborhoodInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutNeighborhoodInput | AddressUpdateWithWhereUniqueWithoutNeighborhoodInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutNeighborhoodInput | AddressUpdateManyWithWhereWithoutNeighborhoodInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutLandmarksInput = {
    create?: XOR<CityCreateWithoutLandmarksInput, CityUncheckedCreateWithoutLandmarksInput>
    connectOrCreate?: CityCreateOrConnectWithoutLandmarksInput
    connect?: CityWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CityUpdateOneRequiredWithoutLandmarksNestedInput = {
    create?: XOR<CityCreateWithoutLandmarksInput, CityUncheckedCreateWithoutLandmarksInput>
    connectOrCreate?: CityCreateOrConnectWithoutLandmarksInput
    upsert?: CityUpsertWithoutLandmarksInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutLandmarksInput, CityUpdateWithoutLandmarksInput>, CityUncheckedUpdateWithoutLandmarksInput>
  }

  export type HotelCardCreateNestedManyWithoutAccommodationTypeInput = {
    create?: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput> | HotelCardCreateWithoutAccommodationTypeInput[] | HotelCardUncheckedCreateWithoutAccommodationTypeInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutAccommodationTypeInput | HotelCardCreateOrConnectWithoutAccommodationTypeInput[]
    createMany?: HotelCardCreateManyAccommodationTypeInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutAccommodationTypeInput = {
    create?: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput> | HotelCardCreateWithoutAccommodationTypeInput[] | HotelCardUncheckedCreateWithoutAccommodationTypeInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutAccommodationTypeInput | HotelCardCreateOrConnectWithoutAccommodationTypeInput[]
    createMany?: HotelCardCreateManyAccommodationTypeInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUpdateManyWithoutAccommodationTypeNestedInput = {
    create?: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput> | HotelCardCreateWithoutAccommodationTypeInput[] | HotelCardUncheckedCreateWithoutAccommodationTypeInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutAccommodationTypeInput | HotelCardCreateOrConnectWithoutAccommodationTypeInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutAccommodationTypeInput | HotelCardUpsertWithWhereUniqueWithoutAccommodationTypeInput[]
    createMany?: HotelCardCreateManyAccommodationTypeInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutAccommodationTypeInput | HotelCardUpdateWithWhereUniqueWithoutAccommodationTypeInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutAccommodationTypeInput | HotelCardUpdateManyWithWhereWithoutAccommodationTypeInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutAccommodationTypeNestedInput = {
    create?: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput> | HotelCardCreateWithoutAccommodationTypeInput[] | HotelCardUncheckedCreateWithoutAccommodationTypeInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutAccommodationTypeInput | HotelCardCreateOrConnectWithoutAccommodationTypeInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutAccommodationTypeInput | HotelCardUpsertWithWhereUniqueWithoutAccommodationTypeInput[]
    createMany?: HotelCardCreateManyAccommodationTypeInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutAccommodationTypeInput | HotelCardUpdateWithWhereUniqueWithoutAccommodationTypeInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutAccommodationTypeInput | HotelCardUpdateManyWithWhereWithoutAccommodationTypeInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardCreateNestedManyWithoutDestinationInput = {
    create?: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput> | HotelCardCreateWithoutDestinationInput[] | HotelCardUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDestinationInput | HotelCardCreateOrConnectWithoutDestinationInput[]
    createMany?: HotelCardCreateManyDestinationInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type CityCreateNestedManyWithoutDestinationsInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput> | CityCreateWithoutDestinationsInput[] | CityUncheckedCreateWithoutDestinationsInput[]
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput | CityCreateOrConnectWithoutDestinationsInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DestinationToCityCreateNestedManyWithoutDestinationInput = {
    create?: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput> | DestinationToCityCreateWithoutDestinationInput[] | DestinationToCityUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutDestinationInput | DestinationToCityCreateOrConnectWithoutDestinationInput[]
    createMany?: DestinationToCityCreateManyDestinationInputEnvelope
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput> | HotelCardCreateWithoutDestinationInput[] | HotelCardUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDestinationInput | HotelCardCreateOrConnectWithoutDestinationInput[]
    createMany?: HotelCardCreateManyDestinationInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutDestinationsInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput> | CityCreateWithoutDestinationsInput[] | CityUncheckedCreateWithoutDestinationsInput[]
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput | CityCreateOrConnectWithoutDestinationsInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DestinationToCityUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput> | DestinationToCityCreateWithoutDestinationInput[] | DestinationToCityUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutDestinationInput | DestinationToCityCreateOrConnectWithoutDestinationInput[]
    createMany?: DestinationToCityCreateManyDestinationInputEnvelope
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotelCardUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput> | HotelCardCreateWithoutDestinationInput[] | HotelCardUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDestinationInput | HotelCardCreateOrConnectWithoutDestinationInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutDestinationInput | HotelCardUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: HotelCardCreateManyDestinationInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutDestinationInput | HotelCardUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutDestinationInput | HotelCardUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type CityUpdateManyWithoutDestinationsNestedInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput> | CityCreateWithoutDestinationsInput[] | CityUncheckedCreateWithoutDestinationsInput[]
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput | CityCreateOrConnectWithoutDestinationsInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutDestinationsInput | CityUpsertWithWhereUniqueWithoutDestinationsInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutDestinationsInput | CityUpdateWithWhereUniqueWithoutDestinationsInput[]
    updateMany?: CityUpdateManyWithWhereWithoutDestinationsInput | CityUpdateManyWithWhereWithoutDestinationsInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DestinationToCityUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput> | DestinationToCityCreateWithoutDestinationInput[] | DestinationToCityUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutDestinationInput | DestinationToCityCreateOrConnectWithoutDestinationInput[]
    upsert?: DestinationToCityUpsertWithWhereUniqueWithoutDestinationInput | DestinationToCityUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: DestinationToCityCreateManyDestinationInputEnvelope
    set?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    disconnect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    delete?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    update?: DestinationToCityUpdateWithWhereUniqueWithoutDestinationInput | DestinationToCityUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: DestinationToCityUpdateManyWithWhereWithoutDestinationInput | DestinationToCityUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput> | HotelCardCreateWithoutDestinationInput[] | HotelCardUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDestinationInput | HotelCardCreateOrConnectWithoutDestinationInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutDestinationInput | HotelCardUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: HotelCardCreateManyDestinationInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutDestinationInput | HotelCardUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutDestinationInput | HotelCardUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutDestinationsNestedInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput> | CityCreateWithoutDestinationsInput[] | CityUncheckedCreateWithoutDestinationsInput[]
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput | CityCreateOrConnectWithoutDestinationsInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutDestinationsInput | CityUpsertWithWhereUniqueWithoutDestinationsInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutDestinationsInput | CityUpdateWithWhereUniqueWithoutDestinationsInput[]
    updateMany?: CityUpdateManyWithWhereWithoutDestinationsInput | CityUpdateManyWithWhereWithoutDestinationsInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DestinationToCityUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput> | DestinationToCityCreateWithoutDestinationInput[] | DestinationToCityUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: DestinationToCityCreateOrConnectWithoutDestinationInput | DestinationToCityCreateOrConnectWithoutDestinationInput[]
    upsert?: DestinationToCityUpsertWithWhereUniqueWithoutDestinationInput | DestinationToCityUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: DestinationToCityCreateManyDestinationInputEnvelope
    set?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    disconnect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    delete?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    connect?: DestinationToCityWhereUniqueInput | DestinationToCityWhereUniqueInput[]
    update?: DestinationToCityUpdateWithWhereUniqueWithoutDestinationInput | DestinationToCityUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: DestinationToCityUpdateManyWithWhereWithoutDestinationInput | DestinationToCityUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
  }

  export type HotelDetailsCreateNestedOneWithoutLabelInput = {
    create?: XOR<HotelDetailsCreateWithoutLabelInput, HotelDetailsUncheckedCreateWithoutLabelInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutLabelInput
    connect?: HotelDetailsWhereUniqueInput
  }

  export type HotelCardToLabelCreateNestedManyWithoutLabelInput = {
    create?: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput> | HotelCardToLabelCreateWithoutLabelInput[] | HotelCardToLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutLabelInput | HotelCardToLabelCreateOrConnectWithoutLabelInput[]
    createMany?: HotelCardToLabelCreateManyLabelInputEnvelope
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
  }

  export type HotelCardToLabelUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput> | HotelCardToLabelCreateWithoutLabelInput[] | HotelCardToLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutLabelInput | HotelCardToLabelCreateOrConnectWithoutLabelInput[]
    createMany?: HotelCardToLabelCreateManyLabelInputEnvelope
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
  }

  export type HotelDetailsUpdateOneWithoutLabelNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutLabelInput, HotelDetailsUncheckedCreateWithoutLabelInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutLabelInput
    upsert?: HotelDetailsUpsertWithoutLabelInput
    disconnect?: HotelDetailsWhereInput | boolean
    delete?: HotelDetailsWhereInput | boolean
    connect?: HotelDetailsWhereUniqueInput
    update?: XOR<XOR<HotelDetailsUpdateToOneWithWhereWithoutLabelInput, HotelDetailsUpdateWithoutLabelInput>, HotelDetailsUncheckedUpdateWithoutLabelInput>
  }

  export type HotelCardToLabelUpdateManyWithoutLabelNestedInput = {
    create?: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput> | HotelCardToLabelCreateWithoutLabelInput[] | HotelCardToLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutLabelInput | HotelCardToLabelCreateOrConnectWithoutLabelInput[]
    upsert?: HotelCardToLabelUpsertWithWhereUniqueWithoutLabelInput | HotelCardToLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: HotelCardToLabelCreateManyLabelInputEnvelope
    set?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    disconnect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    delete?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    update?: HotelCardToLabelUpdateWithWhereUniqueWithoutLabelInput | HotelCardToLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: HotelCardToLabelUpdateManyWithWhereWithoutLabelInput | HotelCardToLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
  }

  export type HotelCardToLabelUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput> | HotelCardToLabelCreateWithoutLabelInput[] | HotelCardToLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutLabelInput | HotelCardToLabelCreateOrConnectWithoutLabelInput[]
    upsert?: HotelCardToLabelUpsertWithWhereUniqueWithoutLabelInput | HotelCardToLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: HotelCardToLabelCreateManyLabelInputEnvelope
    set?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    disconnect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    delete?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    update?: HotelCardToLabelUpdateWithWhereUniqueWithoutLabelInput | HotelCardToLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: HotelCardToLabelUpdateManyWithWhereWithoutLabelInput | HotelCardToLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
  }

  export type HotelCardCreateNestedManyWithoutHotelGroupInput = {
    create?: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput> | HotelCardCreateWithoutHotelGroupInput[] | HotelCardUncheckedCreateWithoutHotelGroupInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelGroupInput | HotelCardCreateOrConnectWithoutHotelGroupInput[]
    createMany?: HotelCardCreateManyHotelGroupInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutHotelGroupInput = {
    create?: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput> | HotelCardCreateWithoutHotelGroupInput[] | HotelCardUncheckedCreateWithoutHotelGroupInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelGroupInput | HotelCardCreateOrConnectWithoutHotelGroupInput[]
    createMany?: HotelCardCreateManyHotelGroupInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUpdateManyWithoutHotelGroupNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput> | HotelCardCreateWithoutHotelGroupInput[] | HotelCardUncheckedCreateWithoutHotelGroupInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelGroupInput | HotelCardCreateOrConnectWithoutHotelGroupInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutHotelGroupInput | HotelCardUpsertWithWhereUniqueWithoutHotelGroupInput[]
    createMany?: HotelCardCreateManyHotelGroupInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutHotelGroupInput | HotelCardUpdateWithWhereUniqueWithoutHotelGroupInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutHotelGroupInput | HotelCardUpdateManyWithWhereWithoutHotelGroupInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutHotelGroupNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput> | HotelCardCreateWithoutHotelGroupInput[] | HotelCardUncheckedCreateWithoutHotelGroupInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelGroupInput | HotelCardCreateOrConnectWithoutHotelGroupInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutHotelGroupInput | HotelCardUpsertWithWhereUniqueWithoutHotelGroupInput[]
    createMany?: HotelCardCreateManyHotelGroupInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutHotelGroupInput | HotelCardUpdateWithWhereUniqueWithoutHotelGroupInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutHotelGroupInput | HotelCardUpdateManyWithWhereWithoutHotelGroupInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardToHotelHighlightCreateNestedManyWithoutHotelHighlightInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput> | HotelCardToHotelHighlightCreateWithoutHotelHighlightInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelHighlightInputEnvelope
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
  }

  export type HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelHighlightInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput> | HotelCardToHotelHighlightCreateWithoutHotelHighlightInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelHighlightInputEnvelope
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
  }

  export type HotelCardToHotelHighlightUpdateManyWithoutHotelHighlightNestedInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput> | HotelCardToHotelHighlightCreateWithoutHotelHighlightInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput[]
    upsert?: HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelHighlightInput | HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelHighlightInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelHighlightInputEnvelope
    set?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    disconnect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    delete?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    update?: HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelHighlightInput | HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelHighlightInput[]
    updateMany?: HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelHighlightInput | HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelHighlightInput[]
    deleteMany?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
  }

  export type HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelHighlightNestedInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput> | HotelCardToHotelHighlightCreateWithoutHotelHighlightInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput[]
    upsert?: HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelHighlightInput | HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelHighlightInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelHighlightInputEnvelope
    set?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    disconnect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    delete?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    update?: HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelHighlightInput | HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelHighlightInput[]
    updateMany?: HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelHighlightInput | HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelHighlightInput[]
    deleteMany?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
  }

  export type HotelCardCreateNestedManyWithoutHotelAmenityInput = {
    create?: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput> | HotelCardCreateWithoutHotelAmenityInput[] | HotelCardUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelAmenityInput | HotelCardCreateOrConnectWithoutHotelAmenityInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardToHotelAmenityCreateNestedManyWithoutHotelAmenityInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput> | HotelCardToHotelAmenityCreateWithoutHotelAmenityInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelAmenityInputEnvelope
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutHotelAmenityInput = {
    create?: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput> | HotelCardCreateWithoutHotelAmenityInput[] | HotelCardUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelAmenityInput | HotelCardCreateOrConnectWithoutHotelAmenityInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelAmenityInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput> | HotelCardToHotelAmenityCreateWithoutHotelAmenityInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelAmenityInputEnvelope
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
  }

  export type HotelCardUpdateManyWithoutHotelAmenityNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput> | HotelCardCreateWithoutHotelAmenityInput[] | HotelCardUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelAmenityInput | HotelCardCreateOrConnectWithoutHotelAmenityInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutHotelAmenityInput | HotelCardUpsertWithWhereUniqueWithoutHotelAmenityInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutHotelAmenityInput | HotelCardUpdateWithWhereUniqueWithoutHotelAmenityInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutHotelAmenityInput | HotelCardUpdateManyWithWhereWithoutHotelAmenityInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardToHotelAmenityUpdateManyWithoutHotelAmenityNestedInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput> | HotelCardToHotelAmenityCreateWithoutHotelAmenityInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput[]
    upsert?: HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelAmenityInput | HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelAmenityInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelAmenityInputEnvelope
    set?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    disconnect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    delete?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    update?: HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelAmenityInput | HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelAmenityInput[]
    updateMany?: HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelAmenityInput | HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelAmenityInput[]
    deleteMany?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutHotelAmenityNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput> | HotelCardCreateWithoutHotelAmenityInput[] | HotelCardUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelAmenityInput | HotelCardCreateOrConnectWithoutHotelAmenityInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutHotelAmenityInput | HotelCardUpsertWithWhereUniqueWithoutHotelAmenityInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutHotelAmenityInput | HotelCardUpdateWithWhereUniqueWithoutHotelAmenityInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutHotelAmenityInput | HotelCardUpdateManyWithWhereWithoutHotelAmenityInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelAmenityNestedInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput> | HotelCardToHotelAmenityCreateWithoutHotelAmenityInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput[]
    upsert?: HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelAmenityInput | HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelAmenityInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelAmenityInputEnvelope
    set?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    disconnect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    delete?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    update?: HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelAmenityInput | HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelAmenityInput[]
    updateMany?: HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelAmenityInput | HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelAmenityInput[]
    deleteMany?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
  }

  export type HotelDetailsCreateNestedManyWithoutRoomAmenityInput = {
    create?: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsCreateWithoutRoomAmenityInput[] | HotelDetailsUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutRoomAmenityInput | HotelDetailsCreateOrConnectWithoutRoomAmenityInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
  }

  export type HotelDetailsToRoomAmenityCreateNestedManyWithoutRoomAmenityInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyRoomAmenityInputEnvelope
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
  }

  export type HotelDetailsUncheckedCreateNestedManyWithoutRoomAmenityInput = {
    create?: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsCreateWithoutRoomAmenityInput[] | HotelDetailsUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutRoomAmenityInput | HotelDetailsCreateOrConnectWithoutRoomAmenityInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
  }

  export type HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutRoomAmenityInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyRoomAmenityInputEnvelope
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
  }

  export type HotelDetailsUpdateManyWithoutRoomAmenityNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsCreateWithoutRoomAmenityInput[] | HotelDetailsUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutRoomAmenityInput | HotelDetailsCreateOrConnectWithoutRoomAmenityInput[]
    upsert?: HotelDetailsUpsertWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsUpsertWithWhereUniqueWithoutRoomAmenityInput[]
    set?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    disconnect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    delete?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    update?: HotelDetailsUpdateWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsUpdateWithWhereUniqueWithoutRoomAmenityInput[]
    updateMany?: HotelDetailsUpdateManyWithWhereWithoutRoomAmenityInput | HotelDetailsUpdateManyWithWhereWithoutRoomAmenityInput[]
    deleteMany?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
  }

  export type HotelDetailsToRoomAmenityUpdateManyWithoutRoomAmenityNestedInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput[]
    upsert?: HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutRoomAmenityInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyRoomAmenityInputEnvelope
    set?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    disconnect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    delete?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    update?: HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutRoomAmenityInput[]
    updateMany?: HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutRoomAmenityInput[]
    deleteMany?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
  }

  export type HotelDetailsUncheckedUpdateManyWithoutRoomAmenityNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsCreateWithoutRoomAmenityInput[] | HotelDetailsUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutRoomAmenityInput | HotelDetailsCreateOrConnectWithoutRoomAmenityInput[]
    upsert?: HotelDetailsUpsertWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsUpsertWithWhereUniqueWithoutRoomAmenityInput[]
    set?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    disconnect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    delete?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    update?: HotelDetailsUpdateWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsUpdateWithWhereUniqueWithoutRoomAmenityInput[]
    updateMany?: HotelDetailsUpdateManyWithWhereWithoutRoomAmenityInput | HotelDetailsUpdateManyWithWhereWithoutRoomAmenityInput[]
    deleteMany?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutRoomAmenityNestedInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput> | HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput[]
    upsert?: HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutRoomAmenityInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyRoomAmenityInputEnvelope
    set?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    disconnect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    delete?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    update?: HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutRoomAmenityInput[]
    updateMany?: HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutRoomAmenityInput | HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutRoomAmenityInput[]
    deleteMany?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
  }

  export type HotelCardToAccessibilityOptionCreateNestedManyWithoutAccessibilityOptionInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput> | HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInputEnvelope
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
  }

  export type HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutAccessibilityOptionInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput> | HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInputEnvelope
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
  }

  export type HotelCardToAccessibilityOptionUpdateManyWithoutAccessibilityOptionNestedInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput> | HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput[]
    upsert?: HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutAccessibilityOptionInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInputEnvelope
    set?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    disconnect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    delete?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    update?: HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutAccessibilityOptionInput[]
    updateMany?: HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutAccessibilityOptionInput[]
    deleteMany?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutAccessibilityOptionNestedInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput> | HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput[]
    upsert?: HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutAccessibilityOptionInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInputEnvelope
    set?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    disconnect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    delete?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    update?: HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutAccessibilityOptionInput[]
    updateMany?: HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutAccessibilityOptionInput | HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutAccessibilityOptionInput[]
    deleteMany?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
  }

  export type HotelCardCreateNestedManyWithoutParkingInput = {
    create?: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput> | HotelCardCreateWithoutParkingInput[] | HotelCardUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutParkingInput | HotelCardCreateOrConnectWithoutParkingInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutParkingInput = {
    create?: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput> | HotelCardCreateWithoutParkingInput[] | HotelCardUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutParkingInput | HotelCardCreateOrConnectWithoutParkingInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUpdateManyWithoutParkingNestedInput = {
    create?: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput> | HotelCardCreateWithoutParkingInput[] | HotelCardUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutParkingInput | HotelCardCreateOrConnectWithoutParkingInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutParkingInput | HotelCardUpsertWithWhereUniqueWithoutParkingInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutParkingInput | HotelCardUpdateWithWhereUniqueWithoutParkingInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutParkingInput | HotelCardUpdateManyWithWhereWithoutParkingInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutParkingNestedInput = {
    create?: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput> | HotelCardCreateWithoutParkingInput[] | HotelCardUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutParkingInput | HotelCardCreateOrConnectWithoutParkingInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutParkingInput | HotelCardUpsertWithWhereUniqueWithoutParkingInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutParkingInput | HotelCardUpdateWithWhereUniqueWithoutParkingInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutParkingInput | HotelCardUpdateManyWithWhereWithoutParkingInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    connect?: CityWhereUniqueInput
  }

  export type NeighborhoodCreateNestedOneWithoutAddressesInput = {
    create?: XOR<NeighborhoodCreateWithoutAddressesInput, NeighborhoodUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutAddressesInput
    connect?: NeighborhoodWhereUniqueInput
  }

  export type HotelDetailsCreateNestedManyWithoutAddressInput = {
    create?: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput> | HotelDetailsCreateWithoutAddressInput[] | HotelDetailsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutAddressInput | HotelDetailsCreateOrConnectWithoutAddressInput[]
    createMany?: HotelDetailsCreateManyAddressInputEnvelope
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput> | UserCreateWithoutAddressInput[] | UserUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput | UserCreateOrConnectWithoutAddressInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HotelDetailsUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput> | HotelDetailsCreateWithoutAddressInput[] | HotelDetailsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutAddressInput | HotelDetailsCreateOrConnectWithoutAddressInput[]
    createMany?: HotelDetailsCreateManyAddressInputEnvelope
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput> | UserCreateWithoutAddressInput[] | UserUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput | UserCreateOrConnectWithoutAddressInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    upsert?: CityUpsertWithoutAddressesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAddressesInput, CityUpdateWithoutAddressesInput>, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type NeighborhoodUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<NeighborhoodCreateWithoutAddressesInput, NeighborhoodUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: NeighborhoodCreateOrConnectWithoutAddressesInput
    upsert?: NeighborhoodUpsertWithoutAddressesInput
    disconnect?: NeighborhoodWhereInput | boolean
    delete?: NeighborhoodWhereInput | boolean
    connect?: NeighborhoodWhereUniqueInput
    update?: XOR<XOR<NeighborhoodUpdateToOneWithWhereWithoutAddressesInput, NeighborhoodUpdateWithoutAddressesInput>, NeighborhoodUncheckedUpdateWithoutAddressesInput>
  }

  export type HotelDetailsUpdateManyWithoutAddressNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput> | HotelDetailsCreateWithoutAddressInput[] | HotelDetailsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutAddressInput | HotelDetailsCreateOrConnectWithoutAddressInput[]
    upsert?: HotelDetailsUpsertWithWhereUniqueWithoutAddressInput | HotelDetailsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: HotelDetailsCreateManyAddressInputEnvelope
    set?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    disconnect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    delete?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    update?: HotelDetailsUpdateWithWhereUniqueWithoutAddressInput | HotelDetailsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: HotelDetailsUpdateManyWithWhereWithoutAddressInput | HotelDetailsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
  }

  export type UserUpdateManyWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput> | UserCreateWithoutAddressInput[] | UserUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput | UserCreateOrConnectWithoutAddressInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddressInput | UserUpsertWithWhereUniqueWithoutAddressInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddressInput | UserUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddressInput | UserUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HotelDetailsUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput> | HotelDetailsCreateWithoutAddressInput[] | HotelDetailsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutAddressInput | HotelDetailsCreateOrConnectWithoutAddressInput[]
    upsert?: HotelDetailsUpsertWithWhereUniqueWithoutAddressInput | HotelDetailsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: HotelDetailsCreateManyAddressInputEnvelope
    set?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    disconnect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    delete?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    connect?: HotelDetailsWhereUniqueInput | HotelDetailsWhereUniqueInput[]
    update?: HotelDetailsUpdateWithWhereUniqueWithoutAddressInput | HotelDetailsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: HotelDetailsUpdateManyWithWhereWithoutAddressInput | HotelDetailsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput> | UserCreateWithoutAddressInput[] | UserUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput | UserCreateOrConnectWithoutAddressInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddressInput | UserUpsertWithWhereUniqueWithoutAddressInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddressInput | UserUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddressInput | UserUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HotelCardCreateNestedManyWithoutImagesInput = {
    create?: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput> | HotelCardCreateWithoutImagesInput[] | HotelCardUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutImagesInput | HotelCardCreateOrConnectWithoutImagesInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput> | HotelCardCreateWithoutImagesInput[] | HotelCardUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutImagesInput | HotelCardCreateOrConnectWithoutImagesInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelCardUpdateManyWithoutImagesNestedInput = {
    create?: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput> | HotelCardCreateWithoutImagesInput[] | HotelCardUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutImagesInput | HotelCardCreateOrConnectWithoutImagesInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutImagesInput | HotelCardUpsertWithWhereUniqueWithoutImagesInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutImagesInput | HotelCardUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutImagesInput | HotelCardUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput> | HotelCardCreateWithoutImagesInput[] | HotelCardUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutImagesInput | HotelCardCreateOrConnectWithoutImagesInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutImagesInput | HotelCardUpsertWithWhereUniqueWithoutImagesInput[]
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutImagesInput | HotelCardUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutImagesInput | HotelCardUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelParkingCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput> | HotelParkingCreateWithoutHotelCardInput[] | HotelParkingUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelParkingCreateOrConnectWithoutHotelCardInput | HotelParkingCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
  }

  export type HotelImageCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput> | HotelImageCreateWithoutHotelCardInput[] | HotelImageUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelImageCreateOrConnectWithoutHotelCardInput | HotelImageCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
  }

  export type HotelAmenityCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelAmenityCreateWithoutHotelCardInput[] | HotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardInput | HotelAmenityCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type HotelDetailsCreateNestedOneWithoutHotelCardInput = {
    create?: XOR<HotelDetailsCreateWithoutHotelCardInput, HotelDetailsUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutHotelCardInput
    connect?: HotelDetailsWhereUniqueInput
  }

  export type AccommodationTypeCreateNestedOneWithoutHotelCardInput = {
    create?: XOR<AccommodationTypeCreateWithoutHotelCardInput, AccommodationTypeUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: AccommodationTypeCreateOrConnectWithoutHotelCardInput
    connect?: AccommodationTypeWhereUniqueInput
  }

  export type DestinationCreateNestedOneWithoutHotelCardInput = {
    create?: XOR<DestinationCreateWithoutHotelCardInput, DestinationUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutHotelCardInput
    connect?: DestinationWhereUniqueInput
  }

  export type HotelGroupCreateNestedOneWithoutHotelCardInput = {
    create?: XOR<HotelGroupCreateWithoutHotelCardInput, HotelGroupUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: HotelGroupCreateOrConnectWithoutHotelCardInput
    connect?: HotelGroupWhereUniqueInput
  }

  export type HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelHighlightCreateWithoutHotelCardInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelCardInputEnvelope
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
  }

  export type HotelCardToLabelCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput> | HotelCardToLabelCreateWithoutHotelCardInput[] | HotelCardToLabelUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutHotelCardInput | HotelCardToLabelCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToLabelCreateManyHotelCardInputEnvelope
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
  }

  export type HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput> | HotelCardToAccessibilityOptionCreateWithoutHotelCardInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyHotelCardInputEnvelope
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
  }

  export type HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelAmenityCreateWithoutHotelCardInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelCardInputEnvelope
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
  }

  export type HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput> | HotelParkingCreateWithoutHotelCardInput[] | HotelParkingUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelParkingCreateOrConnectWithoutHotelCardInput | HotelParkingCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
  }

  export type HotelImageUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput> | HotelImageCreateWithoutHotelCardInput[] | HotelImageUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelImageCreateOrConnectWithoutHotelCardInput | HotelImageCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
  }

  export type HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelAmenityCreateWithoutHotelCardInput[] | HotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardInput | HotelAmenityCreateOrConnectWithoutHotelCardInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelHighlightCreateWithoutHotelCardInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelCardInputEnvelope
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
  }

  export type HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput> | HotelCardToLabelCreateWithoutHotelCardInput[] | HotelCardToLabelUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutHotelCardInput | HotelCardToLabelCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToLabelCreateManyHotelCardInputEnvelope
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
  }

  export type HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput> | HotelCardToAccessibilityOptionCreateWithoutHotelCardInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyHotelCardInputEnvelope
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
  }

  export type HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelAmenityCreateWithoutHotelCardInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelCardInputEnvelope
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotelParkingUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput> | HotelParkingCreateWithoutHotelCardInput[] | HotelParkingUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelParkingCreateOrConnectWithoutHotelCardInput | HotelParkingCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelParkingUpsertWithWhereUniqueWithoutHotelCardInput | HotelParkingUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    disconnect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    delete?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    connect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    update?: HotelParkingUpdateWithWhereUniqueWithoutHotelCardInput | HotelParkingUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelParkingUpdateManyWithWhereWithoutHotelCardInput | HotelParkingUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelParkingScalarWhereInput | HotelParkingScalarWhereInput[]
  }

  export type HotelImageUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput> | HotelImageCreateWithoutHotelCardInput[] | HotelImageUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelImageCreateOrConnectWithoutHotelCardInput | HotelImageCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelImageUpsertWithWhereUniqueWithoutHotelCardInput | HotelImageUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    disconnect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    delete?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    connect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    update?: HotelImageUpdateWithWhereUniqueWithoutHotelCardInput | HotelImageUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelImageUpdateManyWithWhereWithoutHotelCardInput | HotelImageUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelImageScalarWhereInput | HotelImageScalarWhereInput[]
  }

  export type HotelAmenityUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelAmenityCreateWithoutHotelCardInput[] | HotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardInput | HotelAmenityCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput | HotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput | HotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutHotelCardInput | HotelAmenityUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type HotelDetailsUpdateOneWithoutHotelCardNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutHotelCardInput, HotelDetailsUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutHotelCardInput
    upsert?: HotelDetailsUpsertWithoutHotelCardInput
    disconnect?: HotelDetailsWhereInput | boolean
    delete?: HotelDetailsWhereInput | boolean
    connect?: HotelDetailsWhereUniqueInput
    update?: XOR<XOR<HotelDetailsUpdateToOneWithWhereWithoutHotelCardInput, HotelDetailsUpdateWithoutHotelCardInput>, HotelDetailsUncheckedUpdateWithoutHotelCardInput>
  }

  export type AccommodationTypeUpdateOneWithoutHotelCardNestedInput = {
    create?: XOR<AccommodationTypeCreateWithoutHotelCardInput, AccommodationTypeUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: AccommodationTypeCreateOrConnectWithoutHotelCardInput
    upsert?: AccommodationTypeUpsertWithoutHotelCardInput
    disconnect?: AccommodationTypeWhereInput | boolean
    delete?: AccommodationTypeWhereInput | boolean
    connect?: AccommodationTypeWhereUniqueInput
    update?: XOR<XOR<AccommodationTypeUpdateToOneWithWhereWithoutHotelCardInput, AccommodationTypeUpdateWithoutHotelCardInput>, AccommodationTypeUncheckedUpdateWithoutHotelCardInput>
  }

  export type DestinationUpdateOneWithoutHotelCardNestedInput = {
    create?: XOR<DestinationCreateWithoutHotelCardInput, DestinationUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutHotelCardInput
    upsert?: DestinationUpsertWithoutHotelCardInput
    disconnect?: DestinationWhereInput | boolean
    delete?: DestinationWhereInput | boolean
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutHotelCardInput, DestinationUpdateWithoutHotelCardInput>, DestinationUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelGroupUpdateOneWithoutHotelCardNestedInput = {
    create?: XOR<HotelGroupCreateWithoutHotelCardInput, HotelGroupUncheckedCreateWithoutHotelCardInput>
    connectOrCreate?: HotelGroupCreateOrConnectWithoutHotelCardInput
    upsert?: HotelGroupUpsertWithoutHotelCardInput
    disconnect?: HotelGroupWhereInput | boolean
    delete?: HotelGroupWhereInput | boolean
    connect?: HotelGroupWhereUniqueInput
    update?: XOR<XOR<HotelGroupUpdateToOneWithWhereWithoutHotelCardInput, HotelGroupUpdateWithoutHotelCardInput>, HotelGroupUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelHighlightCreateWithoutHotelCardInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelCardInputEnvelope
    set?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    disconnect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    delete?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    update?: HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelCardInput | HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
  }

  export type HotelCardToLabelUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput> | HotelCardToLabelCreateWithoutHotelCardInput[] | HotelCardToLabelUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutHotelCardInput | HotelCardToLabelCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToLabelUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToLabelUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToLabelCreateManyHotelCardInputEnvelope
    set?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    disconnect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    delete?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    update?: HotelCardToLabelUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToLabelUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToLabelUpdateManyWithWhereWithoutHotelCardInput | HotelCardToLabelUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
  }

  export type HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput> | HotelCardToAccessibilityOptionCreateWithoutHotelCardInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyHotelCardInputEnvelope
    set?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    disconnect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    delete?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    update?: HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutHotelCardInput | HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
  }

  export type HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelAmenityCreateWithoutHotelCardInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelCardInputEnvelope
    set?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    disconnect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    delete?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    update?: HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelCardInput | HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
  }

  export type HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput> | HotelParkingCreateWithoutHotelCardInput[] | HotelParkingUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelParkingCreateOrConnectWithoutHotelCardInput | HotelParkingCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelParkingUpsertWithWhereUniqueWithoutHotelCardInput | HotelParkingUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    disconnect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    delete?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    connect?: HotelParkingWhereUniqueInput | HotelParkingWhereUniqueInput[]
    update?: HotelParkingUpdateWithWhereUniqueWithoutHotelCardInput | HotelParkingUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelParkingUpdateManyWithWhereWithoutHotelCardInput | HotelParkingUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelParkingScalarWhereInput | HotelParkingScalarWhereInput[]
  }

  export type HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput> | HotelImageCreateWithoutHotelCardInput[] | HotelImageUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelImageCreateOrConnectWithoutHotelCardInput | HotelImageCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelImageUpsertWithWhereUniqueWithoutHotelCardInput | HotelImageUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    disconnect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    delete?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    connect?: HotelImageWhereUniqueInput | HotelImageWhereUniqueInput[]
    update?: HotelImageUpdateWithWhereUniqueWithoutHotelCardInput | HotelImageUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelImageUpdateManyWithWhereWithoutHotelCardInput | HotelImageUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelImageScalarWhereInput | HotelImageScalarWhereInput[]
  }

  export type HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelAmenityCreateWithoutHotelCardInput[] | HotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardInput | HotelAmenityCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput | HotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput[]
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput | HotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutHotelCardInput | HotelAmenityUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelHighlightCreateWithoutHotelCardInput[] | HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput | HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToHotelHighlightCreateManyHotelCardInputEnvelope
    set?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    disconnect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    delete?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    connect?: HotelCardToHotelHighlightWhereUniqueInput | HotelCardToHotelHighlightWhereUniqueInput[]
    update?: HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelCardInput | HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
  }

  export type HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput> | HotelCardToLabelCreateWithoutHotelCardInput[] | HotelCardToLabelUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToLabelCreateOrConnectWithoutHotelCardInput | HotelCardToLabelCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToLabelUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToLabelUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToLabelCreateManyHotelCardInputEnvelope
    set?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    disconnect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    delete?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    connect?: HotelCardToLabelWhereUniqueInput | HotelCardToLabelWhereUniqueInput[]
    update?: HotelCardToLabelUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToLabelUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToLabelUpdateManyWithWhereWithoutHotelCardInput | HotelCardToLabelUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput> | HotelCardToAccessibilityOptionCreateWithoutHotelCardInput[] | HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput | HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToAccessibilityOptionCreateManyHotelCardInputEnvelope
    set?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    disconnect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    delete?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    connect?: HotelCardToAccessibilityOptionWhereUniqueInput | HotelCardToAccessibilityOptionWhereUniqueInput[]
    update?: HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutHotelCardInput | HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
  }

  export type HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput = {
    create?: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput> | HotelCardToHotelAmenityCreateWithoutHotelCardInput[] | HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput[]
    connectOrCreate?: HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput | HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput[]
    upsert?: HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput[]
    createMany?: HotelCardToHotelAmenityCreateManyHotelCardInputEnvelope
    set?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    disconnect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    delete?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    connect?: HotelCardToHotelAmenityWhereUniqueInput | HotelCardToHotelAmenityWhereUniqueInput[]
    update?: HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput | HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput[]
    updateMany?: HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelCardInput | HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelCardInput[]
    deleteMany?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
  }

  export type AddressCreateNestedOneWithoutHotelDetailsInput = {
    create?: XOR<AddressCreateWithoutHotelDetailsInput, AddressUncheckedCreateWithoutHotelDetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutHotelDetailsInput
    connect?: AddressWhereUniqueInput
  }

  export type RoomAmenityCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput> | RoomAmenityCreateWithoutHotelDetailsInput[] | RoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsInput | RoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type LabelCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput> | LabelCreateWithoutHotelDetailsInput[] | LabelUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutHotelDetailsInput | LabelCreateOrConnectWithoutHotelDetailsInput[]
    createMany?: LabelCreateManyHotelDetailsInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type HotelCardCreateNestedManyWithoutDetailsInput = {
    create?: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput> | HotelCardCreateWithoutDetailsInput[] | HotelCardUncheckedCreateWithoutDetailsInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDetailsInput | HotelCardCreateOrConnectWithoutDetailsInput[]
    createMany?: HotelCardCreateManyDetailsInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput> | HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyHotelDetailsInputEnvelope
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
  }

  export type RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput> | RoomAmenityCreateWithoutHotelDetailsInput[] | RoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsInput | RoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type LabelUncheckedCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput> | LabelCreateWithoutHotelDetailsInput[] | LabelUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutHotelDetailsInput | LabelCreateOrConnectWithoutHotelDetailsInput[]
    createMany?: LabelCreateManyHotelDetailsInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type HotelCardUncheckedCreateNestedManyWithoutDetailsInput = {
    create?: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput> | HotelCardCreateWithoutDetailsInput[] | HotelCardUncheckedCreateWithoutDetailsInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDetailsInput | HotelCardCreateOrConnectWithoutDetailsInput[]
    createMany?: HotelCardCreateManyDetailsInputEnvelope
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
  }

  export type HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput> | HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyHotelDetailsInputEnvelope
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
  }

  export type AddressUpdateOneRequiredWithoutHotelDetailsNestedInput = {
    create?: XOR<AddressCreateWithoutHotelDetailsInput, AddressUncheckedCreateWithoutHotelDetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutHotelDetailsInput
    upsert?: AddressUpsertWithoutHotelDetailsInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutHotelDetailsInput, AddressUpdateWithoutHotelDetailsInput>, AddressUncheckedUpdateWithoutHotelDetailsInput>
  }

  export type RoomAmenityUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput> | RoomAmenityCreateWithoutHotelDetailsInput[] | RoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsInput | RoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput | RoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput | RoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput | RoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type LabelUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput> | LabelCreateWithoutHotelDetailsInput[] | LabelUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutHotelDetailsInput | LabelCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutHotelDetailsInput | LabelUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    createMany?: LabelCreateManyHotelDetailsInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutHotelDetailsInput | LabelUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutHotelDetailsInput | LabelUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type HotelCardUpdateManyWithoutDetailsNestedInput = {
    create?: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput> | HotelCardCreateWithoutDetailsInput[] | HotelCardUncheckedCreateWithoutDetailsInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDetailsInput | HotelCardCreateOrConnectWithoutDetailsInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutDetailsInput | HotelCardUpsertWithWhereUniqueWithoutDetailsInput[]
    createMany?: HotelCardCreateManyDetailsInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutDetailsInput | HotelCardUpdateWithWhereUniqueWithoutDetailsInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutDetailsInput | HotelCardUpdateManyWithWhereWithoutDetailsInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput> | HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyHotelDetailsInputEnvelope
    set?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    disconnect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    delete?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    update?: HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
  }

  export type RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput> | RoomAmenityCreateWithoutHotelDetailsInput[] | RoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsInput | RoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput | RoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput | RoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput | RoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput> | LabelCreateWithoutHotelDetailsInput[] | LabelUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutHotelDetailsInput | LabelCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutHotelDetailsInput | LabelUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    createMany?: LabelCreateManyHotelDetailsInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutHotelDetailsInput | LabelUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutHotelDetailsInput | LabelUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type HotelCardUncheckedUpdateManyWithoutDetailsNestedInput = {
    create?: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput> | HotelCardCreateWithoutDetailsInput[] | HotelCardUncheckedCreateWithoutDetailsInput[]
    connectOrCreate?: HotelCardCreateOrConnectWithoutDetailsInput | HotelCardCreateOrConnectWithoutDetailsInput[]
    upsert?: HotelCardUpsertWithWhereUniqueWithoutDetailsInput | HotelCardUpsertWithWhereUniqueWithoutDetailsInput[]
    createMany?: HotelCardCreateManyDetailsInputEnvelope
    set?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    disconnect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    delete?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    connect?: HotelCardWhereUniqueInput | HotelCardWhereUniqueInput[]
    update?: HotelCardUpdateWithWhereUniqueWithoutDetailsInput | HotelCardUpdateWithWhereUniqueWithoutDetailsInput[]
    updateMany?: HotelCardUpdateManyWithWhereWithoutDetailsInput | HotelCardUpdateManyWithWhereWithoutDetailsInput[]
    deleteMany?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput = {
    create?: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput> | HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput[] | HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput[]
    connectOrCreate?: HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput | HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput[]
    upsert?: HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput[]
    createMany?: HotelDetailsToRoomAmenityCreateManyHotelDetailsInputEnvelope
    set?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    disconnect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    delete?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    connect?: HotelDetailsToRoomAmenityWhereUniqueInput | HotelDetailsToRoomAmenityWhereUniqueInput[]
    update?: HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput[]
    updateMany?: HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput | HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput[]
    deleteMany?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
  }

  export type HotelCardCreateNestedOneWithoutHotelCardToHotelHighlightInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToHotelHighlightInput
    connect?: HotelCardWhereUniqueInput
  }

  export type HotelHighlightCreateNestedOneWithoutHotelCardToHotelHighlightInput = {
    create?: XOR<HotelHighlightCreateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    connectOrCreate?: HotelHighlightCreateOrConnectWithoutHotelCardToHotelHighlightInput
    connect?: HotelHighlightWhereUniqueInput
  }

  export type HotelCardUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToHotelHighlightInput
    upsert?: HotelCardUpsertWithoutHotelCardToHotelHighlightInput
    connect?: HotelCardWhereUniqueInput
    update?: XOR<XOR<HotelCardUpdateToOneWithWhereWithoutHotelCardToHotelHighlightInput, HotelCardUpdateWithoutHotelCardToHotelHighlightInput>, HotelCardUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelHighlightUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput = {
    create?: XOR<HotelHighlightCreateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    connectOrCreate?: HotelHighlightCreateOrConnectWithoutHotelCardToHotelHighlightInput
    upsert?: HotelHighlightUpsertWithoutHotelCardToHotelHighlightInput
    connect?: HotelHighlightWhereUniqueInput
    update?: XOR<XOR<HotelHighlightUpdateToOneWithWhereWithoutHotelCardToHotelHighlightInput, HotelHighlightUpdateWithoutHotelCardToHotelHighlightInput>, HotelHighlightUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelCardCreateNestedOneWithoutHotelCardToLabelInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToLabelInput, HotelCardUncheckedCreateWithoutHotelCardToLabelInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToLabelInput
    connect?: HotelCardWhereUniqueInput
  }

  export type LabelCreateNestedOneWithoutHotelCardToLabelInput = {
    create?: XOR<LabelCreateWithoutHotelCardToLabelInput, LabelUncheckedCreateWithoutHotelCardToLabelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutHotelCardToLabelInput
    connect?: LabelWhereUniqueInput
  }

  export type HotelCardUpdateOneRequiredWithoutHotelCardToLabelNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToLabelInput, HotelCardUncheckedCreateWithoutHotelCardToLabelInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToLabelInput
    upsert?: HotelCardUpsertWithoutHotelCardToLabelInput
    connect?: HotelCardWhereUniqueInput
    update?: XOR<XOR<HotelCardUpdateToOneWithWhereWithoutHotelCardToLabelInput, HotelCardUpdateWithoutHotelCardToLabelInput>, HotelCardUncheckedUpdateWithoutHotelCardToLabelInput>
  }

  export type LabelUpdateOneRequiredWithoutHotelCardToLabelNestedInput = {
    create?: XOR<LabelCreateWithoutHotelCardToLabelInput, LabelUncheckedCreateWithoutHotelCardToLabelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutHotelCardToLabelInput
    upsert?: LabelUpsertWithoutHotelCardToLabelInput
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutHotelCardToLabelInput, LabelUpdateWithoutHotelCardToLabelInput>, LabelUncheckedUpdateWithoutHotelCardToLabelInput>
  }

  export type HotelCardCreateNestedOneWithoutHotelCardToAccessibilityOptionInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToAccessibilityOptionInput
    connect?: HotelCardWhereUniqueInput
  }

  export type AccessibilityOptionCreateNestedOneWithoutHotelCardToAccessibilityOptionInput = {
    create?: XOR<AccessibilityOptionCreateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    connectOrCreate?: AccessibilityOptionCreateOrConnectWithoutHotelCardToAccessibilityOptionInput
    connect?: AccessibilityOptionWhereUniqueInput
  }

  export type HotelCardUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToAccessibilityOptionInput
    upsert?: HotelCardUpsertWithoutHotelCardToAccessibilityOptionInput
    connect?: HotelCardWhereUniqueInput
    update?: XOR<XOR<HotelCardUpdateToOneWithWhereWithoutHotelCardToAccessibilityOptionInput, HotelCardUpdateWithoutHotelCardToAccessibilityOptionInput>, HotelCardUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type AccessibilityOptionUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput = {
    create?: XOR<AccessibilityOptionCreateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    connectOrCreate?: AccessibilityOptionCreateOrConnectWithoutHotelCardToAccessibilityOptionInput
    upsert?: AccessibilityOptionUpsertWithoutHotelCardToAccessibilityOptionInput
    connect?: AccessibilityOptionWhereUniqueInput
    update?: XOR<XOR<AccessibilityOptionUpdateToOneWithWhereWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUpdateWithoutHotelCardToAccessibilityOptionInput>, AccessibilityOptionUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type HotelCardCreateNestedOneWithoutHotelCardToHotelAmenityInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToHotelAmenityInput
    connect?: HotelCardWhereUniqueInput
  }

  export type HotelAmenityCreateNestedOneWithoutHotelCardToHotelAmenityInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardToHotelAmenityInput
    connect?: HotelAmenityWhereUniqueInput
  }

  export type HotelCardUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput = {
    create?: XOR<HotelCardCreateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    connectOrCreate?: HotelCardCreateOrConnectWithoutHotelCardToHotelAmenityInput
    upsert?: HotelCardUpsertWithoutHotelCardToHotelAmenityInput
    connect?: HotelCardWhereUniqueInput
    update?: XOR<XOR<HotelCardUpdateToOneWithWhereWithoutHotelCardToHotelAmenityInput, HotelCardUpdateWithoutHotelCardToHotelAmenityInput>, HotelCardUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelAmenityUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelCardToHotelAmenityInput
    upsert?: HotelAmenityUpsertWithoutHotelCardToHotelAmenityInput
    connect?: HotelAmenityWhereUniqueInput
    update?: XOR<XOR<HotelAmenityUpdateToOneWithWhereWithoutHotelCardToHotelAmenityInput, HotelAmenityUpdateWithoutHotelCardToHotelAmenityInput>, HotelAmenityUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelDetailsCreateNestedOneWithoutHotelDetailsToRoomAmenityInput = {
    create?: XOR<HotelDetailsCreateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutHotelDetailsToRoomAmenityInput
    connect?: HotelDetailsWhereUniqueInput
  }

  export type RoomAmenityCreateNestedOneWithoutHotelDetailsToRoomAmenityInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsToRoomAmenityInput
    connect?: RoomAmenityWhereUniqueInput
  }

  export type HotelDetailsUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput = {
    create?: XOR<HotelDetailsCreateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    connectOrCreate?: HotelDetailsCreateOrConnectWithoutHotelDetailsToRoomAmenityInput
    upsert?: HotelDetailsUpsertWithoutHotelDetailsToRoomAmenityInput
    connect?: HotelDetailsWhereUniqueInput
    update?: XOR<XOR<HotelDetailsUpdateToOneWithWhereWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUpdateWithoutHotelDetailsToRoomAmenityInput>, HotelDetailsUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type RoomAmenityUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutHotelDetailsToRoomAmenityInput
    upsert?: RoomAmenityUpsertWithoutHotelDetailsToRoomAmenityInput
    connect?: RoomAmenityWhereUniqueInput
    update?: XOR<XOR<RoomAmenityUpdateToOneWithWhereWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUpdateWithoutHotelDetailsToRoomAmenityInput>, RoomAmenityUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type DestinationCreateNestedOneWithoutDestinationToCityInput = {
    create?: XOR<DestinationCreateWithoutDestinationToCityInput, DestinationUncheckedCreateWithoutDestinationToCityInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutDestinationToCityInput
    connect?: DestinationWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutDestinationToCityInput = {
    create?: XOR<CityCreateWithoutDestinationToCityInput, CityUncheckedCreateWithoutDestinationToCityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDestinationToCityInput
    connect?: CityWhereUniqueInput
  }

  export type DestinationUpdateOneRequiredWithoutDestinationToCityNestedInput = {
    create?: XOR<DestinationCreateWithoutDestinationToCityInput, DestinationUncheckedCreateWithoutDestinationToCityInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutDestinationToCityInput
    upsert?: DestinationUpsertWithoutDestinationToCityInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutDestinationToCityInput, DestinationUpdateWithoutDestinationToCityInput>, DestinationUncheckedUpdateWithoutDestinationToCityInput>
  }

  export type CityUpdateOneRequiredWithoutDestinationToCityNestedInput = {
    create?: XOR<CityCreateWithoutDestinationToCityInput, CityUncheckedCreateWithoutDestinationToCityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDestinationToCityInput
    upsert?: CityUpsertWithoutDestinationToCityInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDestinationToCityInput, CityUpdateWithoutDestinationToCityInput>, CityUncheckedUpdateWithoutDestinationToCityInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    neighborhood?: NeighborhoodCreateNestedOneWithoutAddressesInput
    hotelDetails?: HotelDetailsCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    streetNumber?: StringNullableFilter<"Address"> | string | null
    streetName?: StringFilter<"Address"> | string
    addressLine2?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    cityId?: StringFilter<"Address"> | string
    neighborhoodId?: StringNullableFilter<"Address"> | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    Address?: AddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Address?: AddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Address?: AddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Address?: AddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    Address?: AddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Address?: AddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Address?: AddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Address?: AddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CityCreateWithoutCountryInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    order?: IntNullableFilter<"City"> | number | null
    countryId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
  }

  export type CountryCreateWithoutCitiesInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    language?: string | null
    currency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    language?: string | null
    currency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type NeighborhoodCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutNeighborhoodInput
  }

  export type NeighborhoodUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutNeighborhoodInput
  }

  export type NeighborhoodCreateOrConnectWithoutCityInput = {
    where: NeighborhoodWhereUniqueInput
    create: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput>
  }

  export type NeighborhoodCreateManyCityInputEnvelope = {
    data: NeighborhoodCreateManyCityInput | NeighborhoodCreateManyCityInput[]
  }

  export type LandmarkCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandmarkUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandmarkCreateOrConnectWithoutCityInput = {
    where: LandmarkWhereUniqueInput
    create: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput>
  }

  export type LandmarkCreateManyCityInputEnvelope = {
    data: LandmarkCreateManyCityInput | LandmarkCreateManyCityInput[]
  }

  export type AddressCreateWithoutCityInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhood?: NeighborhoodCreateNestedOneWithoutAddressesInput
    hotelDetails?: HotelDetailsCreateNestedManyWithoutAddressInput
    user?: UserCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCityInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutAddressInput
    user?: UserUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressCreateManyCityInputEnvelope = {
    data: AddressCreateManyCityInput | AddressCreateManyCityInput[]
  }

  export type DestinationCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutDestinationInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDestinationInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutCityInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput>
  }

  export type DestinationToCityCreateWithoutCityInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutDestinationToCityInput
  }

  export type DestinationToCityUncheckedCreateWithoutCityInput = {
    destinationId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationToCityCreateOrConnectWithoutCityInput = {
    where: DestinationToCityWhereUniqueInput
    create: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput>
  }

  export type DestinationToCityCreateManyCityInputEnvelope = {
    data: DestinationToCityCreateManyCityInput | DestinationToCityCreateManyCityInput[]
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeighborhoodUpsertWithWhereUniqueWithoutCityInput = {
    where: NeighborhoodWhereUniqueInput
    update: XOR<NeighborhoodUpdateWithoutCityInput, NeighborhoodUncheckedUpdateWithoutCityInput>
    create: XOR<NeighborhoodCreateWithoutCityInput, NeighborhoodUncheckedCreateWithoutCityInput>
  }

  export type NeighborhoodUpdateWithWhereUniqueWithoutCityInput = {
    where: NeighborhoodWhereUniqueInput
    data: XOR<NeighborhoodUpdateWithoutCityInput, NeighborhoodUncheckedUpdateWithoutCityInput>
  }

  export type NeighborhoodUpdateManyWithWhereWithoutCityInput = {
    where: NeighborhoodScalarWhereInput
    data: XOR<NeighborhoodUpdateManyMutationInput, NeighborhoodUncheckedUpdateManyWithoutCityInput>
  }

  export type NeighborhoodScalarWhereInput = {
    AND?: NeighborhoodScalarWhereInput | NeighborhoodScalarWhereInput[]
    OR?: NeighborhoodScalarWhereInput[]
    NOT?: NeighborhoodScalarWhereInput | NeighborhoodScalarWhereInput[]
    id?: StringFilter<"Neighborhood"> | string
    name?: StringFilter<"Neighborhood"> | string
    order?: IntNullableFilter<"Neighborhood"> | number | null
    cityId?: StringFilter<"Neighborhood"> | string
    createdAt?: DateTimeFilter<"Neighborhood"> | Date | string
    updatedAt?: DateTimeFilter<"Neighborhood"> | Date | string
  }

  export type LandmarkUpsertWithWhereUniqueWithoutCityInput = {
    where: LandmarkWhereUniqueInput
    update: XOR<LandmarkUpdateWithoutCityInput, LandmarkUncheckedUpdateWithoutCityInput>
    create: XOR<LandmarkCreateWithoutCityInput, LandmarkUncheckedCreateWithoutCityInput>
  }

  export type LandmarkUpdateWithWhereUniqueWithoutCityInput = {
    where: LandmarkWhereUniqueInput
    data: XOR<LandmarkUpdateWithoutCityInput, LandmarkUncheckedUpdateWithoutCityInput>
  }

  export type LandmarkUpdateManyWithWhereWithoutCityInput = {
    where: LandmarkScalarWhereInput
    data: XOR<LandmarkUpdateManyMutationInput, LandmarkUncheckedUpdateManyWithoutCityInput>
  }

  export type LandmarkScalarWhereInput = {
    AND?: LandmarkScalarWhereInput | LandmarkScalarWhereInput[]
    OR?: LandmarkScalarWhereInput[]
    NOT?: LandmarkScalarWhereInput | LandmarkScalarWhereInput[]
    id?: StringFilter<"Landmark"> | string
    name?: StringFilter<"Landmark"> | string
    order?: IntNullableFilter<"Landmark"> | number | null
    description?: StringNullableFilter<"Landmark"> | string | null
    type?: StringFilter<"Landmark"> | string
    cityId?: StringFilter<"Landmark"> | string
    latitude?: FloatNullableFilter<"Landmark"> | number | null
    longitude?: FloatNullableFilter<"Landmark"> | number | null
    createdAt?: DateTimeFilter<"Landmark"> | Date | string
    updatedAt?: DateTimeFilter<"Landmark"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
  }

  export type AddressUpdateManyWithWhereWithoutCityInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCityInput>
  }

  export type DestinationUpsertWithWhereUniqueWithoutCityInput = {
    where: DestinationWhereUniqueInput
    update: XOR<DestinationUpdateWithoutCityInput, DestinationUncheckedUpdateWithoutCityInput>
    create: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput>
  }

  export type DestinationUpdateWithWhereUniqueWithoutCityInput = {
    where: DestinationWhereUniqueInput
    data: XOR<DestinationUpdateWithoutCityInput, DestinationUncheckedUpdateWithoutCityInput>
  }

  export type DestinationUpdateManyWithWhereWithoutCityInput = {
    where: DestinationScalarWhereInput
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyWithoutCityInput>
  }

  export type DestinationScalarWhereInput = {
    AND?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
    OR?: DestinationScalarWhereInput[]
    NOT?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    order?: IntNullableFilter<"Destination"> | number | null
    description?: StringNullableFilter<"Destination"> | string | null
    type?: StringFilter<"Destination"> | string
    popularityScore?: IntFilter<"Destination"> | number
    cityId?: StringFilter<"Destination"> | string
    latitude?: FloatNullableFilter<"Destination"> | number | null
    longitude?: FloatNullableFilter<"Destination"> | number | null
    radius?: FloatNullableFilter<"Destination"> | number | null
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
  }

  export type DestinationToCityUpsertWithWhereUniqueWithoutCityInput = {
    where: DestinationToCityWhereUniqueInput
    update: XOR<DestinationToCityUpdateWithoutCityInput, DestinationToCityUncheckedUpdateWithoutCityInput>
    create: XOR<DestinationToCityCreateWithoutCityInput, DestinationToCityUncheckedCreateWithoutCityInput>
  }

  export type DestinationToCityUpdateWithWhereUniqueWithoutCityInput = {
    where: DestinationToCityWhereUniqueInput
    data: XOR<DestinationToCityUpdateWithoutCityInput, DestinationToCityUncheckedUpdateWithoutCityInput>
  }

  export type DestinationToCityUpdateManyWithWhereWithoutCityInput = {
    where: DestinationToCityScalarWhereInput
    data: XOR<DestinationToCityUpdateManyMutationInput, DestinationToCityUncheckedUpdateManyWithoutCityInput>
  }

  export type DestinationToCityScalarWhereInput = {
    AND?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
    OR?: DestinationToCityScalarWhereInput[]
    NOT?: DestinationToCityScalarWhereInput | DestinationToCityScalarWhereInput[]
    destinationId?: StringFilter<"DestinationToCity"> | string
    cityId?: StringFilter<"DestinationToCity"> | string
    order?: IntNullableFilter<"DestinationToCity"> | number | null
    createdAt?: DateTimeFilter<"DestinationToCity"> | Date | string
    updatedAt?: DateTimeFilter<"DestinationToCity"> | Date | string
  }

  export type CityCreateWithoutNeighborhoodsInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutNeighborhoodsInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutNeighborhoodsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutNeighborhoodsInput, CityUncheckedCreateWithoutNeighborhoodsInput>
  }

  export type AddressCreateWithoutNeighborhoodInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    hotelDetails?: HotelDetailsCreateNestedManyWithoutAddressInput
    user?: UserCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutNeighborhoodInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutAddressInput
    user?: UserUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutNeighborhoodInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput>
  }

  export type AddressCreateManyNeighborhoodInputEnvelope = {
    data: AddressCreateManyNeighborhoodInput | AddressCreateManyNeighborhoodInput[]
  }

  export type CityUpsertWithoutNeighborhoodsInput = {
    update: XOR<CityUpdateWithoutNeighborhoodsInput, CityUncheckedUpdateWithoutNeighborhoodsInput>
    create: XOR<CityCreateWithoutNeighborhoodsInput, CityUncheckedCreateWithoutNeighborhoodsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutNeighborhoodsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutNeighborhoodsInput, CityUncheckedUpdateWithoutNeighborhoodsInput>
  }

  export type CityUpdateWithoutNeighborhoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutNeighborhoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type AddressUpsertWithWhereUniqueWithoutNeighborhoodInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutNeighborhoodInput, AddressUncheckedUpdateWithoutNeighborhoodInput>
    create: XOR<AddressCreateWithoutNeighborhoodInput, AddressUncheckedCreateWithoutNeighborhoodInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutNeighborhoodInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutNeighborhoodInput, AddressUncheckedUpdateWithoutNeighborhoodInput>
  }

  export type AddressUpdateManyWithWhereWithoutNeighborhoodInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutNeighborhoodInput>
  }

  export type CityCreateWithoutLandmarksInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutLandmarksInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutLandmarksInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutLandmarksInput, CityUncheckedCreateWithoutLandmarksInput>
  }

  export type CityUpsertWithoutLandmarksInput = {
    update: XOR<CityUpdateWithoutLandmarksInput, CityUncheckedUpdateWithoutLandmarksInput>
    create: XOR<CityCreateWithoutLandmarksInput, CityUncheckedCreateWithoutLandmarksInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutLandmarksInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutLandmarksInput, CityUncheckedUpdateWithoutLandmarksInput>
  }

  export type CityUpdateWithoutLandmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutLandmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type HotelCardCreateWithoutAccommodationTypeInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutAccommodationTypeInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutAccommodationTypeInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput>
  }

  export type HotelCardCreateManyAccommodationTypeInputEnvelope = {
    data: HotelCardCreateManyAccommodationTypeInput | HotelCardCreateManyAccommodationTypeInput[]
  }

  export type HotelCardUpsertWithWhereUniqueWithoutAccommodationTypeInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutAccommodationTypeInput, HotelCardUncheckedUpdateWithoutAccommodationTypeInput>
    create: XOR<HotelCardCreateWithoutAccommodationTypeInput, HotelCardUncheckedCreateWithoutAccommodationTypeInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutAccommodationTypeInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutAccommodationTypeInput, HotelCardUncheckedUpdateWithoutAccommodationTypeInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutAccommodationTypeInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutAccommodationTypeInput>
  }

  export type HotelCardScalarWhereInput = {
    AND?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
    OR?: HotelCardScalarWhereInput[]
    NOT?: HotelCardScalarWhereInput | HotelCardScalarWhereInput[]
    id?: StringFilter<"HotelCard"> | string
    name?: StringFilter<"HotelCard"> | string
    idCity?: StringFilter<"HotelCard"> | string
    order?: IntFilter<"HotelCard"> | number
    shortDescription?: StringNullableFilter<"HotelCard"> | string | null
    starRating?: IntFilter<"HotelCard"> | number
    overallRating?: FloatNullableFilter<"HotelCard"> | number | null
    ratingAdjective?: StringNullableFilter<"HotelCard"> | string | null
    reviewCount?: IntFilter<"HotelCard"> | number
    basePricePerNight?: FloatFilter<"HotelCard"> | number
    regularPrice?: FloatNullableFilter<"HotelCard"> | number | null
    currency?: StringFilter<"HotelCard"> | string
    isPartner?: BoolFilter<"HotelCard"> | boolean
    promoMessage?: StringNullableFilter<"HotelCard"> | string | null
    imageMessage?: StringNullableFilter<"HotelCard"> | string | null
    cancellationPolicy?: StringNullableFilter<"HotelCard"> | string | null
    accommodationTypeId?: StringNullableFilter<"HotelCard"> | string | null
    destinationId?: StringNullableFilter<"HotelCard"> | string | null
    hotelGroupId?: StringNullableFilter<"HotelCard"> | string | null
    latitude?: FloatNullableFilter<"HotelCard"> | number | null
    longitude?: FloatNullableFilter<"HotelCard"> | number | null
    detailsId?: StringNullableFilter<"HotelCard"> | string | null
  }

  export type HotelCardCreateWithoutDestinationInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutDestinationInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutDestinationInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput>
  }

  export type HotelCardCreateManyDestinationInputEnvelope = {
    data: HotelCardCreateManyDestinationInput | HotelCardCreateManyDestinationInput[]
  }

  export type CityCreateWithoutDestinationsInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDestinationsInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDestinationsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
  }

  export type DestinationToCityCreateWithoutDestinationInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutDestinationToCityInput
  }

  export type DestinationToCityUncheckedCreateWithoutDestinationInput = {
    cityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationToCityCreateOrConnectWithoutDestinationInput = {
    where: DestinationToCityWhereUniqueInput
    create: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput>
  }

  export type DestinationToCityCreateManyDestinationInputEnvelope = {
    data: DestinationToCityCreateManyDestinationInput | DestinationToCityCreateManyDestinationInput[]
  }

  export type HotelCardUpsertWithWhereUniqueWithoutDestinationInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutDestinationInput, HotelCardUncheckedUpdateWithoutDestinationInput>
    create: XOR<HotelCardCreateWithoutDestinationInput, HotelCardUncheckedCreateWithoutDestinationInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutDestinationInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutDestinationInput, HotelCardUncheckedUpdateWithoutDestinationInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutDestinationInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutDestinationInput>
  }

  export type CityUpsertWithWhereUniqueWithoutDestinationsInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutDestinationsInput, CityUncheckedUpdateWithoutDestinationsInput>
    create: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
  }

  export type CityUpdateWithWhereUniqueWithoutDestinationsInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutDestinationsInput, CityUncheckedUpdateWithoutDestinationsInput>
  }

  export type CityUpdateManyWithWhereWithoutDestinationsInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutDestinationsInput>
  }

  export type DestinationToCityUpsertWithWhereUniqueWithoutDestinationInput = {
    where: DestinationToCityWhereUniqueInput
    update: XOR<DestinationToCityUpdateWithoutDestinationInput, DestinationToCityUncheckedUpdateWithoutDestinationInput>
    create: XOR<DestinationToCityCreateWithoutDestinationInput, DestinationToCityUncheckedCreateWithoutDestinationInput>
  }

  export type DestinationToCityUpdateWithWhereUniqueWithoutDestinationInput = {
    where: DestinationToCityWhereUniqueInput
    data: XOR<DestinationToCityUpdateWithoutDestinationInput, DestinationToCityUncheckedUpdateWithoutDestinationInput>
  }

  export type DestinationToCityUpdateManyWithWhereWithoutDestinationInput = {
    where: DestinationToCityScalarWhereInput
    data: XOR<DestinationToCityUpdateManyMutationInput, DestinationToCityUncheckedUpdateManyWithoutDestinationInput>
  }

  export type HotelDetailsCreateWithoutLabelInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutHotelDetailsInput
    RoomAmenity?: RoomAmenityCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUncheckedCreateWithoutLabelInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsCreateOrConnectWithoutLabelInput = {
    where: HotelDetailsWhereUniqueInput
    create: XOR<HotelDetailsCreateWithoutLabelInput, HotelDetailsUncheckedCreateWithoutLabelInput>
  }

  export type HotelCardToLabelCreateWithoutLabelInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToLabelInput
  }

  export type HotelCardToLabelUncheckedCreateWithoutLabelInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelCreateOrConnectWithoutLabelInput = {
    where: HotelCardToLabelWhereUniqueInput
    create: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput>
  }

  export type HotelCardToLabelCreateManyLabelInputEnvelope = {
    data: HotelCardToLabelCreateManyLabelInput | HotelCardToLabelCreateManyLabelInput[]
  }

  export type HotelDetailsUpsertWithoutLabelInput = {
    update: XOR<HotelDetailsUpdateWithoutLabelInput, HotelDetailsUncheckedUpdateWithoutLabelInput>
    create: XOR<HotelDetailsCreateWithoutLabelInput, HotelDetailsUncheckedCreateWithoutLabelInput>
    where?: HotelDetailsWhereInput
  }

  export type HotelDetailsUpdateToOneWithWhereWithoutLabelInput = {
    where?: HotelDetailsWhereInput
    data: XOR<HotelDetailsUpdateWithoutLabelInput, HotelDetailsUncheckedUpdateWithoutLabelInput>
  }

  export type HotelDetailsUpdateWithoutLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutHotelDetailsNestedInput
    RoomAmenity?: RoomAmenityUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateWithoutLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelCardToLabelUpsertWithWhereUniqueWithoutLabelInput = {
    where: HotelCardToLabelWhereUniqueInput
    update: XOR<HotelCardToLabelUpdateWithoutLabelInput, HotelCardToLabelUncheckedUpdateWithoutLabelInput>
    create: XOR<HotelCardToLabelCreateWithoutLabelInput, HotelCardToLabelUncheckedCreateWithoutLabelInput>
  }

  export type HotelCardToLabelUpdateWithWhereUniqueWithoutLabelInput = {
    where: HotelCardToLabelWhereUniqueInput
    data: XOR<HotelCardToLabelUpdateWithoutLabelInput, HotelCardToLabelUncheckedUpdateWithoutLabelInput>
  }

  export type HotelCardToLabelUpdateManyWithWhereWithoutLabelInput = {
    where: HotelCardToLabelScalarWhereInput
    data: XOR<HotelCardToLabelUpdateManyMutationInput, HotelCardToLabelUncheckedUpdateManyWithoutLabelInput>
  }

  export type HotelCardToLabelScalarWhereInput = {
    AND?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
    OR?: HotelCardToLabelScalarWhereInput[]
    NOT?: HotelCardToLabelScalarWhereInput | HotelCardToLabelScalarWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToLabel"> | string
    labelId?: StringFilter<"HotelCardToLabel"> | string
    order?: IntNullableFilter<"HotelCardToLabel"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToLabel"> | Date | string
  }

  export type HotelCardCreateWithoutHotelGroupInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelGroupInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelGroupInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput>
  }

  export type HotelCardCreateManyHotelGroupInputEnvelope = {
    data: HotelCardCreateManyHotelGroupInput | HotelCardCreateManyHotelGroupInput[]
  }

  export type HotelCardUpsertWithWhereUniqueWithoutHotelGroupInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutHotelGroupInput, HotelCardUncheckedUpdateWithoutHotelGroupInput>
    create: XOR<HotelCardCreateWithoutHotelGroupInput, HotelCardUncheckedCreateWithoutHotelGroupInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutHotelGroupInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutHotelGroupInput, HotelCardUncheckedUpdateWithoutHotelGroupInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutHotelGroupInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutHotelGroupInput>
  }

  export type HotelCardToHotelHighlightCreateWithoutHotelHighlightInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToHotelHighlightInput
  }

  export type HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelHighlightCreateOrConnectWithoutHotelHighlightInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    create: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput>
  }

  export type HotelCardToHotelHighlightCreateManyHotelHighlightInputEnvelope = {
    data: HotelCardToHotelHighlightCreateManyHotelHighlightInput | HotelCardToHotelHighlightCreateManyHotelHighlightInput[]
  }

  export type HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelHighlightInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    update: XOR<HotelCardToHotelHighlightUpdateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedUpdateWithoutHotelHighlightInput>
    create: XOR<HotelCardToHotelHighlightCreateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelHighlightInput>
  }

  export type HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelHighlightInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    data: XOR<HotelCardToHotelHighlightUpdateWithoutHotelHighlightInput, HotelCardToHotelHighlightUncheckedUpdateWithoutHotelHighlightInput>
  }

  export type HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelHighlightInput = {
    where: HotelCardToHotelHighlightScalarWhereInput
    data: XOR<HotelCardToHotelHighlightUpdateManyMutationInput, HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelHighlightInput>
  }

  export type HotelCardToHotelHighlightScalarWhereInput = {
    AND?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
    OR?: HotelCardToHotelHighlightScalarWhereInput[]
    NOT?: HotelCardToHotelHighlightScalarWhereInput | HotelCardToHotelHighlightScalarWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelHighlight"> | string
    hotelHighlightId?: StringFilter<"HotelCardToHotelHighlight"> | string
    order?: IntNullableFilter<"HotelCardToHotelHighlight"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelHighlight"> | Date | string
  }

  export type HotelCardCreateWithoutHotelAmenityInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelAmenityInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelAmenityInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityCreateWithoutHotelAmenityInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToHotelAmenityInput
  }

  export type HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelAmenityCreateOrConnectWithoutHotelAmenityInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    create: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityCreateManyHotelAmenityInputEnvelope = {
    data: HotelCardToHotelAmenityCreateManyHotelAmenityInput | HotelCardToHotelAmenityCreateManyHotelAmenityInput[]
  }

  export type HotelCardUpsertWithWhereUniqueWithoutHotelAmenityInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutHotelAmenityInput, HotelCardUncheckedUpdateWithoutHotelAmenityInput>
    create: XOR<HotelCardCreateWithoutHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelAmenityInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutHotelAmenityInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutHotelAmenityInput, HotelCardUncheckedUpdateWithoutHotelAmenityInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutHotelAmenityInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelAmenityInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    update: XOR<HotelCardToHotelAmenityUpdateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedUpdateWithoutHotelAmenityInput>
    create: XOR<HotelCardToHotelAmenityCreateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelAmenityInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    data: XOR<HotelCardToHotelAmenityUpdateWithoutHotelAmenityInput, HotelCardToHotelAmenityUncheckedUpdateWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelAmenityInput = {
    where: HotelCardToHotelAmenityScalarWhereInput
    data: XOR<HotelCardToHotelAmenityUpdateManyMutationInput, HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelAmenityInput>
  }

  export type HotelCardToHotelAmenityScalarWhereInput = {
    AND?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
    OR?: HotelCardToHotelAmenityScalarWhereInput[]
    NOT?: HotelCardToHotelAmenityScalarWhereInput | HotelCardToHotelAmenityScalarWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToHotelAmenity"> | string
    hotelAmenityId?: StringFilter<"HotelCardToHotelAmenity"> | string
    order?: IntNullableFilter<"HotelCardToHotelAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToHotelAmenity"> | Date | string
  }

  export type HotelDetailsCreateWithoutRoomAmenityInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutHotelDetailsInput
    Label?: LabelCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUncheckedCreateWithoutRoomAmenityInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Label?: LabelUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsCreateOrConnectWithoutRoomAmenityInput = {
    where: HotelDetailsWhereUniqueInput
    create: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput>
  }

  export type HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetails: HotelDetailsCreateNestedOneWithoutHotelDetailsToRoomAmenityInput
  }

  export type HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput = {
    hotelDetailsId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsToRoomAmenityCreateOrConnectWithoutRoomAmenityInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    create: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput>
  }

  export type HotelDetailsToRoomAmenityCreateManyRoomAmenityInputEnvelope = {
    data: HotelDetailsToRoomAmenityCreateManyRoomAmenityInput | HotelDetailsToRoomAmenityCreateManyRoomAmenityInput[]
  }

  export type HotelDetailsUpsertWithWhereUniqueWithoutRoomAmenityInput = {
    where: HotelDetailsWhereUniqueInput
    update: XOR<HotelDetailsUpdateWithoutRoomAmenityInput, HotelDetailsUncheckedUpdateWithoutRoomAmenityInput>
    create: XOR<HotelDetailsCreateWithoutRoomAmenityInput, HotelDetailsUncheckedCreateWithoutRoomAmenityInput>
  }

  export type HotelDetailsUpdateWithWhereUniqueWithoutRoomAmenityInput = {
    where: HotelDetailsWhereUniqueInput
    data: XOR<HotelDetailsUpdateWithoutRoomAmenityInput, HotelDetailsUncheckedUpdateWithoutRoomAmenityInput>
  }

  export type HotelDetailsUpdateManyWithWhereWithoutRoomAmenityInput = {
    where: HotelDetailsScalarWhereInput
    data: XOR<HotelDetailsUpdateManyMutationInput, HotelDetailsUncheckedUpdateManyWithoutRoomAmenityInput>
  }

  export type HotelDetailsScalarWhereInput = {
    AND?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
    OR?: HotelDetailsScalarWhereInput[]
    NOT?: HotelDetailsScalarWhereInput | HotelDetailsScalarWhereInput[]
    id?: StringFilter<"HotelDetails"> | string
    idHotelCard?: StringFilter<"HotelDetails"> | string
    description?: StringNullableFilter<"HotelDetails"> | string | null
    addressId?: StringFilter<"HotelDetails"> | string
    order?: IntNullableFilter<"HotelDetails"> | number | null
    createdAt?: DateTimeFilter<"HotelDetails"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetails"> | Date | string
  }

  export type HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutRoomAmenityInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    update: XOR<HotelDetailsToRoomAmenityUpdateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedUpdateWithoutRoomAmenityInput>
    create: XOR<HotelDetailsToRoomAmenityCreateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutRoomAmenityInput>
  }

  export type HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutRoomAmenityInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    data: XOR<HotelDetailsToRoomAmenityUpdateWithoutRoomAmenityInput, HotelDetailsToRoomAmenityUncheckedUpdateWithoutRoomAmenityInput>
  }

  export type HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutRoomAmenityInput = {
    where: HotelDetailsToRoomAmenityScalarWhereInput
    data: XOR<HotelDetailsToRoomAmenityUpdateManyMutationInput, HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutRoomAmenityInput>
  }

  export type HotelDetailsToRoomAmenityScalarWhereInput = {
    AND?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
    OR?: HotelDetailsToRoomAmenityScalarWhereInput[]
    NOT?: HotelDetailsToRoomAmenityScalarWhereInput | HotelDetailsToRoomAmenityScalarWhereInput[]
    hotelDetailsId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    roomAmenityId?: StringFilter<"HotelDetailsToRoomAmenity"> | string
    order?: IntNullableFilter<"HotelDetailsToRoomAmenity"> | number | null
    createdAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelDetailsToRoomAmenity"> | Date | string
  }

  export type HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelCard: HotelCardCreateNestedOneWithoutHotelCardToAccessibilityOptionInput
  }

  export type HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionCreateOrConnectWithoutAccessibilityOptionInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    create: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput>
  }

  export type HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInputEnvelope = {
    data: HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInput | HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInput[]
  }

  export type HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutAccessibilityOptionInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    update: XOR<HotelCardToAccessibilityOptionUpdateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedUpdateWithoutAccessibilityOptionInput>
    create: XOR<HotelCardToAccessibilityOptionCreateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutAccessibilityOptionInput>
  }

  export type HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutAccessibilityOptionInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    data: XOR<HotelCardToAccessibilityOptionUpdateWithoutAccessibilityOptionInput, HotelCardToAccessibilityOptionUncheckedUpdateWithoutAccessibilityOptionInput>
  }

  export type HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutAccessibilityOptionInput = {
    where: HotelCardToAccessibilityOptionScalarWhereInput
    data: XOR<HotelCardToAccessibilityOptionUpdateManyMutationInput, HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutAccessibilityOptionInput>
  }

  export type HotelCardToAccessibilityOptionScalarWhereInput = {
    AND?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
    OR?: HotelCardToAccessibilityOptionScalarWhereInput[]
    NOT?: HotelCardToAccessibilityOptionScalarWhereInput | HotelCardToAccessibilityOptionScalarWhereInput[]
    hotelCardId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    accessibilityOptionId?: StringFilter<"HotelCardToAccessibilityOption"> | string
    order?: IntNullableFilter<"HotelCardToAccessibilityOption"> | number | null
    createdAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
    updatedAt?: DateTimeFilter<"HotelCardToAccessibilityOption"> | Date | string
  }

  export type HotelCardCreateWithoutParkingInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutParkingInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutParkingInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput>
  }

  export type HotelCardUpsertWithWhereUniqueWithoutParkingInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutParkingInput, HotelCardUncheckedUpdateWithoutParkingInput>
    create: XOR<HotelCardCreateWithoutParkingInput, HotelCardUncheckedCreateWithoutParkingInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutParkingInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutParkingInput, HotelCardUncheckedUpdateWithoutParkingInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutParkingInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutParkingInput>
  }

  export type CityCreateWithoutAddressesInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAddressesInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAddressesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type NeighborhoodCreateWithoutAddressesInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutNeighborhoodsInput
  }

  export type NeighborhoodUncheckedCreateWithoutAddressesInput = {
    id?: string
    name: string
    order?: number | null
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NeighborhoodCreateOrConnectWithoutAddressesInput = {
    where: NeighborhoodWhereUniqueInput
    create: XOR<NeighborhoodCreateWithoutAddressesInput, NeighborhoodUncheckedCreateWithoutAddressesInput>
  }

  export type HotelDetailsCreateWithoutAddressInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUncheckedCreateWithoutAddressInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsCreateOrConnectWithoutAddressInput = {
    where: HotelDetailsWhereUniqueInput
    create: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput>
  }

  export type HotelDetailsCreateManyAddressInputEnvelope = {
    data: HotelDetailsCreateManyAddressInput | HotelDetailsCreateManyAddressInput[]
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type CityUpsertWithoutAddressesInput = {
    update: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type CityUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type NeighborhoodUpsertWithoutAddressesInput = {
    update: XOR<NeighborhoodUpdateWithoutAddressesInput, NeighborhoodUncheckedUpdateWithoutAddressesInput>
    create: XOR<NeighborhoodCreateWithoutAddressesInput, NeighborhoodUncheckedCreateWithoutAddressesInput>
    where?: NeighborhoodWhereInput
  }

  export type NeighborhoodUpdateToOneWithWhereWithoutAddressesInput = {
    where?: NeighborhoodWhereInput
    data: XOR<NeighborhoodUpdateWithoutAddressesInput, NeighborhoodUncheckedUpdateWithoutAddressesInput>
  }

  export type NeighborhoodUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutNeighborhoodsNestedInput
  }

  export type NeighborhoodUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsUpsertWithWhereUniqueWithoutAddressInput = {
    where: HotelDetailsWhereUniqueInput
    update: XOR<HotelDetailsUpdateWithoutAddressInput, HotelDetailsUncheckedUpdateWithoutAddressInput>
    create: XOR<HotelDetailsCreateWithoutAddressInput, HotelDetailsUncheckedCreateWithoutAddressInput>
  }

  export type HotelDetailsUpdateWithWhereUniqueWithoutAddressInput = {
    where: HotelDetailsWhereUniqueInput
    data: XOR<HotelDetailsUpdateWithoutAddressInput, HotelDetailsUncheckedUpdateWithoutAddressInput>
  }

  export type HotelDetailsUpdateManyWithWhereWithoutAddressInput = {
    where: HotelDetailsScalarWhereInput
    data: XOR<HotelDetailsUpdateManyMutationInput, HotelDetailsUncheckedUpdateManyWithoutAddressInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAddressInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAddressInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserUpdateManyWithWhereWithoutAddressInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAddressInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type HotelCardCreateWithoutImagesInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutImagesInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput>
  }

  export type HotelCardUpsertWithWhereUniqueWithoutImagesInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutImagesInput, HotelCardUncheckedUpdateWithoutImagesInput>
    create: XOR<HotelCardCreateWithoutImagesInput, HotelCardUncheckedCreateWithoutImagesInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutImagesInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutImagesInput, HotelCardUncheckedUpdateWithoutImagesInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutImagesInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutImagesInput>
  }

  export type HotelParkingCreateWithoutHotelCardInput = {
    id?: string
    isAvailable?: boolean
    spaces?: number | null
    order?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelParkingUncheckedCreateWithoutHotelCardInput = {
    id?: string
    isAvailable?: boolean
    spaces?: number | null
    order?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelParkingCreateOrConnectWithoutHotelCardInput = {
    where: HotelParkingWhereUniqueInput
    create: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelImageCreateWithoutHotelCardInput = {
    id?: string
    entityId: string
    imageUrl: string
    imageType: string
    order?: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelImageUncheckedCreateWithoutHotelCardInput = {
    id?: string
    entityId: string
    imageUrl: string
    imageType: string
    order?: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelImageCreateOrConnectWithoutHotelCardInput = {
    where: HotelImageWhereUniqueInput
    create: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelAmenityCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityUncheckedCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityCreateOrConnectWithoutHotelCardInput = {
    where: HotelAmenityWhereUniqueInput
    create: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelDetailsCreateWithoutHotelCardInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutHotelDetailsInput
    RoomAmenity?: RoomAmenityCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelCreateNestedManyWithoutHotelDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsUncheckedCreateWithoutHotelCardInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
  }

  export type HotelDetailsCreateOrConnectWithoutHotelCardInput = {
    where: HotelDetailsWhereUniqueInput
    create: XOR<HotelDetailsCreateWithoutHotelCardInput, HotelDetailsUncheckedCreateWithoutHotelCardInput>
  }

  export type AccommodationTypeCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationTypeUncheckedCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationTypeCreateOrConnectWithoutHotelCardInput = {
    where: AccommodationTypeWhereUniqueInput
    create: XOR<AccommodationTypeCreateWithoutHotelCardInput, AccommodationTypeUncheckedCreateWithoutHotelCardInput>
  }

  export type DestinationCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutDestinationsInput
    DestinationToCity?: DestinationToCityCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutDestinationsInput
    DestinationToCity?: DestinationToCityUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutHotelCardInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutHotelCardInput, DestinationUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelGroupCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelGroupUncheckedCreateWithoutHotelCardInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelGroupCreateOrConnectWithoutHotelCardInput = {
    where: HotelGroupWhereUniqueInput
    create: XOR<HotelGroupCreateWithoutHotelCardInput, HotelGroupUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToHotelHighlightCreateWithoutHotelCardInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelHighlight: HotelHighlightCreateNestedOneWithoutHotelCardToHotelHighlightInput
  }

  export type HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput = {
    hotelHighlightId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelHighlightCreateOrConnectWithoutHotelCardInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    create: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToHotelHighlightCreateManyHotelCardInputEnvelope = {
    data: HotelCardToHotelHighlightCreateManyHotelCardInput | HotelCardToHotelHighlightCreateManyHotelCardInput[]
  }

  export type HotelCardToLabelCreateWithoutHotelCardInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    label: LabelCreateNestedOneWithoutHotelCardToLabelInput
  }

  export type HotelCardToLabelUncheckedCreateWithoutHotelCardInput = {
    labelId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelCreateOrConnectWithoutHotelCardInput = {
    where: HotelCardToLabelWhereUniqueInput
    create: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToLabelCreateManyHotelCardInputEnvelope = {
    data: HotelCardToLabelCreateManyHotelCardInput | HotelCardToLabelCreateManyHotelCardInput[]
  }

  export type HotelCardToAccessibilityOptionCreateWithoutHotelCardInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessibilityOption: AccessibilityOptionCreateNestedOneWithoutHotelCardToAccessibilityOptionInput
  }

  export type HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput = {
    accessibilityOptionId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionCreateOrConnectWithoutHotelCardInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    create: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToAccessibilityOptionCreateManyHotelCardInputEnvelope = {
    data: HotelCardToAccessibilityOptionCreateManyHotelCardInput | HotelCardToAccessibilityOptionCreateManyHotelCardInput[]
  }

  export type HotelCardToHotelAmenityCreateWithoutHotelCardInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelAmenity: HotelAmenityCreateNestedOneWithoutHotelCardToHotelAmenityInput
  }

  export type HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput = {
    hotelAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelAmenityCreateOrConnectWithoutHotelCardInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    create: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToHotelAmenityCreateManyHotelCardInputEnvelope = {
    data: HotelCardToHotelAmenityCreateManyHotelCardInput | HotelCardToHotelAmenityCreateManyHotelCardInput[]
  }

  export type HotelParkingUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelParkingWhereUniqueInput
    update: XOR<HotelParkingUpdateWithoutHotelCardInput, HotelParkingUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelParkingCreateWithoutHotelCardInput, HotelParkingUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelParkingUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelParkingWhereUniqueInput
    data: XOR<HotelParkingUpdateWithoutHotelCardInput, HotelParkingUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelParkingUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelParkingScalarWhereInput
    data: XOR<HotelParkingUpdateManyMutationInput, HotelParkingUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelParkingScalarWhereInput = {
    AND?: HotelParkingScalarWhereInput | HotelParkingScalarWhereInput[]
    OR?: HotelParkingScalarWhereInput[]
    NOT?: HotelParkingScalarWhereInput | HotelParkingScalarWhereInput[]
    id?: StringFilter<"HotelParking"> | string
    isAvailable?: BoolFilter<"HotelParking"> | boolean
    spaces?: IntNullableFilter<"HotelParking"> | number | null
    order?: IntNullableFilter<"HotelParking"> | number | null
    notes?: StringNullableFilter<"HotelParking"> | string | null
    createdAt?: DateTimeFilter<"HotelParking"> | Date | string
    updatedAt?: DateTimeFilter<"HotelParking"> | Date | string
  }

  export type HotelImageUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelImageWhereUniqueInput
    update: XOR<HotelImageUpdateWithoutHotelCardInput, HotelImageUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelImageCreateWithoutHotelCardInput, HotelImageUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelImageUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelImageWhereUniqueInput
    data: XOR<HotelImageUpdateWithoutHotelCardInput, HotelImageUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelImageUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelImageScalarWhereInput
    data: XOR<HotelImageUpdateManyMutationInput, HotelImageUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelImageScalarWhereInput = {
    AND?: HotelImageScalarWhereInput | HotelImageScalarWhereInput[]
    OR?: HotelImageScalarWhereInput[]
    NOT?: HotelImageScalarWhereInput | HotelImageScalarWhereInput[]
    id?: StringFilter<"HotelImage"> | string
    entityId?: StringFilter<"HotelImage"> | string
    imageUrl?: StringFilter<"HotelImage"> | string
    imageType?: StringFilter<"HotelImage"> | string
    order?: IntFilter<"HotelImage"> | number
    alt?: StringNullableFilter<"HotelImage"> | string | null
    createdAt?: DateTimeFilter<"HotelImage"> | Date | string
    updatedAt?: DateTimeFilter<"HotelImage"> | Date | string
  }

  export type HotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelAmenityWhereUniqueInput
    update: XOR<HotelAmenityUpdateWithoutHotelCardInput, HotelAmenityUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelAmenityCreateWithoutHotelCardInput, HotelAmenityUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelAmenityWhereUniqueInput
    data: XOR<HotelAmenityUpdateWithoutHotelCardInput, HotelAmenityUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelAmenityUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelAmenityScalarWhereInput
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelAmenityScalarWhereInput = {
    AND?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
    OR?: HotelAmenityScalarWhereInput[]
    NOT?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
    id?: StringFilter<"HotelAmenity"> | string
    name?: StringFilter<"HotelAmenity"> | string
    order?: IntNullableFilter<"HotelAmenity"> | number | null
    category?: StringNullableFilter<"HotelAmenity"> | string | null
    icon?: StringNullableFilter<"HotelAmenity"> | string | null
    description?: StringNullableFilter<"HotelAmenity"> | string | null
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"HotelAmenity"> | Date | string
  }

  export type HotelDetailsUpsertWithoutHotelCardInput = {
    update: XOR<HotelDetailsUpdateWithoutHotelCardInput, HotelDetailsUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelDetailsCreateWithoutHotelCardInput, HotelDetailsUncheckedCreateWithoutHotelCardInput>
    where?: HotelDetailsWhereInput
  }

  export type HotelDetailsUpdateToOneWithWhereWithoutHotelCardInput = {
    where?: HotelDetailsWhereInput
    data: XOR<HotelDetailsUpdateWithoutHotelCardInput, HotelDetailsUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelDetailsUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutHotelDetailsNestedInput
    RoomAmenity?: RoomAmenityUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUpdateManyWithoutHotelDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
  }

  export type AccommodationTypeUpsertWithoutHotelCardInput = {
    update: XOR<AccommodationTypeUpdateWithoutHotelCardInput, AccommodationTypeUncheckedUpdateWithoutHotelCardInput>
    create: XOR<AccommodationTypeCreateWithoutHotelCardInput, AccommodationTypeUncheckedCreateWithoutHotelCardInput>
    where?: AccommodationTypeWhereInput
  }

  export type AccommodationTypeUpdateToOneWithWhereWithoutHotelCardInput = {
    where?: AccommodationTypeWhereInput
    data: XOR<AccommodationTypeUpdateWithoutHotelCardInput, AccommodationTypeUncheckedUpdateWithoutHotelCardInput>
  }

  export type AccommodationTypeUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationTypeUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUpsertWithoutHotelCardInput = {
    update: XOR<DestinationUpdateWithoutHotelCardInput, DestinationUncheckedUpdateWithoutHotelCardInput>
    create: XOR<DestinationCreateWithoutHotelCardInput, DestinationUncheckedCreateWithoutHotelCardInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutHotelCardInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutHotelCardInput, DestinationUncheckedUpdateWithoutHotelCardInput>
  }

  export type DestinationUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutDestinationsNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutDestinationsNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type HotelGroupUpsertWithoutHotelCardInput = {
    update: XOR<HotelGroupUpdateWithoutHotelCardInput, HotelGroupUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelGroupCreateWithoutHotelCardInput, HotelGroupUncheckedCreateWithoutHotelCardInput>
    where?: HotelGroupWhereInput
  }

  export type HotelGroupUpdateToOneWithWhereWithoutHotelCardInput = {
    where?: HotelGroupWhereInput
    data: XOR<HotelGroupUpdateWithoutHotelCardInput, HotelGroupUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelGroupUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelGroupUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    update: XOR<HotelCardToHotelHighlightUpdateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelCardToHotelHighlightCreateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToHotelHighlightUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToHotelHighlightWhereUniqueInput
    data: XOR<HotelCardToHotelHighlightUpdateWithoutHotelCardInput, HotelCardToHotelHighlightUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelCardToHotelHighlightUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelCardToHotelHighlightScalarWhereInput
    data: XOR<HotelCardToHotelHighlightUpdateManyMutationInput, HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelCardToLabelUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToLabelWhereUniqueInput
    update: XOR<HotelCardToLabelUpdateWithoutHotelCardInput, HotelCardToLabelUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelCardToLabelCreateWithoutHotelCardInput, HotelCardToLabelUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToLabelUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToLabelWhereUniqueInput
    data: XOR<HotelCardToLabelUpdateWithoutHotelCardInput, HotelCardToLabelUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelCardToLabelUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelCardToLabelScalarWhereInput
    data: XOR<HotelCardToLabelUpdateManyMutationInput, HotelCardToLabelUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelCardToAccessibilityOptionUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    update: XOR<HotelCardToAccessibilityOptionUpdateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelCardToAccessibilityOptionCreateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToAccessibilityOptionUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToAccessibilityOptionWhereUniqueInput
    data: XOR<HotelCardToAccessibilityOptionUpdateWithoutHotelCardInput, HotelCardToAccessibilityOptionUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelCardToAccessibilityOptionUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelCardToAccessibilityOptionScalarWhereInput
    data: XOR<HotelCardToAccessibilityOptionUpdateManyMutationInput, HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type HotelCardToHotelAmenityUpsertWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    update: XOR<HotelCardToHotelAmenityUpdateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedUpdateWithoutHotelCardInput>
    create: XOR<HotelCardToHotelAmenityCreateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedCreateWithoutHotelCardInput>
  }

  export type HotelCardToHotelAmenityUpdateWithWhereUniqueWithoutHotelCardInput = {
    where: HotelCardToHotelAmenityWhereUniqueInput
    data: XOR<HotelCardToHotelAmenityUpdateWithoutHotelCardInput, HotelCardToHotelAmenityUncheckedUpdateWithoutHotelCardInput>
  }

  export type HotelCardToHotelAmenityUpdateManyWithWhereWithoutHotelCardInput = {
    where: HotelCardToHotelAmenityScalarWhereInput
    data: XOR<HotelCardToHotelAmenityUpdateManyMutationInput, HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardInput>
  }

  export type AddressCreateWithoutHotelDetailsInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAddressesInput
    neighborhood?: NeighborhoodCreateNestedOneWithoutAddressesInput
    user?: UserCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutHotelDetailsInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutHotelDetailsInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutHotelDetailsInput, AddressUncheckedCreateWithoutHotelDetailsInput>
  }

  export type RoomAmenityCreateWithoutHotelDetailsInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityUncheckedCreateWithoutHotelDetailsInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityCreateOrConnectWithoutHotelDetailsInput = {
    where: RoomAmenityWhereUniqueInput
    create: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput>
  }

  export type LabelCreateWithoutHotelDetailsInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutHotelDetailsInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutHotelDetailsInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput>
  }

  export type LabelCreateManyHotelDetailsInputEnvelope = {
    data: LabelCreateManyHotelDetailsInput | LabelCreateManyHotelDetailsInput[]
  }

  export type HotelCardCreateWithoutDetailsInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutDetailsInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutDetailsInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput>
  }

  export type HotelCardCreateManyDetailsInputEnvelope = {
    data: HotelCardCreateManyDetailsInput | HotelCardCreateManyDetailsInput[]
  }

  export type HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput = {
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roomAmenity: RoomAmenityCreateNestedOneWithoutHotelDetailsToRoomAmenityInput
  }

  export type HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput = {
    roomAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsToRoomAmenityCreateOrConnectWithoutHotelDetailsInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    create: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput>
  }

  export type HotelDetailsToRoomAmenityCreateManyHotelDetailsInputEnvelope = {
    data: HotelDetailsToRoomAmenityCreateManyHotelDetailsInput | HotelDetailsToRoomAmenityCreateManyHotelDetailsInput[]
  }

  export type AddressUpsertWithoutHotelDetailsInput = {
    update: XOR<AddressUpdateWithoutHotelDetailsInput, AddressUncheckedUpdateWithoutHotelDetailsInput>
    create: XOR<AddressCreateWithoutHotelDetailsInput, AddressUncheckedCreateWithoutHotelDetailsInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutHotelDetailsInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutHotelDetailsInput, AddressUncheckedUpdateWithoutHotelDetailsInput>
  }

  export type AddressUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    neighborhood?: NeighborhoodUpdateOneWithoutAddressesNestedInput
    user?: UserUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type RoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput = {
    where: RoomAmenityWhereUniqueInput
    update: XOR<RoomAmenityUpdateWithoutHotelDetailsInput, RoomAmenityUncheckedUpdateWithoutHotelDetailsInput>
    create: XOR<RoomAmenityCreateWithoutHotelDetailsInput, RoomAmenityUncheckedCreateWithoutHotelDetailsInput>
  }

  export type RoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput = {
    where: RoomAmenityWhereUniqueInput
    data: XOR<RoomAmenityUpdateWithoutHotelDetailsInput, RoomAmenityUncheckedUpdateWithoutHotelDetailsInput>
  }

  export type RoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput = {
    where: RoomAmenityScalarWhereInput
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyWithoutHotelDetailsInput>
  }

  export type RoomAmenityScalarWhereInput = {
    AND?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
    OR?: RoomAmenityScalarWhereInput[]
    NOT?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
    id?: StringFilter<"RoomAmenity"> | string
    name?: StringFilter<"RoomAmenity"> | string
    order?: IntNullableFilter<"RoomAmenity"> | number | null
    category?: StringFilter<"RoomAmenity"> | string
    icon?: StringNullableFilter<"RoomAmenity"> | string | null
    description?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
  }

  export type LabelUpsertWithWhereUniqueWithoutHotelDetailsInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutHotelDetailsInput, LabelUncheckedUpdateWithoutHotelDetailsInput>
    create: XOR<LabelCreateWithoutHotelDetailsInput, LabelUncheckedCreateWithoutHotelDetailsInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutHotelDetailsInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutHotelDetailsInput, LabelUncheckedUpdateWithoutHotelDetailsInput>
  }

  export type LabelUpdateManyWithWhereWithoutHotelDetailsInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutHotelDetailsInput>
  }

  export type LabelScalarWhereInput = {
    AND?: LabelScalarWhereInput | LabelScalarWhereInput[]
    OR?: LabelScalarWhereInput[]
    NOT?: LabelScalarWhereInput | LabelScalarWhereInput[]
    id?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    order?: IntNullableFilter<"Label"> | number | null
    code?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    category?: StringFilter<"Label"> | string
    icon?: StringNullableFilter<"Label"> | string | null
    color?: StringNullableFilter<"Label"> | string | null
    priority?: IntFilter<"Label"> | number
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    hotelDetailsId?: StringNullableFilter<"Label"> | string | null
  }

  export type HotelCardUpsertWithWhereUniqueWithoutDetailsInput = {
    where: HotelCardWhereUniqueInput
    update: XOR<HotelCardUpdateWithoutDetailsInput, HotelCardUncheckedUpdateWithoutDetailsInput>
    create: XOR<HotelCardCreateWithoutDetailsInput, HotelCardUncheckedCreateWithoutDetailsInput>
  }

  export type HotelCardUpdateWithWhereUniqueWithoutDetailsInput = {
    where: HotelCardWhereUniqueInput
    data: XOR<HotelCardUpdateWithoutDetailsInput, HotelCardUncheckedUpdateWithoutDetailsInput>
  }

  export type HotelCardUpdateManyWithWhereWithoutDetailsInput = {
    where: HotelCardScalarWhereInput
    data: XOR<HotelCardUpdateManyMutationInput, HotelCardUncheckedUpdateManyWithoutDetailsInput>
  }

  export type HotelDetailsToRoomAmenityUpsertWithWhereUniqueWithoutHotelDetailsInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    update: XOR<HotelDetailsToRoomAmenityUpdateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedUpdateWithoutHotelDetailsInput>
    create: XOR<HotelDetailsToRoomAmenityCreateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedCreateWithoutHotelDetailsInput>
  }

  export type HotelDetailsToRoomAmenityUpdateWithWhereUniqueWithoutHotelDetailsInput = {
    where: HotelDetailsToRoomAmenityWhereUniqueInput
    data: XOR<HotelDetailsToRoomAmenityUpdateWithoutHotelDetailsInput, HotelDetailsToRoomAmenityUncheckedUpdateWithoutHotelDetailsInput>
  }

  export type HotelDetailsToRoomAmenityUpdateManyWithWhereWithoutHotelDetailsInput = {
    where: HotelDetailsToRoomAmenityScalarWhereInput
    data: XOR<HotelDetailsToRoomAmenityUpdateManyMutationInput, HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsInput>
  }

  export type HotelCardCreateWithoutHotelCardToHotelHighlightInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelCardToHotelHighlightInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelCardToHotelHighlightInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedCreateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelHighlightCreateWithoutHotelCardToHotelHighlightInput = {
    id?: string
    title: string
    order?: number | null
    description?: string | null
    category: string
    icon?: string | null
    priority?: number
    isPromoted?: boolean
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelHighlightUncheckedCreateWithoutHotelCardToHotelHighlightInput = {
    id?: string
    title: string
    order?: number | null
    description?: string | null
    category: string
    icon?: string | null
    priority?: number
    isPromoted?: boolean
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelHighlightCreateOrConnectWithoutHotelCardToHotelHighlightInput = {
    where: HotelHighlightWhereUniqueInput
    create: XOR<HotelHighlightCreateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedCreateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelCardUpsertWithoutHotelCardToHotelHighlightInput = {
    update: XOR<HotelCardUpdateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
    create: XOR<HotelCardCreateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    where?: HotelCardWhereInput
  }

  export type HotelCardUpdateToOneWithWhereWithoutHotelCardToHotelHighlightInput = {
    where?: HotelCardWhereInput
    data: XOR<HotelCardUpdateWithoutHotelCardToHotelHighlightInput, HotelCardUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelCardUpdateWithoutHotelCardToHotelHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelCardToHotelHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelHighlightUpsertWithoutHotelCardToHotelHighlightInput = {
    update: XOR<HotelHighlightUpdateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
    create: XOR<HotelHighlightCreateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedCreateWithoutHotelCardToHotelHighlightInput>
    where?: HotelHighlightWhereInput
  }

  export type HotelHighlightUpdateToOneWithWhereWithoutHotelCardToHotelHighlightInput = {
    where?: HotelHighlightWhereInput
    data: XOR<HotelHighlightUpdateWithoutHotelCardToHotelHighlightInput, HotelHighlightUncheckedUpdateWithoutHotelCardToHotelHighlightInput>
  }

  export type HotelHighlightUpdateWithoutHotelCardToHotelHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelHighlightUncheckedUpdateWithoutHotelCardToHotelHighlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardCreateWithoutHotelCardToLabelInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelCardToLabelInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelCardToLabelInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelCardToLabelInput, HotelCardUncheckedCreateWithoutHotelCardToLabelInput>
  }

  export type LabelCreateWithoutHotelCardToLabelInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsCreateNestedOneWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutHotelCardToLabelInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelDetailsId?: string | null
  }

  export type LabelCreateOrConnectWithoutHotelCardToLabelInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutHotelCardToLabelInput, LabelUncheckedCreateWithoutHotelCardToLabelInput>
  }

  export type HotelCardUpsertWithoutHotelCardToLabelInput = {
    update: XOR<HotelCardUpdateWithoutHotelCardToLabelInput, HotelCardUncheckedUpdateWithoutHotelCardToLabelInput>
    create: XOR<HotelCardCreateWithoutHotelCardToLabelInput, HotelCardUncheckedCreateWithoutHotelCardToLabelInput>
    where?: HotelCardWhereInput
  }

  export type HotelCardUpdateToOneWithWhereWithoutHotelCardToLabelInput = {
    where?: HotelCardWhereInput
    data: XOR<HotelCardUpdateWithoutHotelCardToLabelInput, HotelCardUncheckedUpdateWithoutHotelCardToLabelInput>
  }

  export type HotelCardUpdateWithoutHotelCardToLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelCardToLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type LabelUpsertWithoutHotelCardToLabelInput = {
    update: XOR<LabelUpdateWithoutHotelCardToLabelInput, LabelUncheckedUpdateWithoutHotelCardToLabelInput>
    create: XOR<LabelCreateWithoutHotelCardToLabelInput, LabelUncheckedCreateWithoutHotelCardToLabelInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutHotelCardToLabelInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutHotelCardToLabelInput, LabelUncheckedUpdateWithoutHotelCardToLabelInput>
  }

  export type LabelUpdateWithoutHotelCardToLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUpdateOneWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutHotelCardToLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCardCreateWithoutHotelCardToAccessibilityOptionInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelCardToAccessibilityOptionInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelCardToAccessibilityOptionInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type AccessibilityOptionCreateWithoutHotelCardToAccessibilityOptionInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessibilityOptionUncheckedCreateWithoutHotelCardToAccessibilityOptionInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessibilityOptionCreateOrConnectWithoutHotelCardToAccessibilityOptionInput = {
    where: AccessibilityOptionWhereUniqueInput
    create: XOR<AccessibilityOptionCreateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type HotelCardUpsertWithoutHotelCardToAccessibilityOptionInput = {
    update: XOR<HotelCardUpdateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
    create: XOR<HotelCardCreateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    where?: HotelCardWhereInput
  }

  export type HotelCardUpdateToOneWithWhereWithoutHotelCardToAccessibilityOptionInput = {
    where?: HotelCardWhereInput
    data: XOR<HotelCardUpdateWithoutHotelCardToAccessibilityOptionInput, HotelCardUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type HotelCardUpdateWithoutHotelCardToAccessibilityOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type AccessibilityOptionUpsertWithoutHotelCardToAccessibilityOptionInput = {
    update: XOR<AccessibilityOptionUpdateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
    create: XOR<AccessibilityOptionCreateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedCreateWithoutHotelCardToAccessibilityOptionInput>
    where?: AccessibilityOptionWhereInput
  }

  export type AccessibilityOptionUpdateToOneWithWhereWithoutHotelCardToAccessibilityOptionInput = {
    where?: AccessibilityOptionWhereInput
    data: XOR<AccessibilityOptionUpdateWithoutHotelCardToAccessibilityOptionInput, AccessibilityOptionUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput>
  }

  export type AccessibilityOptionUpdateWithoutHotelCardToAccessibilityOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessibilityOptionUncheckedUpdateWithoutHotelCardToAccessibilityOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardCreateWithoutHotelCardToHotelAmenityInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    latitude?: number | null
    longitude?: number | null
    parking?: HotelParkingCreateNestedManyWithoutHotelCardInput
    images?: HotelImageCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityCreateNestedManyWithoutHotelCardInput
    details?: HotelDetailsCreateNestedOneWithoutHotelCardInput
    accommodationType?: AccommodationTypeCreateNestedOneWithoutHotelCardInput
    destination?: DestinationCreateNestedOneWithoutHotelCardInput
    hotelGroup?: HotelGroupCreateNestedOneWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardUncheckedCreateWithoutHotelCardToHotelAmenityInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
    parking?: HotelParkingUncheckedCreateNestedManyWithoutHotelCardInput
    images?: HotelImageUncheckedCreateNestedManyWithoutHotelCardInput
    HotelAmenity?: HotelAmenityUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToLabel?: HotelCardToLabelUncheckedCreateNestedManyWithoutHotelCardInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedCreateNestedManyWithoutHotelCardInput
  }

  export type HotelCardCreateOrConnectWithoutHotelCardToHotelAmenityInput = {
    where: HotelCardWhereUniqueInput
    create: XOR<HotelCardCreateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelAmenityCreateWithoutHotelCardToHotelAmenityInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityUncheckedCreateWithoutHotelCardToHotelAmenityInput = {
    id?: string
    name: string
    order?: number | null
    category?: string | null
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutHotelAmenityInput
  }

  export type HotelAmenityCreateOrConnectWithoutHotelCardToHotelAmenityInput = {
    where: HotelAmenityWhereUniqueInput
    create: XOR<HotelAmenityCreateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedCreateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelCardUpsertWithoutHotelCardToHotelAmenityInput = {
    update: XOR<HotelCardUpdateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
    create: XOR<HotelCardCreateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    where?: HotelCardWhereInput
  }

  export type HotelCardUpdateToOneWithWhereWithoutHotelCardToHotelAmenityInput = {
    where?: HotelCardWhereInput
    data: XOR<HotelCardUpdateWithoutHotelCardToHotelAmenityInput, HotelCardUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelCardUpdateWithoutHotelCardToHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelCardToHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelAmenityUpsertWithoutHotelCardToHotelAmenityInput = {
    update: XOR<HotelAmenityUpdateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
    create: XOR<HotelAmenityCreateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedCreateWithoutHotelCardToHotelAmenityInput>
    where?: HotelAmenityWhereInput
  }

  export type HotelAmenityUpdateToOneWithWhereWithoutHotelCardToHotelAmenityInput = {
    where?: HotelAmenityWhereInput
    data: XOR<HotelAmenityUpdateWithoutHotelCardToHotelAmenityInput, HotelAmenityUncheckedUpdateWithoutHotelCardToHotelAmenityInput>
  }

  export type HotelAmenityUpdateWithoutHotelCardToHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelAmenityUncheckedUpdateWithoutHotelCardToHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelDetailsCreateWithoutHotelDetailsToRoomAmenityInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address: AddressCreateNestedOneWithoutHotelDetailsInput
    RoomAmenity?: RoomAmenityCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardCreateNestedManyWithoutDetailsInput
  }

  export type HotelDetailsUncheckedCreateWithoutHotelDetailsToRoomAmenityInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    addressId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomAmenity?: RoomAmenityUncheckedCreateNestedManyWithoutHotelDetailsInput
    Label?: LabelUncheckedCreateNestedManyWithoutHotelDetailsInput
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDetailsInput
  }

  export type HotelDetailsCreateOrConnectWithoutHotelDetailsToRoomAmenityInput = {
    where: HotelDetailsWhereUniqueInput
    create: XOR<HotelDetailsCreateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type RoomAmenityCreateWithoutHotelDetailsToRoomAmenityInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityUncheckedCreateWithoutHotelDetailsToRoomAmenityInput = {
    id?: string
    name: string
    order?: number | null
    category: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelDetails?: HotelDetailsUncheckedCreateNestedManyWithoutRoomAmenityInput
  }

  export type RoomAmenityCreateOrConnectWithoutHotelDetailsToRoomAmenityInput = {
    where: RoomAmenityWhereUniqueInput
    create: XOR<RoomAmenityCreateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type HotelDetailsUpsertWithoutHotelDetailsToRoomAmenityInput = {
    update: XOR<HotelDetailsUpdateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
    create: XOR<HotelDetailsCreateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    where?: HotelDetailsWhereInput
  }

  export type HotelDetailsUpdateToOneWithWhereWithoutHotelDetailsToRoomAmenityInput = {
    where?: HotelDetailsWhereInput
    data: XOR<HotelDetailsUpdateWithoutHotelDetailsToRoomAmenityInput, HotelDetailsUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type HotelDetailsUpdateWithoutHotelDetailsToRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutHotelDetailsNestedInput
    RoomAmenity?: RoomAmenityUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUpdateManyWithoutDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDetailsNestedInput
  }

  export type RoomAmenityUpsertWithoutHotelDetailsToRoomAmenityInput = {
    update: XOR<RoomAmenityUpdateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
    create: XOR<RoomAmenityCreateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedCreateWithoutHotelDetailsToRoomAmenityInput>
    where?: RoomAmenityWhereInput
  }

  export type RoomAmenityUpdateToOneWithWhereWithoutHotelDetailsToRoomAmenityInput = {
    where?: RoomAmenityWhereInput
    data: XOR<RoomAmenityUpdateWithoutHotelDetailsToRoomAmenityInput, RoomAmenityUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput>
  }

  export type RoomAmenityUpdateWithoutHotelDetailsToRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUpdateManyWithoutRoomAmenityNestedInput
  }

  export type RoomAmenityUncheckedUpdateWithoutHotelDetailsToRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetails?: HotelDetailsUncheckedUpdateManyWithoutRoomAmenityNestedInput
  }

  export type DestinationCreateWithoutDestinationToCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardCreateNestedManyWithoutDestinationInput
    City?: CityCreateNestedManyWithoutDestinationsInput
  }

  export type DestinationUncheckedCreateWithoutDestinationToCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    popularityScore?: number
    cityId: string
    latitude?: number | null
    longitude?: number | null
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HotelCard?: HotelCardUncheckedCreateNestedManyWithoutDestinationInput
    City?: CityUncheckedCreateNestedManyWithoutDestinationsInput
  }

  export type DestinationCreateOrConnectWithoutDestinationToCityInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutDestinationToCityInput, DestinationUncheckedCreateWithoutDestinationToCityInput>
  }

  export type CityCreateWithoutDestinationToCityInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    neighborhoods?: NeighborhoodCreateNestedManyWithoutCityInput
    landmarks?: LandmarkCreateNestedManyWithoutCityInput
    addresses?: AddressCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDestinationToCityInput = {
    id?: string
    name: string
    order?: number | null
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    neighborhoods?: NeighborhoodUncheckedCreateNestedManyWithoutCityInput
    landmarks?: LandmarkUncheckedCreateNestedManyWithoutCityInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDestinationToCityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDestinationToCityInput, CityUncheckedCreateWithoutDestinationToCityInput>
  }

  export type DestinationUpsertWithoutDestinationToCityInput = {
    update: XOR<DestinationUpdateWithoutDestinationToCityInput, DestinationUncheckedUpdateWithoutDestinationToCityInput>
    create: XOR<DestinationCreateWithoutDestinationToCityInput, DestinationUncheckedCreateWithoutDestinationToCityInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutDestinationToCityInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutDestinationToCityInput, DestinationUncheckedUpdateWithoutDestinationToCityInput>
  }

  export type DestinationUpdateWithoutDestinationToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutDestinationNestedInput
    City?: CityUpdateManyWithoutDestinationsNestedInput
  }

  export type DestinationUncheckedUpdateWithoutDestinationToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDestinationNestedInput
    City?: CityUncheckedUpdateManyWithoutDestinationsNestedInput
  }

  export type CityUpsertWithoutDestinationToCityInput = {
    update: XOR<CityUpdateWithoutDestinationToCityInput, CityUncheckedUpdateWithoutDestinationToCityInput>
    create: XOR<CityCreateWithoutDestinationToCityInput, CityUncheckedCreateWithoutDestinationToCityInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDestinationToCityInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDestinationToCityInput, CityUncheckedUpdateWithoutDestinationToCityInput>
  }

  export type CityUpdateWithoutDestinationToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDestinationToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    neighborhood?: NeighborhoodUpdateOneWithoutAddressesNestedInput
    hotelDetails?: HotelDetailsUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyCountryInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeighborhoodCreateManyCityInput = {
    id?: string
    name: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandmarkCreateManyCityInput = {
    id?: string
    name: string
    order?: number | null
    description?: string | null
    type: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyCityInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    neighborhoodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationToCityCreateManyCityInput = {
    destinationId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NeighborhoodUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutNeighborhoodNestedInput
  }

  export type NeighborhoodUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutNeighborhoodNestedInput
  }

  export type NeighborhoodUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandmarkUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhood?: NeighborhoodUpdateOneWithoutAddressesNestedInput
    hotelDetails?: HotelDetailsUpdateManyWithoutAddressNestedInput
    user?: UserUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUncheckedUpdateManyWithoutAddressNestedInput
    user?: UserUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    neighborhoodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUpdateManyWithoutDestinationNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDestinationNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    popularityScore?: IntFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityUpdateWithoutCityInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutDestinationToCityNestedInput
  }

  export type DestinationToCityUncheckedUpdateWithoutCityInput = {
    destinationId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityUncheckedUpdateManyWithoutCityInput = {
    destinationId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyNeighborhoodInput = {
    id?: string
    streetNumber?: string | null
    streetName: string
    addressLine2?: string | null
    postalCode: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutNeighborhoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAddressesNestedInput
    hotelDetails?: HotelDetailsUpdateManyWithoutAddressNestedInput
    user?: UserUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutNeighborhoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUncheckedUpdateManyWithoutAddressNestedInput
    user?: UserUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutNeighborhoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    streetName?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardCreateManyAccommodationTypeInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
  }

  export type HotelCardUpdateWithoutAccommodationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutAccommodationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutAccommodationTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCardCreateManyDestinationInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
  }

  export type DestinationToCityCreateManyDestinationInput = {
    cityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CityUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    neighborhoods?: NeighborhoodUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUpdateManyWithoutCityNestedInput
    addresses?: AddressUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    neighborhoods?: NeighborhoodUncheckedUpdateManyWithoutCityNestedInput
    landmarks?: LandmarkUncheckedUpdateManyWithoutCityNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCityNestedInput
    DestinationToCity?: DestinationToCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityUpdateWithoutDestinationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutDestinationToCityNestedInput
  }

  export type DestinationToCityUncheckedUpdateWithoutDestinationInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationToCityUncheckedUpdateManyWithoutDestinationInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelCreateManyLabelInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelUpdateWithoutLabelInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToLabelNestedInput
  }

  export type HotelCardToLabelUncheckedUpdateWithoutLabelInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelUncheckedUpdateManyWithoutLabelInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardCreateManyHotelGroupInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    latitude?: number | null
    longitude?: number | null
    detailsId?: string | null
  }

  export type HotelCardUpdateWithoutHotelGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutHotelGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCardToHotelHighlightCreateManyHotelHighlightInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelHighlightUpdateWithoutHotelHighlightInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput
  }

  export type HotelCardToHotelHighlightUncheckedUpdateWithoutHotelHighlightInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelHighlightInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityCreateManyHotelAmenityInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardUpdateWithoutHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutHotelAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCardToHotelAmenityUpdateWithoutHotelAmenityInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput
  }

  export type HotelCardToHotelAmenityUncheckedUpdateWithoutHotelAmenityInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelAmenityInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityCreateManyRoomAmenityInput = {
    hotelDetailsId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsUpdateWithoutRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutHotelDetailsNestedInput
    Label?: LabelUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateWithoutRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Label?: LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateManyWithoutRoomAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityUpdateWithoutRoomAmenityInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelDetails?: HotelDetailsUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateWithoutRoomAmenityInput = {
    hotelDetailsId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutRoomAmenityInput = {
    hotelDetailsId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionCreateManyAccessibilityOptionInput = {
    hotelCardId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionUpdateWithoutAccessibilityOptionInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelCard?: HotelCardUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateWithoutAccessibilityOptionInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutAccessibilityOptionInput = {
    hotelCardId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardUpdateWithoutParkingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutParkingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutParkingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelDetailsCreateManyAddressInput = {
    id?: string
    idHotelCard: string
    description?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelDetailsUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomAmenity?: RoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
    Label?: LabelUncheckedUpdateManyWithoutHotelDetailsNestedInput
    HotelCard?: HotelCardUncheckedUpdateManyWithoutDetailsNestedInput
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsNestedInput
  }

  export type HotelDetailsUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    idHotelCard?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    details?: HotelDetailsUpdateOneWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    detailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCardToHotelHighlightCreateManyHotelCardInput = {
    hotelHighlightId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToLabelCreateManyHotelCardInput = {
    labelId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToAccessibilityOptionCreateManyHotelCardInput = {
    accessibilityOptionId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardToHotelAmenityCreateManyHotelCardInput = {
    hotelAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelParkingUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelParkingUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelParkingUncheckedUpdateManyWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    spaces?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelImageUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelImageUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelImageUncheckedUpdateManyWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageType?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelAmenityUncheckedUpdateWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelAmenityNestedInput
  }

  export type HotelAmenityUncheckedUpdateManyWithoutHotelCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightUpdateWithoutHotelCardInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelHighlight?: HotelHighlightUpdateOneRequiredWithoutHotelCardToHotelHighlightNestedInput
  }

  export type HotelCardToHotelHighlightUncheckedUpdateWithoutHotelCardInput = {
    hotelHighlightId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardInput = {
    hotelHighlightId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelUpdateWithoutHotelCardInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: LabelUpdateOneRequiredWithoutHotelCardToLabelNestedInput
  }

  export type HotelCardToLabelUncheckedUpdateWithoutHotelCardInput = {
    labelId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToLabelUncheckedUpdateManyWithoutHotelCardInput = {
    labelId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionUpdateWithoutHotelCardInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessibilityOption?: AccessibilityOptionUpdateOneRequiredWithoutHotelCardToAccessibilityOptionNestedInput
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateWithoutHotelCardInput = {
    accessibilityOptionId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardInput = {
    accessibilityOptionId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityUpdateWithoutHotelCardInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelAmenity?: HotelAmenityUpdateOneRequiredWithoutHotelCardToHotelAmenityNestedInput
  }

  export type HotelCardToHotelAmenityUncheckedUpdateWithoutHotelCardInput = {
    hotelAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardInput = {
    hotelAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateManyHotelDetailsInput = {
    id?: string
    name: string
    order?: number | null
    code: string
    description?: string | null
    category: string
    icon?: string | null
    color?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelCardCreateManyDetailsInput = {
    id?: string
    name: string
    idCity: string
    order?: number
    shortDescription?: string | null
    starRating: number
    overallRating?: number | null
    ratingAdjective?: string | null
    reviewCount?: number
    basePricePerNight: number
    regularPrice?: number | null
    currency?: string
    isPartner?: boolean
    promoMessage?: string | null
    imageMessage?: string | null
    cancellationPolicy?: string | null
    accommodationTypeId?: string | null
    destinationId?: string | null
    hotelGroupId?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type HotelDetailsToRoomAmenityCreateManyHotelDetailsInput = {
    roomAmenityId: string
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUpdateManyWithoutRoomAmenityNestedInput
  }

  export type RoomAmenityUncheckedUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelDetailsToRoomAmenity?: HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutRoomAmenityNestedInput
  }

  export type RoomAmenityUncheckedUpdateManyWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutHotelDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCardUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUpdateManyWithoutHotelCardNestedInput
    accommodationType?: AccommodationTypeUpdateOneWithoutHotelCardNestedInput
    destination?: DestinationUpdateOneWithoutHotelCardNestedInput
    hotelGroup?: HotelGroupUpdateOneWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    parking?: HotelParkingUncheckedUpdateManyWithoutHotelCardNestedInput
    images?: HotelImageUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelAmenity?: HotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelHighlight?: HotelCardToHotelHighlightUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToLabel?: HotelCardToLabelUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToAccessibilityOption?: HotelCardToAccessibilityOptionUncheckedUpdateManyWithoutHotelCardNestedInput
    HotelCardToHotelAmenity?: HotelCardToHotelAmenityUncheckedUpdateManyWithoutHotelCardNestedInput
  }

  export type HotelCardUncheckedUpdateManyWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    idCity?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    starRating?: IntFieldUpdateOperationsInput | number
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingAdjective?: NullableStringFieldUpdateOperationsInput | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    basePricePerNight?: FloatFieldUpdateOperationsInput | number
    regularPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    promoMessage?: NullableStringFieldUpdateOperationsInput | string | null
    imageMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    hotelGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HotelDetailsToRoomAmenityUpdateWithoutHotelDetailsInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomAmenity?: RoomAmenityUpdateOneRequiredWithoutHotelDetailsToRoomAmenityNestedInput
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateWithoutHotelDetailsInput = {
    roomAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelDetailsToRoomAmenityUncheckedUpdateManyWithoutHotelDetailsInput = {
    roomAmenityId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}